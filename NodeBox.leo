<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20250718093121.1" a="E"><vh>+ APP +</vh>
<v t="karstenw.20170704103837.1"><vh>@clean macboot.py</vh>
<v t="karstenw.20170704103857.1"><vh>Declarations 1</vh></v>
<v t="karstenw.20210322113242.1"><vh>python3 stuff</vh></v>
<v t="karstenw.20210322113320.1"><vh>Declarations 2</vh></v>
<v t="karstenw.20170704103935.1"><vh>main</vh></v>
</v>
<v t="karstenw.20170704103951.1"><vh>@clean setup.py</vh>
<v t="karstenw.20170704104003.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20170804151930.1"><vh>@clean setup_large.py</vh>
<v t="karstenw.20170804152129.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20170704104018.1"><vh>@clean setup_console.py</vh>
<v t="karstenw.20170704104030.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20170704104045.1"><vh>nodebox</vh>
<v t="karstenw.20170704104053.1"><vh>@clean nodebox/__init__.py</vh>
<v t="karstenw.20170704104119.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20170704104119.2"><vh>get_version</vh></v>
</v>
<v t="karstenw.20230718111102.1"><vh>@clean nodebox/console.py</vh>
<v t="karstenw.20230718111113.1"><vh>Declarations</vh></v>
<v t="karstenw.20230718111113.2"><vh>class NodeBoxRunner</vh>
<v t="karstenw.20230718111113.3"><vh>__init__</vh></v>
<v t="karstenw.20230718111113.4"><vh>_check_animation</vh></v>
<v t="karstenw.20230718111113.5"><vh>run</vh></v>
<v t="karstenw.20230718111113.6"><vh>run_multiple</vh></v>
<v t="karstenw.20230718111113.7"><vh>_initNamespace</vh></v>
</v>
<v t="karstenw.20230718111113.8"><vh>make_image</vh></v>
<v t="karstenw.20230718111113.9"><vh>make_movie</vh></v>
<v t="karstenw.20230718111113.10"><vh>usage</vh></v>
<v t="karstenw.20230718111113.11"><vh>main</vh></v>
<v t="karstenw.20230718111113.12"><vh>test</vh></v>
</v>
<v t="karstenw.20170704104150.1"><vh>@clean nodebox/PyFontify.py</vh>
<v t="karstenw.20170704104209.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20210323114020.1"><vh>init</vh></v>
<v t="karstenw.20170704104209.2"><vh>fontify</vh></v>
<v t="karstenw.20170704104209.3"><vh>test</vh></v>
</v>
<v t="karstenw.20170704104453.1"><vh>geo</vh>
<v t="karstenw.20170704104531.1"><vh>@clean nodebox/geo/__init__.py</vh>
<v t="karstenw.20170704104618.1"><vh>Declarations</vh></v>
<v t="karstenw.20170726154241.1"><vh>Python Functions</vh></v>
<v t="karstenw.20170726154315.1"><vh>C Functions</vh></v>
<v t="karstenw.20170726133907.1"><vh>benchmark</vh></v>
<v t="karstenw.20170704104618.2"><vh>reflect</vh></v>
</v>
<v t="karstenw.20170704104605.1"><vh>@clean nodebox/geo/pathmatics.py</vh>
<v t="karstenw.20170704104615.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704104615.2"><vh>linepoint</vh></v>
<v t="karstenw.20170704104615.3"><vh>linelength</vh></v>
<v t="karstenw.20170704104615.4"><vh>curvepoint</vh></v>
<v t="karstenw.20170704104615.5"><vh>curvelength</vh></v>
</v>
</v>
<v t="karstenw.20170704104455.1"><vh>graphics</vh>
<v t="karstenw.20170704104646.1"><vh>@clean nodebox/graphics/__init__.py</vh>
<v t="karstenw.20170704104725.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20170704104725.2" a="E"><vh>class Context</vh>
<v t="karstenw.20170704104725.3"><vh>__init__</vh></v>
<v t="karstenw.20170704104725.4"><vh>_resetContext</vh></v>
<v t="karstenw.20230217121258.1"><vh>scanmodule</vh></v>
<v t="karstenw.20170704104725.5"><vh>ximport</vh></v>
<v t="karstenw.20170709143724.1" a="E"><vh>## Setup Methods ##</vh>
<v t="karstenw.20170704104725.6"><vh>size</vh></v>
<v t="karstenw.20170704104725.7"><vh>_get_width</vh></v>
<v t="karstenw.20170704104725.8"><vh>_get_height</vh></v>
<v t="karstenw.20170704104725.9"><vh>speed</vh></v>
<v t="karstenw.20170704104725.10"><vh>background</vh></v>
<v t="karstenw.20170704104725.11"><vh>outputmode</vh></v>
</v>
<v t="karstenw.20170709143221.1" a="E"><vh>## Variables ##</vh>
<v t="karstenw.20170704104725.12"><vh>var</vh></v>
<v t="karstenw.20170704104725.13"><vh>addvar</vh></v>
<v t="karstenw.20170704104725.14"><vh>findvar</vh></v>
</v>
<v t="karstenw.20170709143242.1" a="E"><vh>## Objects ##</vh>
<v t="karstenw.20170704104725.15"><vh>_makeInstance</vh></v>
<v t="karstenw.20170704104725.16"><vh>BezierPath</vh></v>
<v t="karstenw.20170704104725.17"><vh>ClippingPath</vh></v>
<v t="karstenw.20170704104725.18"><vh>Rect</vh></v>
<v t="karstenw.20170704104725.19"><vh>Oval</vh></v>
<v t="karstenw.20170704104725.20"><vh>Color</vh></v>
<v t="karstenw.20170704104725.21"><vh>Image</vh></v>
<v t="karstenw.20170704104725.22"><vh>Text</vh></v>
</v>
<v t="karstenw.20170709143301.1"><vh>## Primitives ##</vh>
<v t="karstenw.20170704104725.23"><vh>rect</vh></v>
<v t="karstenw.20170704104725.24"><vh>oval</vh></v>
<v t="karstenw.20170704104725.25"><vh>arc</vh></v>
<v t="karstenw.20170704104725.26"><vh>line</vh></v>
<v t="karstenw.20170704104725.27"><vh>star</vh></v>
<v t="karstenw.20170704104725.28"><vh>arrow</vh></v>
<v t="karstenw.20170704104725.29"><vh>_arrow</vh></v>
<v t="karstenw.20170704104725.30"><vh>_arrow45</vh></v>
</v>
<v t="karstenw.20170709143318.1"><vh>## Path Commands ##</vh>
<v t="karstenw.20170704104725.31"><vh>beginpath</vh></v>
<v t="karstenw.20170704104725.32"><vh>moveto</vh></v>
<v t="karstenw.20170704104725.33"><vh>lineto</vh></v>
<v t="karstenw.20170704104725.34"><vh>curveto</vh></v>
<v t="karstenw.20170704104725.35"><vh>closepath</vh></v>
<v t="karstenw.20170704104725.36"><vh>endpath</vh></v>
<v t="karstenw.20170704104725.37"><vh>drawpath</vh></v>
<v t="karstenw.20170704104725.38"><vh>autoclosepath</vh></v>
<v t="karstenw.20170704104725.39"><vh>findpath</vh></v>
</v>
<v t="karstenw.20170709143341.1"><vh>## Clipping Commands ##</vh>
<v t="karstenw.20170704104725.40"><vh>beginclip</vh></v>
<v t="karstenw.20170704104725.41"><vh>endclip</vh></v>
</v>
<v t="karstenw.20170709143354.1" a="E"><vh>## Transformation Commands ##</vh>
<v t="karstenw.20170704104725.42"><vh>push</vh></v>
<v t="karstenw.20170704104725.43"><vh>pop</vh></v>
<v t="karstenw.20170704104725.44"><vh>transform</vh></v>
<v t="karstenw.20170704104725.46"><vh>reset</vh></v>
<v t="karstenw.20170704104725.47"><vh>rotate</vh></v>
<v t="karstenw.20170704104725.48"><vh>translate</vh></v>
<v t="karstenw.20170704104726.1"><vh>scale</vh></v>
<v t="karstenw.20170704104726.2"><vh>skew</vh></v>
</v>
<v t="karstenw.20170709143414.1"><vh>## Color Commands ##</vh>
<v t="karstenw.20170704104726.3"><vh>colormode</vh></v>
<v t="karstenw.20170704104726.4"><vh>colorrange</vh></v>
<v t="karstenw.20170704104726.5"><vh>nofill</vh></v>
<v t="karstenw.20170704104726.6"><vh>fill</vh></v>
<v t="karstenw.20170704104726.7"><vh>nostroke</vh></v>
<v t="karstenw.20170704104726.8"><vh>stroke</vh></v>
<v t="karstenw.20170704104726.9"><vh>strokewidth</vh></v>
</v>
<v t="karstenw.20170709143705.1"><vh>## Path Style Commands ##</vh>
<v t="karstenw.20170704104726.10"><vh>capstyle</vh></v>
<v t="karstenw.20170704104726.11"><vh>joinstyle</vh></v>
</v>
<v t="karstenw.20170709143458.1" a="E"><vh>## Font Commands ##</vh>
<v t="karstenw.20170704104726.12"><vh>font</vh></v>
<v t="karstenw.20170704104726.13"><vh>fontsize</vh></v>
<v t="karstenw.20170704104726.14"><vh>lineheight</vh></v>
<v t="karstenw.20170704104726.15"><vh>align</vh></v>
<v t="karstenw.20170704104726.16"><vh>textwidth</vh></v>
<v t="karstenw.20170704104726.17"><vh>textheight</vh></v>
<v t="karstenw.20170704104726.18"><vh>text</vh></v>
<v t="karstenw.20170704104726.19"><vh>textpath</vh></v>
<v t="karstenw.20170704104726.20"><vh>textmetrics</vh></v>
<v t="karstenw.20170704104726.21"><vh>alltextmetrics</vh></v>
</v>
<v t="karstenw.20170709143553.1" a="E"><vh>## Image Commands ##</vh>
<v t="karstenw.20170704104726.22"><vh>image</vh></v>
<v t="karstenw.20170704104726.23"><vh>imagesize</vh></v>
</v>
<v t="karstenw.20170709143618.1"><vh>## Canvas Proxy ##</vh>
<v t="karstenw.20170704104726.24"><vh>save</vh></v>
</v>
<v t="karstenw.20170709143636.1"><vh>## C-Extensions Interface ##</vh>
<v t="karstenw.20170704104726.25"><vh>isqrt</vh></v>
<v t="karstenw.20170704104726.26"><vh>angle</vh></v>
<v t="karstenw.20170704104726.27"><vh>distance</vh></v>
<v t="karstenw.20170704104726.28"><vh>coordinates</vh></v>
<v t="karstenw.20170704104726.29"><vh>reflect</vh></v>
<v t="karstenw.20180202044929.1"><vh>dither</vh></v>
<v t="karstenw.20210623195428.1"><vh>fractalimage</vh></v>
</v>
</v>
</v>
<v t="karstenw.20170704104730.1"><vh>@clean nodebox/graphics/bezier.py</vh>
<v t="karstenw.20170704104742.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704104742.2"><vh>segment_lengths</vh></v>
<v t="karstenw.20170704104742.3"><vh>length</vh></v>
<v t="karstenw.20170704104742.4"><vh>_locate</vh></v>
<v t="karstenw.20170704104742.5"><vh>point</vh></v>
<v t="karstenw.20170704104742.6"><vh>points</vh></v>
<v t="karstenw.20170704104742.7"><vh>contours</vh></v>
<v t="karstenw.20170704104742.8"><vh>findpath</vh></v>
<v t="karstenw.20170704104742.9"><vh>insert_point</vh></v>
<v t="karstenw.20170704104742.10"><vh>_test</vh></v>
</v>
<v t="karstenw.20170704104743.1"><vh>@clean nodebox/graphics/cocoa.py</vh>
<v t="karstenw.20170704104751.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20170704104751.2"><vh>_save</vh></v>
<v t="karstenw.20170704104751.3"><vh>_restore</vh></v>
<v t="karstenw.20251222122634.1"><vh>+ FROM SQUEAKLIB +</vh>
<v t="karstenw.20251222122658.1"><vh>sign</vh></v>
<v t="karstenw.20251222122705.1"><vh>makePoint</vh></v>
</v>
<v t="karstenw.20170704104751.4"><vh>class NodeBoxError</vh></v>
<v t="karstenw.20170704104751.5"><vh>class Point</vh>
<v t="karstenw.20251222122048.1"><vh>__python__</vh>
<v t="karstenw.20170704104751.6"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.7"><vh>__repr__</vh></v>
<v t="karstenw.20170704104751.8"><vh>__eq__</vh></v>
<v t="karstenw.20170704104751.9"><vh>__ne__</vh></v>
<v t="karstenw.20210714232702.1"><vh>__lt__ __le__ __gt__ __ge__</vh></v>
<v t="karstenw.20210714232606.1"><vh>__hash__</vh></v>
</v>
</v>
<v t="karstenw.20170704104751.10"><vh>class Grob</vh>
<v t="karstenw.20170704104751.11"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.12"><vh>draw</vh></v>
<v t="karstenw.20170704104751.13"><vh>copy</vh></v>
<v t="karstenw.20170704104751.14"><vh>inheritFromContext</vh></v>
<v t="karstenw.20170704104751.15"><vh>checkKwargs</vh></v>
</v>
<v t="karstenw.20170704104751.16"><vh>class TransformMixin</vh>
<v t="karstenw.20170704104751.17"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.18"><vh>_reset</vh></v>
<v t="karstenw.20170704104751.19"><vh>transform</vh></v>
<v t="karstenw.20170704104751.21"><vh>transformmode</vh></v>
<v t="karstenw.20170704104751.24"><vh>reset</vh></v>
<v t="karstenw.20170704104751.25"><vh>rotate</vh></v>
<v t="karstenw.20170704104751.26"><vh>translate</vh></v>
<v t="karstenw.20170704104751.27"><vh>scale</vh></v>
<v t="karstenw.20170704104751.28"><vh>skew</vh></v>
</v>
<v t="karstenw.20170704104751.29"><vh>class ColorMixin</vh>
<v t="karstenw.20170704104751.30"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.31"><vh>fill</vh></v>
<v t="karstenw.20170704104751.33"><vh>stroke</vh></v>
<v t="karstenw.20170704104751.35"><vh>strokewidth</vh></v>
</v>
<v t="karstenw.20170704104751.37"><vh>class BezierPath</vh>
<v t="karstenw.20170704104751.38"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.39"><vh>_get_path</vh></v>
<v t="karstenw.20170704104751.40"><vh>copy</vh></v>
<v t="karstenw.20170704104751.41"><vh>capstyle</vh></v>
<v t="karstenw.20170704104751.43"><vh>joinstyle</vh></v>
<v t="karstenw.20230718091743.1"><vh>+ Path methods</vh>
<v t="karstenw.20170704104751.45"><vh>moveto</vh></v>
<v t="karstenw.20170704104751.46"><vh>lineto</vh></v>
<v t="karstenw.20170704104751.47"><vh>curveto</vh></v>
<v t="karstenw.20170704104751.48"><vh>closepath</vh></v>
<v t="karstenw.20170704104751.49"><vh>setlinewidth</vh></v>
<v t="karstenw.20170704104751.50"><vh>bounds</vh></v>
<v t="karstenw.20170704104751.51"><vh>contains</vh></v>
</v>
<v t="karstenw.20230718091902.1"><vh>### Basic shapes ###</vh>
<v t="karstenw.20170704104751.52"><vh>rect</vh></v>
<v t="karstenw.20170704104751.53"><vh>oval</vh></v>
<v t="karstenw.20170704104751.54"><vh>arc</vh></v>
<v t="karstenw.20170704104751.55"><vh>line</vh></v>
</v>
<v t="karstenw.20230718091919.1"><vh>### List methods ###</vh>
<v t="karstenw.20170704104751.56"><vh>__getitem__</vh></v>
<v t="karstenw.20170704104751.57"><vh>__iter__</vh></v>
<v t="karstenw.20170704104751.58"><vh>__len__</vh></v>
<v t="karstenw.20170704104751.59"><vh>extend</vh></v>
<v t="karstenw.20170704104751.60"><vh>append</vh></v>
</v>
<v t="karstenw.20170704104751.61"><vh>_get_contours</vh></v>
<v t="karstenw.20230718092007.1"><vh>### Drawing methods ###</vh>
<v t="karstenw.20170704104751.62"><vh>_get_transform</vh></v>
<v t="karstenw.20170704104751.63"><vh>_draw</vh></v>
</v>
<v t="karstenw.20230718092025.1"><vh>### Geometry ###</vh>
<v t="karstenw.20170704104751.64"><vh>fit</vh></v>
<v t="karstenw.20170704104751.65"><vh>segmentlengths</vh></v>
<v t="karstenw.20170704104751.66"><vh>_get_length</vh></v>
<v t="karstenw.20170704104751.67"><vh>point</vh></v>
<v t="karstenw.20170704104751.68"><vh>points</vh></v>
<v t="karstenw.20170704104751.69"><vh>addpoint</vh></v>
</v>
<v t="karstenw.20230718092146.1"><vh>### Clipping operations ###</vh>
<v t="karstenw.20170704104751.70"><vh>intersects</vh></v>
<v t="karstenw.20170704104751.71"><vh>union</vh></v>
<v t="karstenw.20170704104751.72"><vh>intersect</vh></v>
<v t="karstenw.20170704104751.73"><vh>difference</vh></v>
<v t="karstenw.20170704104751.74"><vh>xor</vh></v>
</v>
</v>
<v t="karstenw.20170704104751.75"><vh>class PathElement</vh>
<v t="karstenw.20170704104751.76"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.77"><vh>__repr__</vh></v>
<v t="karstenw.20170704104751.78"><vh>__eq__</vh></v>
<v t="karstenw.20210714234429.1"><vh>__lt__</vh></v>
<v t="karstenw.20210714234443.1"><vh>__le__</vh></v>
<v t="karstenw.20210714234451.1"><vh>__gt__</vh></v>
<v t="karstenw.20210714234458.1"><vh>__ge__</vh></v>
<v t="karstenw.20170704104751.79"><vh>__ne__</vh></v>
<v t="karstenw.20210714232328.1"><vh>__hash__</vh></v>
</v>
<v t="karstenw.20170704104751.80"><vh>class ClippingPath</vh>
<v t="karstenw.20170704104751.81"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.82"><vh>append</vh></v>
<v t="karstenw.20170704104751.83"><vh>_draw</vh></v>
</v>
<v t="karstenw.20170704104751.84"><vh>class Rect</vh>
<v t="karstenw.20170704104751.85"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.86"><vh>copy</vh></v>
</v>
<v t="karstenw.20170704104751.87"><vh>class Oval</vh>
<v t="karstenw.20170704104751.88"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.89"><vh>copy</vh></v>
</v>
<v t="karstenw.20170704104751.90"><vh>class Color</vh>
<v t="karstenw.20170704104751.91"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.92"><vh>__repr__</vh></v>
<v t="karstenw.20210715171431.1"><vh>__hash__</vh></v>
<v t="karstenw.20170704104751.93"><vh>set</vh></v>
<v t="karstenw.20170704104751.94"><vh>_get_nsColor</vh></v>
<v t="karstenw.20170704104751.95"><vh>copy</vh></v>
<v t="karstenw.20170704104751.96"><vh>_updateCmyk</vh></v>
<v t="karstenw.20170704104751.97"><vh>_updateRgb</vh></v>
<v t="karstenw.20170704104751.98"><vh>_get_hue</vh></v>
<v t="karstenw.20170704104751.99"><vh>_set_hue</vh></v>
<v t="karstenw.20170704104751.100"><vh>_get_saturation</vh></v>
<v t="karstenw.20170704104751.101"><vh>_set_saturation</vh></v>
<v t="karstenw.20170704104751.102"><vh>_get_brightness</vh></v>
<v t="karstenw.20170704104751.103"><vh>_set_brightness</vh></v>
<v t="karstenw.20170704104751.104"><vh>_get_hsba</vh></v>
<v t="karstenw.20170704104751.105"><vh>_set_hsba</vh></v>
<v t="karstenw.20170704104751.106"><vh>_get_red</vh></v>
<v t="karstenw.20170704104751.107"><vh>_set_red</vh></v>
<v t="karstenw.20170704104751.108"><vh>_get_green</vh></v>
<v t="karstenw.20170704104751.109"><vh>_set_green</vh></v>
<v t="karstenw.20170704104751.110"><vh>_get_blue</vh></v>
<v t="karstenw.20170704104751.111"><vh>_set_blue</vh></v>
<v t="karstenw.20170704104751.112"><vh>_get_alpha</vh></v>
<v t="karstenw.20170704104751.113"><vh>_set_alpha</vh></v>
<v t="karstenw.20170704104751.114"><vh>_get_rgba</vh></v>
<v t="karstenw.20170704104751.115"><vh>_set_rgba</vh></v>
<v t="karstenw.20170704104751.116"><vh>_get_cyan</vh></v>
<v t="karstenw.20170704104751.117"><vh>_set_cyan</vh></v>
<v t="karstenw.20170704104751.118"><vh>_get_magenta</vh></v>
<v t="karstenw.20170704104751.119"><vh>_set_magenta</vh></v>
<v t="karstenw.20170704104751.120"><vh>_get_yellow</vh></v>
<v t="karstenw.20170704104751.121"><vh>_set_yellow</vh></v>
<v t="karstenw.20170704104751.122"><vh>_get_black</vh></v>
<v t="karstenw.20170704104751.123"><vh>_set_black</vh></v>
<v t="karstenw.20170704104751.124"><vh>_get_cmyka</vh></v>
<v t="karstenw.20170704104751.125"><vh>blend</vh></v>
<v t="karstenw.20170704104751.126"><vh>_normalize</vh></v>
<v t="karstenw.20170704104751.127"><vh>_normalizeList</vh></v>
</v>
<v t="karstenw.20170704104751.128"><vh>class Transform</vh>
<v t="karstenw.20170704104751.129"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.130"><vh>_get_transform</vh></v>
<v t="karstenw.20170704104751.131"><vh>set</vh></v>
<v t="karstenw.20170704104751.132"><vh>concat</vh></v>
<v t="karstenw.20170704104751.133"><vh>copy</vh></v>
<v t="karstenw.20170704104751.134"><vh>__repr__</vh></v>
<v t="karstenw.20170704104751.135"><vh>__iter__</vh></v>
<v t="karstenw.20170704104751.136"><vh>_get_matrix</vh></v>
<v t="karstenw.20170704104751.137"><vh>_set_matrix</vh></v>
<v t="karstenw.20170704104751.138"><vh>rotate</vh></v>
<v t="karstenw.20170704104751.139"><vh>translate</vh></v>
<v t="karstenw.20170704104751.140"><vh>scale</vh></v>
<v t="karstenw.20170704104751.141"><vh>skew</vh></v>
<v t="karstenw.20170704104751.142"><vh>invert</vh></v>
<v t="karstenw.20170704104751.143"><vh>append</vh></v>
<v t="karstenw.20170704104751.144"><vh>prepend</vh></v>
<v t="karstenw.20170704104751.145"><vh>transformPoint</vh></v>
<v t="karstenw.20170704104751.146"><vh>transformBezierPath</vh></v>
</v>
<v t="karstenw.20170704104751.147"><vh>class Image</vh>
<v t="karstenw.20170704104751.148"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.149"><vh>_get_image</vh></v>
<v t="karstenw.20170704104751.150"><vh>copy</vh></v>
<v t="karstenw.20170704104751.151"><vh>getSize</vh></v>
<v t="karstenw.20170704104751.152"><vh>_draw</vh></v>
</v>
<v t="karstenw.20170704104751.153"><vh>class Text</vh>
<v t="karstenw.20170704104751.154"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.155"><vh>copy</vh></v>
<v t="karstenw.20170704104751.156"><vh>font_exists</vh></v>
<v t="karstenw.20170704104751.157"><vh>_get_font</vh></v>
<v t="karstenw.20170704104751.158"><vh>_getLayoutManagerTextContainerTextStorage</vh></v>
<v t="karstenw.20170704104751.159"><vh>_draw</vh></v>
<v t="karstenw.20170704104751.160"><vh>_get_allmetrics</vh></v>
<v t="karstenw.20170704104751.161"><vh>_get_metrics</vh></v>
<v t="karstenw.20170704104751.162"><vh>_get_path</vh></v>
</v>
<v t="karstenw.20170704104751.163"><vh>class Variable</vh>
<v t="karstenw.20170704104751.164"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.165"><vh>sanitize</vh></v>
<v t="karstenw.20170704104751.166"><vh>compliesTo</vh></v>
<v t="karstenw.20170704104751.167"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20170704104751.168"><vh>class _PDFRenderView</vh>
<v t="karstenw.20170704104751.169"><vh>initWithCanvas_</vh></v>
<v t="karstenw.20170704104751.170"><vh>drawRect_</vh></v>
<v t="karstenw.20170704104751.171"><vh>isOpaque</vh></v>
<v t="karstenw.20170704104751.172"><vh>isFlipped</vh></v>
</v>
<v t="karstenw.20170704104751.173"><vh>class Canvas</vh>
<v t="karstenw.20170704104751.174"><vh>__init__</vh></v>
<v t="karstenw.20170704104751.175"><vh>clear</vh></v>
<v t="karstenw.20170704104751.176"><vh>_get_size</vh></v>
<v t="karstenw.20170704104751.177"><vh>append</vh></v>
<v t="karstenw.20170704104751.178"><vh>__iter__</vh></v>
<v t="karstenw.20170704104751.179"><vh>__len__</vh></v>
<v t="karstenw.20170704104751.180"><vh>__getitem__</vh></v>
<v t="karstenw.20170704104751.181"><vh>push</vh></v>
<v t="karstenw.20170704104751.182"><vh>pop</vh></v>
<v t="karstenw.20170704104751.183"><vh>draw</vh></v>
<v t="karstenw.20170704104751.184"><vh>_get_nsImage</vh></v>
<v t="karstenw.20170704104751.185"><vh>_getImageData</vh></v>
<v t="karstenw.20170704104751.186"><vh>save</vh></v>
</v>
<v t="karstenw.20170704104751.187"><vh>_test</vh></v>
</v>
</v>
<v t="karstenw.20170704104501.1"><vh>gui</vh>
<v t="karstenw.20170704104824.1"><vh>@clean nodebox/gui/__init__.py</vh></v>
<v t="karstenw.20170704105258.1"><vh>mac</vh>
<v t="karstenw.20170704104856.1"><vh>@clean nodebox/gui/mac/__init__.py</vh>
<v t="karstenw.20170704105032.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20170704105032.2"><vh>class ExportCommand</vh></v>
<v t="karstenw.20170704105032.3"><vh>class OutputFile</vh>
<v t="karstenw.20170704105032.4"><vh>__init__</vh></v>
<v t="karstenw.20170704105032.5"><vh>write</vh></v>
</v>
<v t="karstenw.20210623180227.1"><vh>NodeBoxApplication</vh>
<v t="karstenw.20210623180253.1"><vh>awakeFromNib</vh></v>
<v t="karstenw.20210623180302.1"><vh>finishLaunching</vh></v>
</v>
<v t="karstenw.20170704105032.6" a="E"><vh>class NodeBoxDocument</vh>
<v t="karstenw.20170704105032.7"><vh>windowNibName</vh></v>
<v t="karstenw.20170704105032.8"><vh>init</vh></v>
<v t="karstenw.20170704105032.9"><vh>autosavesInPlace</vh></v>
<v t="karstenw.20170704105032.10"><vh>close</vh></v>
<v t="karstenw.20170704105032.11"><vh>__del__</vh></v>
<v t="karstenw.20170704105032.12"><vh>textFontChanged_</vh></v>
<v t="karstenw.20170704105032.13"><vh>readFromFile_ofType_</vh></v>
<v t="karstenw.20170704105032.14"><vh>writeToFile_ofType_</vh></v>
<v t="karstenw.20170704105032.15"><vh>windowControllerDidLoadNib_</vh></v>
<v t="karstenw.20170704105032.16"><vh>readFromUTF8_</vh></v>
<v t="karstenw.20170704105032.17"><vh>cleanRun_newSeed_buildInterface_</vh></v>
<v t="karstenw.20170704105032.18"><vh>prepareRun</vh></v>
<v t="karstenw.20170704105032.19"><vh>fastRun_newSeed_</vh></v>
<v t="karstenw.20170709154311.1"><vh>fastRun_newSeed_args_</vh></v>
<v t="karstenw.20210624121624.1"><vh>clearMessageArea_</vh></v>
<v t="karstenw.20170704105032.20"><vh>runFullscreen_</vh></v>
<v t="karstenw.20170704105032.21"><vh>runScript_</vh></v>
<v t="karstenw.20170704105032.22"><vh>runScript</vh></v>
<v t="karstenw.20170704105032.23"><vh>_runScript</vh></v>
<v t="karstenw.20170704105032.24"><vh>runScriptFast</vh></v>
<v t="karstenw.20170704105032.25"><vh>doFrame</vh></v>
<v t="karstenw.20170704105032.26"><vh>source</vh></v>
<v t="karstenw.20170704105032.27"><vh>setSource_</vh></v>
<v t="karstenw.20170704105032.28"><vh>stopScript_</vh></v>
<v t="karstenw.20170704105032.29"><vh>stopScript</vh></v>
<v t="karstenw.20170704105032.30"><vh>_compileScript</vh></v>
<v t="karstenw.20170704105032.31"><vh>_initNamespace</vh></v>
<v t="karstenw.20170704105032.32"><vh>_execScript</vh></v>
<v t="karstenw.20170704105032.33"><vh>boxedRun_args_</vh></v>
<v t="karstenw.20170704105032.34"><vh>_userCancelledMonitor</vh></v>
<v t="karstenw.20170704105032.35"><vh>flushOutput_</vh></v>
<v t="karstenw.20170704105032.36"><vh>copyImageAsPDF_</vh></v>
<v t="karstenw.20170704105032.37"><vh>exportAsImage_</vh></v>
<v t="karstenw.20170704105032.38"><vh>exportPanelDidEnd_returnCode_contextInfo_</vh></v>
<v t="karstenw.20170704105032.39"><vh>exportImageFormatChanged_</vh></v>
<v t="karstenw.20170704105032.40"><vh>doExportAsImage_fmt_pages_</vh></v>
<v t="karstenw.20170704105032.41"><vh>exportAsMovie_</vh></v>
<v t="karstenw.20170704105032.42"><vh>qtPanelDidEnd_returnCode_contextInfo_</vh></v>
<v t="karstenw.20170704105032.43"><vh>doExportAsMovie_frames_fps_</vh></v>
<v t="karstenw.20170704105032.44"><vh>printDocument_</vh></v>
<v t="karstenw.20170704105032.45"><vh>printOperationDidRun_success_contextInfo_</vh></v>
<v t="karstenw.20170704105032.46"><vh>buildInterface_</vh></v>
<v t="karstenw.20170704105032.47"><vh>validateMenuItem_</vh></v>
<v t="karstenw.20170727100220.1"><vh>ZOOM COMMANDS</vh>
<v t="karstenw.20170704105032.48"><vh>zoomIn_</vh></v>
<v t="karstenw.20170704105032.49"><vh>zoomOut_</vh></v>
<v t="karstenw.20170704105032.50"><vh>zoomToTag_</vh></v>
<v t="karstenw.20170704105032.51"><vh>zoomToFit_</vh></v>
</v>
</v>
<v t="karstenw.20170704105032.52"><vh>class FullscreenWindow</vh>
<v t="karstenw.20170704105032.53"><vh>initWithRect_</vh></v>
<v t="karstenw.20170704105032.54"><vh>canBecomeKeyWindow</vh></v>
</v>
<v t="karstenw.20170704105032.55"><vh>class FullscreenView</vh>
<v t="karstenw.20170704105032.56"><vh>init</vh></v>
<v t="karstenw.20170704105032.57"><vh>setCanvas_</vh></v>
<v t="karstenw.20170704105032.58"><vh>drawRect_</vh></v>
<v t="karstenw.20170704105032.59"><vh>isFlipped</vh></v>
<v t="karstenw.20170704105032.60"><vh>mouseDown_</vh></v>
<v t="karstenw.20170704105032.61"><vh>mouseUp_</vh></v>
<v t="karstenw.20170704105032.62"><vh>keyDown_</vh></v>
<v t="karstenw.20170704105032.63"><vh>keyUp_</vh></v>
<v t="karstenw.20170704105032.64"><vh>scrollWheel_</vh></v>
<v t="karstenw.20170704105032.65"><vh>canBecomeKeyView</vh></v>
<v t="karstenw.20170704105032.66"><vh>acceptsFirstResponder</vh></v>
</v>
<v t="karstenw.20170704105032.67"><vh>calc_scaling_factor</vh></v>
<v t="karstenw.20170704105032.68"><vh>class ZoomPanel</vh></v>
<v t="karstenw.20170704105032.69"><vh>class NodeBoxGraphicsView</vh>
<v t="karstenw.20170704105032.70"><vh>awakeFromNib</vh></v>
<v t="karstenw.20170704105032.71"><vh>setCanvas_</vh></v>
<v t="karstenw.20170704105032.72"><vh>getZoom</vh></v>
<v t="karstenw.20170704105032.73"><vh>setZoom_</vh></v>
<v t="karstenw.20170704105032.74"><vh>dragZoom_</vh></v>
<v t="karstenw.20170704105032.75"><vh>findNearestZoomIndex_</vh></v>
<v t="karstenw.20170704105032.76"><vh>zoomIn_</vh></v>
<v t="karstenw.20170704105032.77"><vh>zoomOut_</vh></v>
<v t="karstenw.20170704105032.78"><vh>resetZoom_</vh></v>
<v t="karstenw.20170704105032.79"><vh>zoomTo_</vh></v>
<v t="karstenw.20170704105032.80"><vh>zoomToFit_</vh></v>
<v t="karstenw.20170704105032.81"><vh>markDirty</vh></v>
<v t="karstenw.20170704105032.82"><vh>setFrameSize_</vh></v>
<v t="karstenw.20170704105032.83"><vh>isOpaque</vh></v>
<v t="karstenw.20170704105032.84"><vh>isFlipped</vh></v>
<v t="karstenw.20170704105032.85"><vh>drawRect_</vh></v>
<v t="karstenw.20170704105032.86"><vh>_updateImage</vh></v>
<v t="karstenw.20170704105032.87"><vh>pasteboard_provideDataForType_</vh></v>
<v t="karstenw.20170704105032.88"><vh>_get_pdfData</vh></v>
<v t="karstenw.20170704105032.89"><vh>_get_epsData</vh></v>
<v t="karstenw.20170704105032.90"><vh>_get_tiffData</vh></v>
<v t="karstenw.20170704105032.91"><vh>_get_pngData</vh></v>
<v t="karstenw.20170704105032.92"><vh>_get_gifData</vh></v>
<v t="karstenw.20170704105032.93"><vh>_get_jpegData</vh></v>
<v t="karstenw.20170704105032.94"><vh>mouseDown_</vh></v>
<v t="karstenw.20170704105032.95"><vh>mouseUp_</vh></v>
<v t="karstenw.20170704105032.96"><vh>keyDown_</vh></v>
<v t="karstenw.20170704105032.97"><vh>keyUp_</vh></v>
<v t="karstenw.20170704105032.98"><vh>scrollWheel_</vh></v>
<v t="karstenw.20170704105032.99"><vh>canBecomeKeyView</vh></v>
<v t="karstenw.20170704105032.100"><vh>acceptsFirstResponder</vh></v>
</v>
<v t="karstenw.20170704105032.101"><vh>class NodeBoxAppDelegate</vh>
<v t="karstenw.20170704105032.102"><vh>awakeFromNib</vh></v>
<v t="karstenw.20230216113142.1"><vh>applicationShouldOpenUntitledFile_</vh></v>
<v t="karstenw.20230216115950.1"><vh>applicationShouldHandleReopen_hasVisibleWindows_</vh></v>
<v t="karstenw.20170704105032.103"><vh>showPreferencesPanel_</vh></v>
<v t="karstenw.20170704105032.104"><vh>generateCode_</vh></v>
<v t="karstenw.20170704105032.105"><vh>showHelp_</vh></v>
<v t="karstenw.20170704105032.106"><vh>showSite_</vh></v>
<v t="karstenw.20170704105032.107"><vh>showLibrary_</vh></v>
<v t="karstenw.20170704105032.108"><vh>applicationWillTerminate_</vh></v>
</v>
</v>
<v t="karstenw.20170704104908.1"><vh>@clean nodebox/gui/mac/AskStringWindowController.py</vh>
<v t="karstenw.20170704105043.1"><vh>Declarations</vh></v>
<v t="karstenw.20211204132045.1"><vh>AskString_cb_default_parent_</vh></v>
<v t="karstenw.20170704105043.2" a="E"><vh>class AskStringWindowController</vh>
<v t="karstenw.20211125131320.1"><vh>init</vh></v>
<v t="karstenw.20170704105043.3"><vh>xx__new__</vh></v>
<v t="karstenw.20211125131451.1"><vh>setup_cb_default_parent_</vh></v>
<v t="karstenw.20170704105043.4"><vh>windowWillClose_</vh></v>
<v t="karstenw.20170704105043.5"><vh>awakeFromNib</vh></v>
<v t="karstenw.20170704105043.6"><vh>done</vh></v>
<v t="karstenw.20170704105043.7"><vh>ok_</vh></v>
<v t="karstenw.20170704105043.8"><vh>cancel_</vh></v>
<v t="karstenw.20211127131740.1"><vh>DEBUG</vh></v>
</v>
</v>
<v t="karstenw.20170704104918.1"><vh>@clean nodebox/gui/mac/dashboard.py</vh>
<v t="karstenw.20170704105051.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20210628212143.1"><vh>getFunctionArgCount</vh></v>
<v t="karstenw.20170704105051.2" a="E"><vh>class DashboardController</vh>
<v t="karstenw.20170704105051.3"><vh>clearInterface</vh></v>
<v t="karstenw.20170704105051.4"><vh>numberChanged_</vh></v>
<v t="karstenw.20170704105051.5"><vh>textChanged_</vh></v>
<v t="karstenw.20170704105051.6"><vh>booleanChanged_</vh></v>
<v t="karstenw.20170704105051.7"><vh>buttonClicked_</vh></v>
<v t="karstenw.20170709145427.1"><vh>menuSelected_</vh></v>
<v t="karstenw.20170704105051.8"><vh>buildInterface_</vh></v>
<v t="karstenw.20170704105051.9"><vh>addLabel_idx_frame_</vh></v>
<v t="karstenw.20170704105051.10"><vh>addSlider_idx_frame_</vh></v>
<v t="karstenw.20170704105051.11"><vh>addTextField_idx_frame_</vh></v>
<v t="karstenw.20170704105051.12"><vh>addSwitch_idx_frame_</vh></v>
<v t="karstenw.20170704105051.13"><vh>addButton_y_ctrl_width_</vh></v>
<v t="karstenw.20170709145531.1"><vh>addMenu_idx_frame_</vh></v>
</v>
</v>
<v t="karstenw.20170704104926.1"><vh>@clean nodebox/gui/mac/preferences.py</vh>
<v t="karstenw.20170704105106.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105106.2" a="E"><vh>class LibraryFolder</vh>
<v t="karstenw.20170704105106.3"><vh>__init__</vh></v>
</v>
<v t="karstenw.20170704105106.4" a="E"><vh>class NodeBoxPreferencesController</vh>
<v t="karstenw.20170704105106.5"><vh>init</vh></v>
<v t="karstenw.20170704105106.6"><vh>awakeFromNib</vh></v>
<v t="karstenw.20170704105106.7"><vh>windowWillClose_</vh></v>
<v t="karstenw.20170704105106.8"><vh>updateColors_</vh></v>
<v t="karstenw.20170704105106.9"><vh>timeToUpdateTheColors_</vh></v>
<v t="karstenw.20170704105106.10"><vh>chooseFont_</vh></v>
<v t="karstenw.20170704105106.11"><vh>chooseLibrary_</vh></v>
<v t="karstenw.20170704105106.12"><vh>changeFont_</vh></v>
<v t="karstenw.20170704105106.13"><vh>textFontChanged_</vh></v>
</v>
</v>
<v t="karstenw.20170704104934.1"><vh>@clean nodebox/gui/mac/PyDETextView.py</vh>
<v t="karstenw.20170704105113.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105113.2"><vh>findWhitespace</vh></v>
<v t="karstenw.20170704105113.3"><vh>removeStringsAndComments</vh></v>
<v t="karstenw.20170704105113.4" a="E"><vh>class PyDETextView</vh>
<v t="karstenw.20170704105113.5"><vh>awakeFromNib</vh></v>
<v t="karstenw.20170704105113.6"><vh>drawRect_</vh></v>
<v t="karstenw.20170704105113.7"><vh>hideValueLadder</vh></v>
<v t="karstenw.20170704105113.8"><vh>mouseUp_</vh></v>
<v t="karstenw.20170704105113.9"><vh>mouseDragged_</vh></v>
<v t="karstenw.20170704105113.10"><vh>mouseDown_</vh></v>
<v t="karstenw.20170704105113.11"><vh>acceptableDragTypes</vh></v>
<v t="karstenw.20170704105113.12"><vh>draggingEntered_</vh></v>
<v t="karstenw.20170704105113.13"><vh>_cleanup</vh></v>
<v t="karstenw.20170704105113.14"><vh>__del__</vh></v>
<v t="karstenw.20170704105113.15"><vh>jumpToLine_</vh></v>
<v t="karstenw.20170704105113.16"><vh>jumpToLineCallback_</vh></v>
<v t="karstenw.20170704105113.17"><vh>jumpToLineNr_</vh></v>
<v t="karstenw.20170704105113.18"><vh>textFontChanged_</vh></v>
<v t="karstenw.20170704105113.19"><vh>setTextStorage_str_tabs_</vh></v>
<v t="karstenw.20170704105113.20"><vh>changeFont_</vh></v>
<v t="karstenw.20170704105113.21"><vh>getLinesForRange_</vh></v>
<v t="karstenw.20170704105113.22"><vh>getIndent</vh></v>
<v t="karstenw.20170704105113.23"><vh>drawInsertionPointInRect_color_turnedOn_</vh></v>
<v t="karstenw.20170704105113.24"><vh>keyDown_</vh></v>
<v t="karstenw.20170704105113.25"><vh>balanceParens_</vh></v>
<v t="karstenw.20170704105113.26"><vh>resetBalanceParens_</vh></v>
<v t="karstenw.20170704105113.27"><vh>iterLinesBackwards_maxChars_</vh></v>
<v t="karstenw.20170704105113.28"><vh>findMatchingIndex_paren_</vh></v>
<v t="karstenw.20170704105113.29"><vh>insertNewline_</vh></v>
<v t="karstenw.20170704105113.30"><vh>insertTab_</vh></v>
<v t="karstenw.20170704105113.31"><vh>deleteBackward_</vh></v>
<v t="karstenw.20170704105113.32"><vh>deleteForward_</vh></v>
<v t="karstenw.20170704105113.33"><vh>delete_fwd_superf_</vh></v>
<v t="karstenw.20170704105113.34"><vh>indent_</vh></v>
<v t="karstenw.20170704105113.35"><vh>dedent_</vh></v>
<v t="karstenw.20170704105113.36"><vh>comment_</vh></v>
<v t="karstenw.20170704105113.37"><vh>uncomment_</vh></v>
<v t="karstenw.20170704105113.38"><vh>filterLines_</vh></v>
</v>
<v t="karstenw.20170704105113.39"><vh>class PyDETextStorageDelegate</vh>
<v t="karstenw.20170704105113.40"><vh>__new__</vh></v>
<v t="karstenw.20170704105113.41"><vh>__init__</vh></v>
<v t="karstenw.20170704105113.42"><vh>textFontChanged_</vh></v>
<v t="karstenw.20170704105113.43"><vh>textStorage</vh></v>
<v t="karstenw.20170704105113.44"><vh>string</vh></v>
<v t="karstenw.20170704105113.45"><vh>lineIndexFromCharIndex_</vh></v>
<v t="karstenw.20170704105113.46"><vh>charIndexFromLineIndex_</vh></v>
<v t="karstenw.20170704105113.47"><vh>numberOfLines</vh></v>
<v t="karstenw.20170704105113.48"><vh>getSource</vh></v>
<v t="karstenw.20170704105113.49"><vh>textStorageWillProcessEditing_</vh></v>
<v t="karstenw.20170704105113.50"><vh>textStorageDidProcessEditing_</vh></v>
<v t="karstenw.20170704105113.51"><vh>scheduleColorize</vh></v>
<v t="karstenw.20170704105113.52"><vh>colorize</vh></v>
<v t="karstenw.20170704105113.53"><vh>_colorize</vh></v>
</v>
<v t="karstenw.20170704105113.54"><vh>class LineTracker</vh>
<v t="karstenw.20170704105113.55"><vh>__init__</vh></v>
<v t="karstenw.20170704105113.56"><vh>_makeLines</vh></v>
<v t="karstenw.20170704105113.57"><vh>_update</vh></v>
<v t="karstenw.20170704105113.58"><vh>lineIndexFromCharIndex_</vh></v>
<v t="karstenw.20170704105113.59"><vh>charIndexFromLineIndex_</vh></v>
<v t="karstenw.20170704105113.60"><vh>numberOfLines</vh></v>
</v>
<v t="karstenw.20230216131548.1" a="E"><vh>+ ATTRIBUTES +</vh>
<v t="karstenw.20170704105113.61"><vh>unpackAttrs</vh></v>
<v t="karstenw.20170704105113.62"><vh>packAttrs</vh></v>
<v t="karstenw.20170704105113.63"><vh>getBasicTextAttributes</vh></v>
<v t="karstenw.20170704105113.64"><vh>getSyntaxTextAttributes</vh></v>
<v t="karstenw.20170704105113.65"><vh>setBasicTextAttributes</vh></v>
<v t="karstenw.20170704105113.66"><vh>setSyntaxTextAttributes</vh></v>
<v t="karstenw.20170704105113.67"><vh>setTextFont</vh></v>
</v>
</v>
<v t="karstenw.20170704104947.1"><vh>@clean nodebox/gui/mac/util.py</vh>
<v t="karstenw.20170704105119.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105119.2"><vh>errorAlert</vh></v>
</v>
<v t="karstenw.20170704104953.1"><vh>@clean nodebox/gui/mac/ValueLadder.py</vh>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20170704105126.1"><vh>Declarations</vh></v>
<v t="karstenw.20211017190738.1"><vh>+ Globals +</vh></v>
<v t="karstenw.20170704105126.2" a="E"><vh>class ValueLadder</vh>
<v t="karstenw.20170704105126.3"><vh>__init__</vh></v>
<v t="karstenw.20170704105126.4"><vh>_parseAndCompile</vh></v>
<v t="karstenw.20170704105126.5"><vh>_checkSigns</vh></v>
<v t="karstenw.20170704105126.6"><vh>show</vh></v>
<v t="karstenw.20170704105126.7"><vh>hide</vh></v>
<v t="karstenw.20170704105126.8"><vh>draw</vh></v>
<v t="karstenw.20170704105126.9"><vh>mouseDragged_</vh></v>
</v>
</v>
</v>
</v>
<v t="karstenw.20170704104503.1"><vh>tests</vh>
<v t="karstenw.20170704105701.1"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20170704104508.1"><vh>util</vh>
<v t="karstenw.20170704105327.1"><vh>@clean nodebox/util/__init__.py</vh>
<v t="karstenw.20170704105353.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20210630133918.1"><vh>py2/3 list sort</vh></v>
<v t="karstenw.20170804122614.1"><vh>Globals</vh></v>
<v t="karstenw.20180202045145.1"><vh>UTILITIES</vh>
<v t="karstenw.20170704105353.2"><vh>makeunicode</vh></v>
<v t="karstenw.20170704105353.3"><vh>datestring</vh></v>
<v t="karstenw.20170704105353.4"><vh>grid</vh></v>
<v t="karstenw.20170704105353.5"><vh>random</vh></v>
</v>
<v t="karstenw.20170704105353.14"><vh>autotext</vh></v>
<v t="karstenw.20170811141051.1"><vh>FILE FUNCTIONS</vh>
<v t="karstenw.20170704105353.6"><vh>files</vh></v>
<v t="karstenw.20170704105353.7"><vh>filelist</vh></v>
<v t="karstenw.20170704105353.8"><vh>imagefiles</vh></v>
</v>
<v t="karstenw.20170811141102.1"><vh>FONT FUNCTIONS</vh>
<v t="karstenw.20170704105353.9"><vh>fontnames</vh></v>
<v t="karstenw.20170704105353.10"><vh>class FontRecord</vh>
<v t="karstenw.20170704105353.11"><vh>__init__</vh></v>
<v t="karstenw.20170704105353.12"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20170704105353.13"><vh>fontfamilies</vh></v>
</v>
<v t="karstenw.20170811141113.1"><vh>SPEECH FUNCTIONS</vh>
<v t="karstenw.20170801052347.1"><vh>voices</vh></v>
<v t="karstenw.20170804122600.1"><vh>voiceattributes</vh></v>
<v t="karstenw.20170804123557.1"><vh>anySpeakers</vh></v>
<v t="karstenw.20170801052423.1"><vh>say</vh></v>
</v>
<v t="karstenw.20171218183025.1" a="E"><vh>IMAGE FUNCTIONS</vh>
<v t="karstenw.20180202050130.1"><vh>aspectRatio</vh></v>
<v t="karstenw.20171218183032.1"><vh>palette</vh></v>
<v t="karstenw.20171218183048.1"><vh>asvoid</vh></v>
<v t="karstenw.20180202044822.1"><vh>imagepalette</vh></v>
<v t="karstenw.20180207131456.1"><vh>tempimagepath</vh></v>
<v t="karstenw.20180207131514.1"><vh>dithertypes</vh></v>
<v t="karstenw.20180202061109.1"><vh>ditherimage</vh></v>
</v>
<v t="karstenw.20170704105353.15"><vh>_copy_attr</vh></v>
<v t="karstenw.20170704105353.16"><vh>_copy_attrs</vh></v>
</v>
<v t="karstenw.20170704105406.1"><vh>kgp</vh>
<v t="karstenw.20170704105442.1" a="E"><vh>@clean nodebox/util/kgp/__init__.py</vh>
<v t="karstenw.20170704105455.1"><vh>Declarations</vh></v>
<v t="karstenw.20210322113242.1"></v>
<v t="karstenw.20210703124707.1"><vh>makeunicode double</vh></v>
<v t="karstenw.20170704105455.2"><vh>openAnything</vh></v>
<v t="karstenw.20170704105455.3"><vh>class NoSourceError</vh></v>
<v t="karstenw.20170704105455.4" a="E"><vh>class KantGenerator</vh>
<v t="karstenw.20170704105455.5"><vh>__init__</vh></v>
<v t="karstenw.20170704105455.6"><vh>_load</vh></v>
<v t="karstenw.20170704105455.7"><vh>loadGrammar</vh></v>
<v t="karstenw.20170704105455.8"><vh>loadSource</vh></v>
<v t="karstenw.20170704105455.9"><vh>getDefaultSource</vh></v>
<v t="karstenw.20170704105455.10"><vh>reset</vh></v>
<v t="karstenw.20170704105455.11"><vh>refresh</vh></v>
<v t="karstenw.20170704105455.12"><vh>output</vh></v>
<v t="karstenw.20170704105455.13"><vh>randomChildElement</vh></v>
<v t="karstenw.20170704105455.14"><vh>parse</vh></v>
<v t="karstenw.20170704105455.15"><vh>parse_Document</vh></v>
<v t="karstenw.20170704105455.16"><vh>parse_Text</vh></v>
<v t="karstenw.20170704105455.17"><vh>parse_Element</vh></v>
<v t="karstenw.20170704105455.18"><vh>parse_Comment</vh></v>
<v t="karstenw.20170704105455.19"><vh>do_xref</vh></v>
<v t="karstenw.20170704105455.20"><vh>do_p</vh></v>
<v t="karstenw.20170704105455.21"><vh>do_choice</vh></v>
</v>
<v t="karstenw.20170704105455.22"><vh>usage</vh></v>
<v t="karstenw.20170704105455.23"><vh>main</vh></v>
</v>
</v>
<v t="karstenw.20170704105534.1"><vh>ottobot</vh>
<v t="karstenw.20170704105412.1"><vh>@clean nodebox/util/ottobot/__init__.py</vh>
<v t="karstenw.20170704105528.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105528.2"><vh>class Context</vh>
<v t="karstenw.20170704105528.3"><vh>__init__</vh></v>
<v t="karstenw.20170704105528.4"><vh>indent</vh></v>
<v t="karstenw.20170704105528.5"><vh>dedent</vh></v>
<v t="karstenw.20170704105528.6"><vh>spaces</vh></v>
<v t="karstenw.20170704105528.7"><vh>inGrid</vh></v>
</v>
<v t="karstenw.20170704105528.8"><vh>nrReally</vh></v>
<v t="karstenw.20170704105528.9"><vh>nr</vh></v>
<v t="karstenw.20170704105528.10"><vh>genDraw</vh></v>
<v t="karstenw.20170704105528.11"><vh>genRect</vh></v>
<v t="karstenw.20170704105528.12"><vh>genOval</vh></v>
<v t="karstenw.20170704105528.13"><vh>genArrow</vh></v>
<v t="karstenw.20170704105528.14"><vh>genStar</vh></v>
<v t="karstenw.20170704105528.15"><vh>genPath</vh></v>
<v t="karstenw.20170704105528.16"><vh>genPathDraw</vh></v>
<v t="karstenw.20170704105528.17"><vh>genLineto</vh></v>
<v t="karstenw.20170704105528.18"><vh>genCurveto</vh></v>
<v t="karstenw.20170704105528.19"><vh>genTransform</vh></v>
<v t="karstenw.20170704105528.20"><vh>genRotate</vh></v>
<v t="karstenw.20170704105528.21"><vh>genTranslate</vh></v>
<v t="karstenw.20170704105528.22"><vh>genScale</vh></v>
<v t="karstenw.20170704105528.23"><vh>genSkew</vh></v>
<v t="karstenw.20170704105528.24"><vh>genReset</vh></v>
<v t="karstenw.20170704105528.25"><vh>genColor</vh></v>
<v t="karstenw.20170704105528.26"><vh>genFill</vh></v>
<v t="karstenw.20170704105528.27"><vh>genStroke</vh></v>
<v t="karstenw.20170704105528.28"><vh>genNofill</vh></v>
<v t="karstenw.20170704105528.29"><vh>genNostroke</vh></v>
<v t="karstenw.20170704105528.30"><vh>genStrokewidth</vh></v>
<v t="karstenw.20170704105528.31"><vh>genLoop</vh></v>
<v t="karstenw.20170704105528.32"><vh>genFor</vh></v>
<v t="karstenw.20170704105528.33"><vh>genGrid</vh></v>
<v t="karstenw.20170704105528.34"><vh>genVisual</vh></v>
<v t="karstenw.20170704105528.35"><vh>genStatement</vh></v>
<v t="karstenw.20170704105528.36"><vh>genProgram</vh></v>
</v>
</v>
<v t="karstenw.20170704105416.1"><vh>QTSupport</vh>
<v t="karstenw.20170704105551.1"><vh>@clean nodebox/util/QTSupport/__init__.py</vh>
<v t="karstenw.20170704105603.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105603.2"><vh>class Movie</vh>
<v t="karstenw.20170704105603.3"><vh>__init__</vh></v>
<v t="karstenw.20170704105603.4"><vh>add</vh></v>
<v t="karstenw.20170704105603.5"><vh>save</vh></v>
</v>
<v t="karstenw.20170704105603.6"><vh>test</vh></v>
</v>
</v>
<v t="karstenw.20170704105619.1"><vh>@clean nodebox/util/vdiff.py</vh>
<v t="karstenw.20170704105642.1"><vh>Declarations</vh></v>
<v t="karstenw.20170704105642.2"><vh>format_stats</vh></v>
<v t="karstenw.20170704105642.3"><vh>format_stats_list</vh></v>
<v t="karstenw.20170704105642.4"><vh>compare_pixel</vh></v>
<v t="karstenw.20170704105642.5"><vh>visual_diff</vh></v>
<v t="karstenw.20170704105642.6"><vh>make_comparison_image</vh></v>
<v t="karstenw.20170704105642.7"><vh>isEqual</vh></v>
<v t="karstenw.20170704105642.8" a="E"><vh>class Statistics</vh>
<v t="karstenw.20170704105642.9"><vh>__init__</vh></v>
<v t="karstenw.20170704105642.10"><vh>calculate</vh></v>
<v t="karstenw.20170704105642.11"><vh>_get_size</vh></v>
<v t="karstenw.20170704105642.12"><vh>_get_number_of_differences</vh></v>
<v t="karstenw.20170704105642.13"><vh>_get_comparison_image</vh></v>
<v t="karstenw.20170704105642.14"><vh>save_comparison_image</vh></v>
<v t="karstenw.20170704105642.15"><vh>__str__</vh></v>
</v>
<v t="karstenw.20170704105642.16"><vh>statistics</vh></v>
<v t="karstenw.20170704105642.17"><vh>test_vdiff</vh></v>
<v t="karstenw.20170704105642.18"><vh>usage</vh></v>
</v>
</v>
</v>
</v>
<v t="karstenw.20180202040514.1"><vh>+ c-libraries +</vh>
<v t="karstenw.20180202040520.1"><vh>bwdithering</vh>
<v t="karstenw.20180202040559.1"><vh>@clean libs/bwdithering/bwdithering.c</vh>
<v t="karstenw.20180202040658.1"><vh>includes &amp; globals</vh></v>
<v t="karstenw.20210320110747.1"><vh>py2/3 defs</vh></v>
<v t="karstenw.20210630165621.1"><vh>py 2/3 format strings</vh></v>
<v t="karstenw.20180202040628.1"><vh>int arrayindex</vh></v>
<v t="karstenw.20180202040628.2"><vh>void distributeError(x, y, w, h, type, errval, destImage, errorBuffer)</vh></v>
<v t="karstenw.20180202040628.3"><vh>static PyObject dither(self, args)</vh></v>
<v t="karstenw.20180202040628.4"><vh>static PyMethodDef bwdither_methods[]</vh></v>
<v t="karstenw.20180202040859.1"><vh>PyMODINIT_FUNC initbwdithering()</vh></v>
<v t="karstenw.20180202040628.5"><vh>int main</vh></v>
</v>
<v t="karstenw.20180202041015.1"><vh>@clean libs/bwdithering/setup.py</vh>
<v t="karstenw.20180202041040.1"><vh>Declarations</vh></v>
</v>
</v>
<v t="karstenw.20180202044244.1"><vh>cGeo</vh>
<v t="karstenw.20180202044248.1"><vh>@clean libs/cGeo/cGeo.c</vh>
<v t="karstenw.20180202044341.1"><vh>includes &amp; globals</vh></v>
<v t="karstenw.20210320110747.1"></v>
<v t="karstenw.20180202044313.1"><vh>float _fast_inverse_sqrt</vh></v>
<v t="karstenw.20180202044313.2"><vh>static PyObject fast_inverse_sqrt(self, args)</vh></v>
<v t="karstenw.20180202044313.3"><vh>void _angle(x0, y0, x1, y1, *a)</vh></v>
<v t="karstenw.20180202044313.4"><vh>static PyObject angle(self, args)</vh></v>
<v t="karstenw.20180202044313.5"><vh>void _distance(x0, y0, x1, y1, *d)</vh></v>
<v t="karstenw.20180202044313.6"><vh>static PyObject distance(self, args)</vh></v>
<v t="karstenw.20180202044313.7"><vh>void _coordinates(x0, y0, d, a, *x1, *y1)</vh></v>
<v t="karstenw.20180202044313.8"><vh>static PyObject coordinates(self, args)</vh></v>
<v t="karstenw.20180202044313.9"><vh>static PyMethodDef geometry_methods[]</vh></v>
<v t="karstenw.20180202044624.1"><vh>PyMODINIT_FUNC initcGeo()</vh></v>
<v t="karstenw.20180202044313.10"><vh>int main</vh></v>
</v>
<v t="karstenw.20180202044708.1"><vh>@clean libs/cGeo/setup.py</vh>
<v t="karstenw.20180202044720.1"><vh>Declarations</vh></v>
</v>
</v>
<v t="karstenw.20210320115101.1"><vh>fractal</vh>
<v t="karstenw.20210320115106.1"><vh>@clean libs/fractal/fractal.c</vh>
<v t="karstenw.20210320115212.1"><vh>declarations</vh></v>
<v t="karstenw.20210320110747.1"></v>
<v t="karstenw.20210630171229.1"><vh>py 2/3 format strings</vh></v>
<v t="karstenw.20210320115155.1"><vh>static PyObject</vh></v>
<v t="karstenw.20210320115155.2"><vh>static PyMethodDef</vh></v>
<v t="karstenw.20210320115155.3"><vh>int main</vh></v>
</v>
<v t="karstenw.20210320115144.1"><vh>@clean libs/fractal/setup.py</vh>
<v t="karstenw.20210320115153.1"><vh>Declarations</vh></v>
</v>
</v>
<v t="karstenw.20210320120737.1"><vh>pathmatics</vh>
<v t="karstenw.20210320120859.1"><vh>@clean libs/pathmatics/pathmatics.c</vh>
<v t="karstenw.20210320121857.1"><vh>declarations</vh></v>
<v t="karstenw.20210320110747.1"></v>
<v t="karstenw.20210320120941.1"><vh>void _linepoint</vh></v>
<v t="karstenw.20210320120941.2"><vh>void _linelength</vh></v>
<v t="karstenw.20210320120941.3"><vh>void _curvepoint</vh></v>
<v t="karstenw.20210320120941.4"><vh>void _curvepoint_handles</vh></v>
<v t="karstenw.20210320120941.5"><vh>void _curvelength</vh></v>
<v t="karstenw.20210320120941.6"><vh>static PyObject</vh></v>
<v t="karstenw.20210320120941.7"><vh>static PyObject</vh></v>
<v t="karstenw.20210320120941.8"><vh>static PyObject</vh></v>
<v t="karstenw.20210320120941.9"><vh>static PyObject</vh></v>
<v t="karstenw.20210320120941.10"><vh>static PyMethodDef</vh></v>
<v t="karstenw.20210320120941.11"><vh>int main</vh></v>
</v>
<v t="karstenw.20210320120918.1"><vh>@clean libs/pathmatics/pathmatics.py</vh>
<v t="karstenw.20210320120938.1"><vh>Declarations</vh></v>
<v t="karstenw.20210320120938.2"><vh>linepoint</vh></v>
<v t="karstenw.20210320120938.3"><vh>linelength</vh></v>
<v t="karstenw.20210320120938.4"><vh>curvepoint</vh></v>
<v t="karstenw.20210320120938.5"><vh>curvelength</vh></v>
</v>
<v t="karstenw.20210320120924.1" a="E"><vh>@clean libs/pathmatics/setup.py</vh>
<v t="karstenw.20210320120934.1"><vh>Declarations</vh></v>
</v>
</v>
<v t="karstenw.20210320120741.1"><vh>polymagic</vh>
<v t="karstenw.20210320123535.1"><vh>@clean libs/polymagic/gpc.h</vh>
<v t="karstenw.20210320125516.1"><vh>declarations</vh></v>
<v t="karstenw.20210320123811.1"><vh>typedef enum</vh></v>
<v t="karstenw.20210320123811.2"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123811.3"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123811.4"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123811.5"><vh>typedef struct</vh></v>
</v>
<v t="karstenw.20210320123635.1"><vh>@clean libs/polymagic/gpc.c</vh>
<v t="karstenw.20210320125621.1"><vh>declarations</vh></v>
<v t="karstenw.20210320123814.1"><vh>typedef enum</vh></v>
<v t="karstenw.20210320123814.2"><vh>typedef enum</vh></v>
<v t="karstenw.20210320123814.3"><vh>typedef enum</vh></v>
<v t="karstenw.20210320123814.4"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.5"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.6"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.7"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.8"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.9"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.10"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.11"><vh>typedef struct</vh></v>
<v t="karstenw.20210320123814.12"><vh>const h_state</vh></v>
<v t="karstenw.20210320123814.13"><vh>void reset_it</vh></v>
<v t="karstenw.20210320123814.14"><vh>void reset_lmt</vh></v>
<v t="karstenw.20210320123814.15"><vh>void insert_bound</vh></v>
<v t="karstenw.20210320123814.16"><vh>static edge_node</vh></v>
<v t="karstenw.20210320123814.17"><vh>void add_to_sbtree</vh></v>
<v t="karstenw.20210320123814.18"><vh>void build_sbt</vh></v>
<v t="karstenw.20210320123814.19"><vh>void free_sbtree</vh></v>
<v t="karstenw.20210320123814.20"><vh>int count_optimal_vertices</vh></v>
<v t="karstenw.20210320123814.21"><vh>static edge_node</vh></v>
<v t="karstenw.20210320123814.22"><vh>void add_edge_to_aet</vh></v>
<v t="karstenw.20210320123814.23"><vh>void add_intersection</vh></v>
<v t="karstenw.20210320123814.24"><vh>void add_st_edge</vh></v>
<v t="karstenw.20210320123814.25"><vh>void build_intersection_table</vh></v>
<v t="karstenw.20210320123814.26"><vh>int count_contours</vh></v>
<v t="karstenw.20210320123814.27"><vh>void add_left</vh></v>
<v t="karstenw.20210320123814.28"><vh>void merge_left</vh></v>
<v t="karstenw.20210320123814.29"><vh>void add_right</vh></v>
<v t="karstenw.20210320123814.30"><vh>void merge_right</vh></v>
<v t="karstenw.20210320123814.31"><vh>void add_local_min</vh></v>
<v t="karstenw.20210320123814.32"><vh>int count_tristrips</vh></v>
<v t="karstenw.20210320123814.33"><vh>void add_vertex</vh></v>
<v t="karstenw.20210320123814.34"><vh>void new_tristrip</vh></v>
<v t="karstenw.20210320123814.35"><vh>static bbox</vh></v>
<v t="karstenw.20210320123814.36"><vh>void minimax_test</vh></v>
<v t="karstenw.20210320123814.37"><vh>void gpc_free_polygon</vh></v>
<v t="karstenw.20210320123814.38"><vh>void gpc_read_polygon</vh></v>
<v t="karstenw.20210320123814.39"><vh>void gpc_write_polygon</vh></v>
<v t="karstenw.20210320123814.40"><vh>void gpc_add_contour</vh></v>
<v t="karstenw.20210320123814.41"><vh>void gpc_polygon_clip</vh></v>
<v t="karstenw.20210320123814.42"><vh>void gpc_free_tristrip</vh></v>
<v t="karstenw.20210320123814.43"><vh>void gpc_polygon_to_tristrip</vh></v>
<v t="karstenw.20210320123814.44"><vh>void gpc_tristrip_clip</vh></v>
</v>
<v t="karstenw.20210320123639.1"><vh>@clean libs/polymagic/polymagic.m</vh>
<v t="karstenw.20210320131053.1"><vh>declarations</vh></v>
<v t="karstenw.20210320110747.1"></v>
<v t="karstenw.20210320130456.1"><vh>kib functionl</vh></v>
<v t="karstenw.20210320131240.1"><vh>objc stuff</vh></v>
<v t="karstenw.20210320131126.1"><vh>PyMethodDef</vh></v>
<v t="karstenw.20210320133430.1"><vh>main</vh></v>
</v>
<v t="karstenw.20210320123652.1" a="E"><vh>@clean libs/polymagic/setup.py</vh>
<v t="karstenw.20210320123819.1"><vh>Declarations</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20170704103837.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704103857.1"># Startup file for the NodeBox OS X application
# PyObjC requires the startup file to be in the root folder.
# This just imports everything from the nodebox.gui.mac module
# and works from there


import os
import operator
import warnings
import io
import json
import optparse

import importlib
# import _multibytecodec

import sqlite3
import zipfile
import tarfile
import gzip

import hashlib
import base64
import re
import pickle
import pydoc

# pattern lib
import csv
import functools
import itertools
import codecs
import calendar
import types
import feedparser

import encodings

import requests


# for the libraries
import bs4

# moved to Library
import numpy


try:
    import planar
except:
    pass

# wn
import httpx
import tomllib
import anyio
import certifi
import httpcore
import idna
import sniffio
import h11

# nltk
import regex



# PIL / Pillow support
import PIL
import PIL.Image
import PIL.ImageFilter
import PIL.ImageChops
import PIL.ImageEnhance
import PIL.ImageOps
import PIL.ImageDraw
import PIL.ImageStat

# import cairo

import objc
import Foundation
import AppKit

import Quartz
import Quartz.QuartzCore
import AVFoundation
import AVKit
import LaunchServices
import WebKit

import CoreLocation



import  PyObjCTools
import  PyObjCTools.AppHelper

import  PyObjCTools.Signals
PyObjCTools.Signals.dumpStackOnFatalSignal()

import PyObjCTools.Debugging
PyObjCTools.Debugging.installVerboseExceptionHandler()


import nodebox
import nodebox.geo
import nodebox.graphics
import nodebox.gui
import nodebox.gui.mac

# pattern
# import xml.etree
# import xml.etree.cElementTree

# Do not import these here; they are in the app and are imported by scripts
# If you import here, 10.6 breaks
# import scipy
# import matplotlib
# import cairo

# Twyg is in Library
# import twyg


</t>
<t tx="karstenw.20170704103935.1"></t>
<t tx="karstenw.20170704103951.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104003.1">"""
Script for building NodeBox

Usage:
    python setup.py py2app
"""


import platform
from setuptools import setup
from setuptools.extension import Extension

import py2app

import nodebox

machine = platform.machine()

NAME = 'NodeBox'
VERSION = nodebox.__version__
py3 = nodebox.py3

BUNDLENAME = NAME + "_intel"
if machine.startswith("arm"):
    BUNDLENAME = NAME + "_arm"

AUTHOR = "Frederik De Bleser",
AUTHOR_EMAIL = "frederik@pandora.be",
URL = "http://nodebox.net/",
CLASSIFIERS = [
    "Development Status :: 5 - Production/Stable",
    "Environment :: MacOS X :: Cocoa",
    "Intended Audience :: Developers",
    "Intended Audience :: Education",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: MacOS :: MacOS X",
    "Programming Language :: Python",
    "Topic :: Artistic Software",
    "Topic :: Multimedia :: Graphics",
    "Topic :: Multimedia :: Graphics :: Editors :: Vector-Based",
    "Topic :: Multimedia :: Video",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
    "Topic :: Software Development :: User Interfaces",
    "Topic :: Text Editors :: Integrated Development Environments (IDE)",
]

DESCRIPTION = (u"Simple application for creating 2-dimensional graphics "
               u"and animation using Python code")
LONG_DESCRIPTION = u"""NodeBox is a Mac OS X application that allows you to create visual output with programming code. The application targets an audience of designers, with an easy set of state commands that is both intuitive and creative. It is essentially a learning environment and an automation tool.

The current version features:

* State-based graphics context
* Extensive reference documentation and tutorials
* PDF export for graphics
* QuickTime export for animations
* Manipulate every numeric variable in a script by command-dragging it, even during animation
* Creating simple user interfaces using text fields, sliders, and buttons
* Stop a running script by typing command-period
* Universal Binary
* Integrated bezier mathematics and boolean operations
* Command-line interface
* Zooming
"""



creator = 'NdBx'
bundleID = "net.nodebox.NodeBox"

setup(
    
    name = NAME,
    version = VERSION,
    description = DESCRIPTION,
    long_description = LONG_DESCRIPTION,
    author = AUTHOR,
    author_email = AUTHOR_EMAIL,
    url = URL,
    classifiers = CLASSIFIERS,

    app=[{
        'script': "macboot.py",

        "plist": {
            "NSPrincipalClass": 'NodeBoxApplication',
            "CFBundleIdentifier": bundleID,
            "CFBundleName": BUNDLENAME,
            "CFBundleSignature": creator,
            "CFBundleShortVersionString": VERSION,
            "CFBundleGetInfoString": DESCRIPTION,
            "NSHumanReadableCopyright": "Copyright (c) 2015 Frederik De Bleser",

            'CFBundleDocumentTypes': [
                {
                    'CFBundleTypeExtensions': [ 'py', 'bot', 'pv' ],
                    'CFBundleTypeIconFile': 'NodeBoxFile.icns',
                    'CFBundleTypeName': "Python File",
                    'CFBundleTypeOSTypes': [ '????', '****', 'utxt'],
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'NodeBoxDocument',
                }
            ]
        }
    }],

    data_files=[
        "Resources/English.lproj/AskString.nib",
        "Resources/English.lproj/Credits.rtf",
        "Resources/English.lproj/ExportImageAccessory.nib",
        "Resources/English.lproj/ExportMovieAccessory.nib",
        "Resources/English.lproj/MainMenu.nib",
        "Resources/English.lproj/NodeBoxDocument.nib",
        "Resources/English.lproj/NodeBoxPreferences.nib",
        "Resources/English.lproj/ProgressBarSheet.nib",
        "Resources/NodeBox.icns",
        "Resources/NodeBoxFile.icns",
        "Resources/zoombig.png",
        "Resources/zoomsmall.png"
        ],

    ext_modules=[
        Extension('bwdithering', ['libs/bwdithering/bwdithering.c']),
        Extension('fractal', ['libs/fractal/fractal.c']),
        Extension('cGeo', ['libs/cGeo/cGeo.c']),
        Extension('cPathmatics', ['libs/pathmatics/pathmatics.c']),
        Extension('cPolymagic', ['libs/polymagic/gpc.c', 'libs/polymagic/polymagic.m'],
                extra_link_args=['-framework', 'AppKit', '-framework', 'Foundation'])
    ],

    options={
        "py2app": {
            "iconfile": "Resources/NodeBox.icns",
            "packages": [ "requests", "numpy", #"scipy", "matplotlib", "sympy",
                        # "pandas", "cv2", "dlib", "skimage", "sklearn"],
            ],
            "excludes": [
                'TkInter', 'tkinter', 'tk', 'wx', 'sphinx',
                'pyqt5', 'qt5', 'PyQt5', 
                
                'setuptools', 'numba', 
                
                # 'certifi', 'pytz', 
                'notebook', 'nbformat', 'jedi', 'testpath', 'docutils',
                'ipykernel', 'parso', 'Cython', 'sphinx_rtd_theme', 'alabaster',
                'tornado', 'IPython', 'numpydoc', 'nbconvert', 
                'scipy', 'matplotlib', 
                'pandas', 'cv2', 'dlib', 'skimage', 'sklearn', 'mpl_toolkits', 
            ],
        }
    } )
</t>
<t tx="karstenw.20170704104018.1">@language python
@tabwidth -4
# This is a setup file for a command-line version of NodeBox.
# If you want to work on the Mac OS X version, go look in macsetup.py.

# This is your standard setup.py, so to install the package, use:
#     python setup.py install

# We require some dependencies:
# - PyObjC
# - py2app
# - cPathMatics (included in the "libs" folder)
# - polymagic (included in the "libs" folder)
# - Numpy (installable using "easy_install numpy")

@others
</t>
<t tx="karstenw.20170704104030.1">from distutils.core import setup, Extension
import nodebox

NAME = 'NodeBox'
VERSION = nodebox.__version__

AUTHOR = "Frederik De Bleser",
AUTHOR_EMAIL = "frederik@pandora.be",
URL = "http://nodebox.net/",
CLASSIFIERS = (
    "Development Status :: 5 - Production/Stable",
    "Environment :: MacOS X :: Cocoa",
    "Intended Audience :: Developers",
    "Intended Audience :: Education",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: MacOS :: MacOS X",
    "Programming Language :: Python",
    "Topic :: Artistic Software",
    "Topic :: Multimedia :: Graphics",
    "Topic :: Multimedia :: Graphics :: Editors :: Vector-Based",
    "Topic :: Multimedia :: Video",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
    "Topic :: Software Development :: User Interfaces",
    "Topic :: Text Editors :: Integrated Development Environments (IDE)",
)

DESCRIPTION = "Simple application for creating 2-dimensional graphics and animation using Python code"
LONG_DESCRIPTION = """NodeBox is a Mac OS X application that allows you to create visual output
with programming code. The application targets an audience of designers, with an easy set of state 
commands that is both intuitive and creative. It is essentially a learning environment and an automation tool.

The current version features:

* State-based graphics context
* Extensive reference documentation and tutorials
* PDF export for graphics
* QuickTime export for animations
* Manipulate every numeric variable in a script by command-dragging it, even during animation
* Creating simple user interfaces using text fields, sliders, and buttons
* Stop a running script by typing command-period
* Universal Binary
* Integrated bezier mathematics and boolean operations
* Command-line interface
* Zooming
"""


ext_modules=[
    Extension('bwdithering', ['libs/bwdithering/bwdithering.c']),
    Extension('fractal', ['libs/fractal/fractal.c']),
    Extension('cGeo', ['libs/cGeo/cGeo.c']),
    Extension('cPathmatics', ['libs/pathmatics/pathmatics.c']),
    Extension('cPolymagic', ['libs/polymagic/gpc.c', 'libs/polymagic/polymagic.m'],
            extra_link_args=['-framework', 'AppKit', '-framework', 'Foundation'])
]

packages = [
    'nodebox',
    'nodebox.graphics',
    # 'nodebox.graphics.bezier',
    # 'nodebox.graphics.cocoa',
    'nodebox.util',
    'nodebox.util.kgp',
    'nodebox.util.QTSupport',
    'nodebox.geo']

if __name__=='__main__':

    setup(name = NAME,
        version = VERSION,
        description = DESCRIPTION,
        long_description = LONG_DESCRIPTION,
        author = AUTHOR,
        author_email = AUTHOR_EMAIL,
        url = URL,
        classifiers = CLASSIFIERS,
        ext_modules = ext_modules,
        packages = packages
    )

</t>
<t tx="karstenw.20170704104045.1"></t>
<t tx="karstenw.20170704104053.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104119.1">__version__='1.10.2'

</t>
<t tx="karstenw.20170704104119.2">def get_version():
    return __version__

</t>
<t tx="karstenw.20170704104150.1">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    import sys
    test(sys.argv[1])

</t>
<t tx="karstenw.20170704104209.1">"""Module to analyze Python source code; for syntax coloring tools.

Interface:
    for tag, start, end, sublist in fontify(pytext, searchfrom, searchto):
        ...

The 'pytext' argument is a string containing Python source code.
The (optional) arguments 'searchfrom' and 'searchto' may contain a slice in pytext. 
The returned value is a list of tuples, formatted like this:
    [('keyword', 0, 6, None), ('keyword', 11, 17, None), ('comment', 23, 53, None), etc. ]
The tuple contents are always like this:
    (tag, startindex, endindex, sublist)
tag is one of 'keyword', 'string', 'comment' or 'identifier'
sublist is not used, hence always None. 
"""

# Based on FontText.py by Mitchell S. Chapman,
# which was modified by Zachary Roadhouse,
# then un-Tk'd by Just van Rossum.
# Many thanks for regular expression debugging &amp; authoring are due to:
#	Tim (the-incredib-ly y'rs) Peters and Cristian Tismer
# So, who owns the copyright? ;-) How about this:
# Copyright 1996-2003:
#	Mitchell S. Chapman,
#	Zachary Roadhouse,
#	Tim Peters,
#	Just van Rossum

# from __future__ import generators

__version__ = "0.5"

import io
import re

from . import graphics
from . import util

# import Foundation
# import objc

</t>
<t tx="karstenw.20170704104209.2">def fontify(pytext, searchfrom=0, searchto=None):
    if searchto is None:
        searchto = len(pytext)
    # Cache a few attributes for quicker reference.
    search = matchRE.search
    idMatch = idRE.match
    asMatch = asRE.match
    
    commentTag = 'comment'
    stringTag = 'string'
    keywordTag = 'keyword'
    identifierTag = 'identifier'
    
    start = 0
    end = searchfrom
    while 1:
        m = search(pytext, end)
        if m is None:
            break	# EXIT LOOP
        if start &gt;= searchto:
            break	# EXIT LOOP
        keyword = m.group(1)
        if keyword is not None:
            # matched a keyword
            start, end = m.span(1)
            yield keywordTag, start, end, None
            if keyword in ["def", "class"]:
                # If this was a defining keyword, color the
                # following identifier.
                m = idMatch(pytext, end)
                if m is not None:
                    start, end = m.span(1)
                    yield identifierTag, start, end, None
            elif keyword == "import":
                # color all the "as" words on same line;
                # cheap approximation to the truth
                while 1:
                    m = asMatch(pytext, end)
                    if not m:
                        break
                    start, end = m.span(1)
                    yield keywordTag, start, end, None
        elif m.group(0)[0] == "#":
            start, end = m.span()
            yield commentTag, start, end, None
        else:
            start, end = m.span()
            yield stringTag, start, end, None


</t>
<t tx="karstenw.20170704104209.3">def test(path):
    f = io.open(path, 'r', encoding="utf-8")
    text = f.read()
    f.close()
    for tag, start, end, sublist in fontify(text):
        print( "%s  %s" % (tag, repr(text[start:end])))


</t>
<t tx="karstenw.20170704104453.1"></t>
<t tx="karstenw.20170704104455.1"></t>
<t tx="karstenw.20170704104501.1"></t>
<t tx="karstenw.20170704104503.1"></t>
<t tx="karstenw.20170704104508.1"></t>
<t tx="karstenw.20170704104531.1">@language python
@tabwidth -4
# Geometric functionality

from __future__ import print_function

@others
</t>
<t tx="karstenw.20170704104605.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104615.1">from math import sqrt, pow

# from nodebox.geo import distance

</t>
<t tx="karstenw.20170704104615.2">def linepoint(t, x0, y0, x1, y1):

    """Returns coordinates for point at t on the line.

    Calculates the coordinates of x and y for a point
    at t on a straight line.

    The t parameter is a number between 0.0 and 1.0,
    x0 and y0 define the starting point of the line,
    x1 and y1 the ending point of the line,    

    """

    out_x = x0 + t * (x1-x0)
    out_y = y0 + t * (y1-y0)
    return (out_x, out_y)

</t>
<t tx="karstenw.20170704104615.3">def linelength(x0, y0, x1, y1):

    """Returns the length of the line."""
    #return distance(x0,y0, x1,y1)
    
    # fastest
    return math.sqrt((x1-x0)**2 + (y1-y0)**2)
    #a = pow(abs(x0 - x1), 2)
    #b = pow(abs(y0 - y1), 2)
    #return sqrt(a+b)

</t>
<t tx="karstenw.20170704104615.4">def curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3, handles=False):

    """Returns coordinates for point at t on the spline.

    Calculates the coordinates of x and y for a point
    at t on the cubic bezier spline, and its control points,
    based on the de Casteljau interpolation algorithm.

    The t parameter is a number between 0.0 and 1.0,
    x0 and y0 define the starting point of the spline,
    x1 and y1 its control point,
    x3 and y3 the ending point of the spline,
    x2 and y2 its control point.
    
    If the handles parameter is set,
    returns not only the point at t,
    but the modified control points of p0 and p3
    should this point split the path as well.
    """
    
    mint = 1 - t

    x01   = x0 * mint + x1 * t
    y01   = y0 * mint + y1 * t
    x12   = x1 * mint + x2 * t
    y12   = y1 * mint + y2 * t
    x23   = x2 * mint + x3 * t
    y23   = y2 * mint + y3 * t
   
    out_c1x = x01 * mint + x12 * t
    out_c1y = y01 * mint + y12 * t
    out_c2x = x12 * mint + x23 * t
    out_c2y = y12 * mint + y23 * t
    out_x = out_c1x * mint + out_c2x * t
    out_y = out_c1y * mint + out_c2y * t
    
    if not handles:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y)
    else:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y, x01, y01, x23, y23)

</t>
<t tx="karstenw.20170704104615.5">def curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n=20):

    """Returns the length of the spline.

    Integrates the estimated length of the cubic bezier spline
    defined by x0, y0, ... x3, y3, by adding the lengths of
    lineair lines between points at t.

    The number of points is defined by n 
    (n=10 would add the lengths of lines between 0.0 and 0.1, 
    between 0.1 and 0.2, and so on).

    The default n=20 is fine for most cases, usually
    resulting in a deviation of less than 0.01.
    """

    length = 0
    xi = x0
    yi = y0

    for i in range(n):
        t = 1.0 * (i+1) / n
        pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y = curvepoint(t, x0, y0,
                                                                   x1, y1,
                                                                   x2, y2,
                                                                   x3, y3)
        # TBD: replace distance calculation
        c = sqrt(pow(abs(xi-pt_x),2) + pow(abs(yi-pt_y),2))
        length += c
        xi = pt_x
        yi = pt_y
        
    return length
</t>
<t tx="karstenw.20170704104618.1">import math
</t>
<t tx="karstenw.20170704104618.2">def reflect(x0, y0, x1, y1, d=1.0, a=180):
    d *= distance(x0, y0, x1, y1)
    a += angle(x0, y0, x1, y1)
    x, y = coordinates(x0, y0, d, a)
    return x, y

</t>
<t tx="karstenw.20170704104646.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104725.1">
import pprint
import importlib

import pdb

import AppKit

from . import cocoa
graphics_impl = cocoa

BEVEL = cocoa.BEVEL
BOOLEAN = cocoa.BOOLEAN
BUTTON = cocoa.BUTTON
BUTT = cocoa.BUTT
BezierPath = cocoa.BezierPath
CENTER = cocoa.CENTER
CLOSE = cocoa.CLOSE
CMYK = cocoa.CMYK
CORNER = cocoa.CORNER
CURVETO = cocoa.CURVETO
Canvas = cocoa.Canvas
ClippingPath = cocoa.ClippingPath
Color = cocoa.Color
DEFAULT_HEIGHT = cocoa.DEFAULT_HEIGHT
DEFAULT_WIDTH = cocoa.DEFAULT_WIDTH
Grob = cocoa.Grob
HSB = cocoa.HSB
Image = cocoa.Image
JUSTIFY = cocoa.JUSTIFY
LEFT = cocoa.LEFT
LINETO = cocoa.LINETO
MENU = cocoa.MENU
MITER = cocoa.MITER
MOVETO = cocoa.MOVETO
NORMAL = cocoa.NORMAL
FORTYFIVE = cocoa.FORTYFIVE
NUMBER = cocoa.NUMBER
NodeBoxError = cocoa.NodeBoxError
Oval = cocoa.Oval
PathElement = cocoa.PathElement
Point = cocoa.Point
RGB = cocoa.RGB
RIGHT = cocoa.RIGHT
ROUND = cocoa.ROUND
Rect = cocoa.Rect
SQUARE = cocoa.SQUARE
TEXT = cocoa.TEXT
Text = cocoa.Text
Transform = cocoa.Transform
Variable = cocoa.Variable
cm = cocoa.cm
inch = cocoa.inch
mm = cocoa.mm


# from nodebox.util import _copy_attr, _copy_attrs
import nodebox.util
_copy_attr = nodebox.util._copy_attr
_copy_attrs = nodebox.util._copy_attrs

import nodebox.geo

# add graphics commands from cocoa
__all__ = list(graphics_impl.__all__)
__all__.extend(['Context'])


</t>
<t tx="karstenw.20170704104725.10">def background(self, *args):
    if len(args) &gt; 0:
        if len(args) == 1 and args[0] is None:
            self.canvas.background = None
        else:
            self.canvas.background = self.Color(args)
    return self.canvas.background

</t>
<t tx="karstenw.20170704104725.11">def outputmode(self, mode=None):
    if mode is not None:
        self._outputmode = mode
    return self._outputmode


</t>
<t tx="karstenw.20170704104725.12">def var(self, name, type,
        default=None, min=0, max=100, value=None,
        handler=None, menuitems=None):
    # pdb.set_trace()
    v = Variable(name, type, default, min, max, value, handler, menuitems)
    self.addvar(v)
    return v


</t>
<t tx="karstenw.20170704104725.13">def addvar(self, v):
    oldvar = self.findvar(v.name)
    if oldvar is not None:
        if oldvar.compliesTo(v):
            v.value = oldvar.value
    self._vars.append(v)
    self._ns[v.name] = v.value

</t>
<t tx="karstenw.20170704104725.14">def findvar(self, name):
    for v in self._oldvars:
        if v.name == name:
            return v
    return None


</t>
<t tx="karstenw.20170704104725.15">### Objects ####

def _makeInstance(self, clazz, args, kwargs):
    """Creates an instance of a class defined in this document.        
       This method sets the context of the object to the current context."""
    inst = clazz(self, *args, **kwargs)
    return inst

</t>
<t tx="karstenw.20170704104725.16">def BezierPath(self, *args, **kwargs):
    return self._makeInstance(BezierPath, args, kwargs)

</t>
<t tx="karstenw.20170704104725.17">def ClippingPath(self, *args, **kwargs):
    return self._makeInstance(ClippingPath, args, kwargs)

</t>
<t tx="karstenw.20170704104725.18">def Rect(self, *args, **kwargs):
    return self._makeInstance(Rect, args, kwargs)

</t>
<t tx="karstenw.20170704104725.19">def Oval(self, *args, **kwargs):
    return self._makeInstance(Oval, args, kwargs)

</t>
<t tx="karstenw.20170704104725.2">class Context(object):
    
    KEY_UP = graphics_impl.KEY_UP
    KEY_DOWN = graphics_impl.KEY_DOWN
    KEY_LEFT = graphics_impl.KEY_LEFT
    KEY_RIGHT = graphics_impl.KEY_RIGHT
    KEY_BACKSPACE = graphics_impl.KEY_BACKSPACE
    KEY_TAB = graphics_impl.KEY_TAB
    KEY_ESC = graphics_impl.KEY_ESC

    KEY_ENTER = graphics_impl.KEY_ENTER
    KEY_RETURN = graphics_impl.KEY_RETURN
    KEY_SPACE = graphics_impl.KEY_SPACE

    NORMAL = graphics_impl.NORMAL
    FORTYFIVE = graphics_impl.FORTYFIVE


    @others
</t>
<t tx="karstenw.20170704104725.20">def Color(self, *args, **kwargs):
    return self._makeInstance(Color, args, kwargs)

</t>
<t tx="karstenw.20170704104725.21">def Image(self, *args, **kwargs):
    # this creates a cocoa.Image instance. Devious.
    return self._makeInstance(Image, args, kwargs)

</t>
<t tx="karstenw.20170704104725.22">def Text(self, *args, **kwargs):
    return self._makeInstance(Text, args, kwargs)


</t>
<t tx="karstenw.20170704104725.23">### Primitives ###

def rect(self, x, y, width, height, roundness=0.0, draw=True, **kwargs):
    BezierPath.checkKwargs(kwargs)
    p = self.BezierPath(**kwargs)
    if roundness == 0:
        p.rect(x, y, width, height)
    else:
        curve = min(width*roundness, height*roundness)
        p.moveto(x, y+curve)
        p.curveto(x, y, x, y, x+curve, y)
        p.lineto(x+width-curve, y)
        p.curveto(x+width, y, x+width, y, x+width, y+curve)
        p.lineto(x+width, y+height-curve)
        p.curveto(x+width, y+height, x+width, y+height, x+width-curve, y+height)
        p.lineto(x+curve, y+height)
        p.curveto(x, y+height, x, y+height, x, y+height-curve)
        p.closepath()
    p.inheritFromContext(kwargs.keys())

    if draw:
        p.draw()
    return p

</t>
<t tx="karstenw.20170704104725.24">def oval(self, x, y, width, height, draw=True, **kwargs):
    BezierPath.checkKwargs(kwargs)
    path = self.BezierPath(**kwargs)
    path.oval(x, y, width, height)
    path.inheritFromContext(kwargs.keys())

    if draw:
        path.draw()
    return path

ellipse = oval


def circle(self, cx, cy, rx, ry=None, draw=True, **kwargs):
    if ry == None:
        ry = rx
    width = 2 * rx
    height = 2 * ry
    x = cx - rx
    y = cy - ry
    return self.oval( x, y, width, height, draw=draw, **kwargs )


</t>
<t tx="karstenw.20170704104725.25">def arc(self, x, y, r, startAngle, endAngle, draw=True, **kwargs):
    BezierPath.checkKwargs(kwargs)
    path = self.BezierPath(**kwargs)
    path.arc(x, y, r, startAngle, endAngle)
    path.inheritFromContext(kwargs.keys())
    if draw:
        path.draw()
    return path

</t>
<t tx="karstenw.20170704104725.26">def line(self, x1, y1, x2, y2, draw=True, **kwargs):
    BezierPath.checkKwargs(kwargs)
    p = self.BezierPath(**kwargs)
    p.line(x1, y1, x2, y2)
    p.inheritFromContext(kwargs.keys())
    if draw:
        p.draw()
    return p

</t>
<t tx="karstenw.20170704104725.27">def star(self, startx, starty, points=20, outer= 100, inner = 50, draw=True, **kwargs):
    BezierPath.checkKwargs(kwargs)
    from math import sin, cos, pi

    p = self.BezierPath(**kwargs)
    p.moveto(startx, starty + outer)

    for i in range(1, int(2 * points)):
        angle = i * pi / points
        x = sin(angle)
        y = cos(angle)
        if i % 2:
            radius = inner
        else:
            radius = outer
        x = startx + radius * x
        y = starty + radius * y
        p.lineto(x,y)

    p.closepath()
    p.inheritFromContext(kwargs.keys())
    if draw:
        p.draw()
    return p


# a working arrow implementation shold be here



</t>
<t tx="karstenw.20170704104725.28">def arrow(self, x, y, width=100, type=NORMAL, draw=True, **kwargs):

    """Draws an arrow.

    Draws an arrow at position x, y, with a default width of 100.
    There are two different types of arrows: NORMAL and trendy FORTYFIVE
    degrees arrows.  When draw=False then the arrow's path is not ended,
    similar to endpath(draw=False)."""

    BezierPath.checkKwargs(kwargs)
    if type==NORMAL:
        return self._arrow(x, y, width, draw, **kwargs)
    elif type==FORTYFIVE:
        return self._arrow45(x, y, width, draw, **kwargs)
    else:
        raise NodeBoxError( "arrow: available types for arrow() "
                            "are NORMAL and FORTYFIVE\n")

</t>
<t tx="karstenw.20170704104725.29">def _arrow(self, x, y, width, draw, **kwargs):

    head = width * .4
    tail = width * .2

    p = self.BezierPath(**kwargs)
    p.moveto(x, y)
    p.lineto(x-head, y+head)
    p.lineto(x-head, y+tail)
    p.lineto(x-width, y+tail)
    p.lineto(x-width, y-tail)
    p.lineto(x-head, y-tail)
    p.lineto(x-head, y-head)
    p.lineto(x, y)
    p.closepath()
    p.inheritFromContext(kwargs.keys())
    if draw:
        p.draw()
    return p

</t>
<t tx="karstenw.20170704104725.3">def __init__(self, canvas=None, ns=None):

    """Initializes the context.
    
    Note that we have to give the namespace of the executing script, 
    which is a hack to keep the WIDTH and HEIGHT properties updated.
    Python's getattr only looks up property values once: at assign time."""

    if canvas is None:
        canvas = Canvas()
    if ns is None:
        ns = {}
    self.canvas = canvas
    self._ns = ns
    self._imagecache = {}
    self._vars = []
    self._resetContext()

</t>
<t tx="karstenw.20170704104725.30">def _arrow45(self, x, y, width, draw, **kwargs):

    head = .3
    tail = 1 + head

    p = self.BezierPath(**kwargs)
    p.moveto(x, y)
    p.lineto(x, y+width*(1-head))
    p.lineto(x-width*head, y+width)
    p.lineto(x-width*head, y+width*tail*.4)
    p.lineto(x-width*tail*.6, y+width)
    p.lineto(x-width, y+width*tail*.6)
    p.lineto(x-width*tail*.4, y+width*head)
    p.lineto(x-width, y+width*head)
    p.lineto(x-width*(1-head), y)
    p.lineto(x, y)
    p.inheritFromContext(kwargs.keys())
    if draw:
        p.draw()
    return p


</t>
<t tx="karstenw.20170704104725.31">### Path Commands ###

def beginpath(self, x=None, y=None):
    self._path = self.BezierPath()
    self._pathclosed = False
    if x != None and y != None:
        self._path.moveto(x,y)

</t>
<t tx="karstenw.20170704104725.32">def moveto(self, x, y):
    if self._path is None:
        raise NodeBoxError("No current path. Use beginpath() first.")
    self._path.moveto(x,y)

</t>
<t tx="karstenw.20170704104725.33">def lineto(self, x, y):
    if self._path is None:
        raise NodeBoxError("No current path. Use beginpath() first.")
    self._path.lineto(x, y)

</t>
<t tx="karstenw.20170704104725.34">def curveto(self, x1, y1, x2, y2, x3, y3):
    if self._path is None:
        raise(NodeBoxError, "No current path. Use beginpath() first.")
    self._path.curveto(x1, y1, x2, y2, x3, y3)

</t>
<t tx="karstenw.20170704104725.35">def closepath(self):
    if self._path is None:
        raise NodeBoxError("No current path. Use beginpath() first.")
    if not self._pathclosed:
        self._path.closepath()

</t>
<t tx="karstenw.20170704104725.36">def endpath(self, draw=True):
    if self._path is None:
        raise NodeBoxError("No current path. Use beginpath() first.")
    if self._autoclosepath:
        self.closepath()
    p = self._path
    p.inheritFromContext()
    if draw:
        p.draw()
    self._path = None
    self._pathclosed = False
    return p

</t>
<t tx="karstenw.20170704104725.37">def drawpath(self, path, **kwargs):
    BezierPath.checkKwargs(kwargs)
    if isinstance(path, (list, tuple)):
        path = self.BezierPath(path, **kwargs)
    else: # Set the values in the current bezier path with the kwargs
        for arg_key, arg_val in kwargs.items():
            setattr(path, arg_key, _copy_attr(arg_val))
    path.inheritFromContext(kwargs.keys())
    path.draw()

</t>
<t tx="karstenw.20170704104725.38">def autoclosepath(self, close=True):
    self._autoclosepath = close

</t>
<t tx="karstenw.20170704104725.39">def findpath(self, points, curvature=1.0):
    from . import bezier
    path = bezier.findpath(points, curvature=curvature)
    path._ctx = self
    path.inheritFromContext()
    return path


</t>
<t tx="karstenw.20170704104725.4">def _resetContext(self):
    self._outputmode = RGB
    self._colormode = RGB
    self._colorrange = 1.0
    self._fillcolor = self.Color()
    self._strokecolor = None
    self._strokewidth = 1.0
    self._capstyle = BUTT
    self._joinstyle = MITER
    self.canvas.background = self.Color(1.0)
    self._path = None
    self._autoclosepath = True
    self._transform = Transform()
    self._transformmode = CENTER
    self._transformstack = []
    self._fontname = "Helvetica"
    self._fontsize = 24
    self._lineheight = 1.2
    self._align = LEFT
    self._noImagesHint = False
    self._oldvars = self._vars
    self._vars = []

</t>
<t tx="karstenw.20170704104725.40">### Clipping Commands ###

def beginclip(self, path):
    cp = self.ClippingPath(path)
    self.canvas.push(cp)
    return cp

</t>
<t tx="karstenw.20170704104725.41">def endclip(self):
    self.canvas.pop()


</t>
<t tx="karstenw.20170704104725.42">### Transformation Commands ###

def push(self): #, all=False):
    top = (self._transform.matrix,)
    if False: # all:
        top = (self._align, self._autoclosepath, self._capstyle, self._colormode,
               self._fillcolor, self._fontname, self._fontsize, self._joinstyle,
               self._lineheight, self._outputmode, self._strokecolor,
               self._strokewidth, self._transformmode, self._transform.matrix)
    self._transformstack.append(top)

</t>
<t tx="karstenw.20170704104725.43">def pop(self):
    try:
        top = self._transformstack.pop()
    except IndexError as e:
        raise NodeBoxError( "pop: too many pops!" )
    if len(top) &gt; 1:
        self._align, self._autoclosepath, self._capstyle, self._colormode,
        self._fillcolor, self._fontname, self._fontsize, self._joinstyle,
        self._lineheight, self._outputmode, self._strokecolor,
        self._strokewidth, self._transformmode, self._transform.matrix = top
    else:
        self._transform.matrix = top[0]

</t>
<t tx="karstenw.20170704104725.44">def transform(self, mode=None):
    if mode is not None:
        self._transformmode = mode
    return self._transformmode
    
</t>
<t tx="karstenw.20170704104725.46">def reset(self):
    self._transform = Transform()

</t>
<t tx="karstenw.20170704104725.47">def rotate(self, degrees=0, radians=0):
    self._transform.rotate(-degrees,-radians)

</t>
<t tx="karstenw.20170704104725.48">def translate(self, x=0, y=0):
    self._transform.translate(x,y)

</t>
<t tx="karstenw.20170704104725.5">def ximport(self, libName):
    lib = importlib.__import__( libName )
    if 0:
        scan = self.scanmodule( lib )
        # pprint.pprint( scan )
    self._ns[libName] = lib
    lib._ctx = self
    return lib
    
</t>
<t tx="karstenw.20170704104725.6">### Setup methods ###

def size(self, width, height):
    if width == 0 and height == 0:
        # set to main screen size
        allsc = AppKit.NSScreen.screens()
        mainscreen = allsc[0]
        mainframe = mainscreen.frame()
        width = mainframe.size.width
        height = mainframe.size.height

    self.canvas.width = width
    self.canvas.height = height
    self._ns["WIDTH"] = width
    self._ns["HEIGHT"] = height

</t>
<t tx="karstenw.20170704104725.7">def _get_width(self):
    return self.canvas.width

WIDTH = property(_get_width)

</t>
<t tx="karstenw.20170704104725.8">def _get_height(self):
    return self.canvas.height

HEIGHT = property(_get_height)

</t>
<t tx="karstenw.20170704104725.9">def speed(self, speed):
    self.canvas.speed = speed
    
</t>
<t tx="karstenw.20170704104726.1">def scale(self, x=1, y=None):
    self._transform.scale(x,y)

</t>
<t tx="karstenw.20170704104726.10">def capstyle(self, style=None):
    if style is not None:
        if style not in (BUTT, ROUND, SQUARE):
            raise NodeBoxError( 'Line cap style should be BUTT,'
                                ' ROUND or SQUARE.')
        self._capstyle = style
    return self._capstyle

</t>
<t tx="karstenw.20170704104726.11">def joinstyle(self, style=None):
    if style is not None:
        if style not in (MITER, ROUND, BEVEL):
            raise NodeBoxError( 'Line join style should be MITER,'
                                ' ROUND or BEVEL.')
        self._joinstyle = style
    return self._joinstyle


</t>
<t tx="karstenw.20170704104726.12">### Font Commands ###

def font(self, fontname=None, fontsize = None):
    if fontname is not None:
        if not Text.font_exists(fontname):
            raise NodeBoxError('Font "%s" not found.' % fontname )
        else:
            self._fontname = fontname
    if fontsize is not None:
        self._fontsize = fontsize
    return self._fontname

</t>
<t tx="karstenw.20170704104726.13">def fontsize(self, fontsize=None):
    if fontsize is not None:
        self._fontsize = fontsize
    return self._fontsize

</t>
<t tx="karstenw.20170704104726.14">def lineheight(self, lineheight=None):
    if lineheight is not None:
        self._lineheight = max(lineheight, 0.01)
    return self._lineheight

</t>
<t tx="karstenw.20170704104726.15">def align(self, align=None):
    if align is not None:
        self._align = align
    return self._align

</t>
<t tx="karstenw.20170704104726.16">def textwidth(self, txt, width=None, **kwargs):
    """Calculates the width of a single-line string."""
    return self.textmetrics(txt, width, **kwargs)[0]

</t>
<t tx="karstenw.20170704104726.17">def textheight(self, txt, width=None, **kwargs):
    """Calculates the height of a (probably) multi-line string."""
    return self.textmetrics(txt, width, **kwargs)[1]

</t>
<t tx="karstenw.20170704104726.18">def text(self, txt, x, y, width=None, height=None, outline=False, draw=True, **kwargs):
    Text.checkKwargs(kwargs)
    txt = self.Text(txt, x, y, width, height, **kwargs)
    txt.inheritFromContext(kwargs.keys())
    if outline:
        path = txt.path
        if draw:
            path.draw()
        return path
    else:
        if draw:
            txt.draw()
        return txt

</t>
<t tx="karstenw.20170704104726.19">def textpath(self, txt, x, y, width=None, height=None, **kwargs):
    # pdb.set_trace()
    Text.checkKwargs(kwargs)
    txt = self.Text(txt, x, y, width, height, **kwargs)
    txt.inheritFromContext( list( kwargs.keys()) )
    return txt.path

</t>
<t tx="karstenw.20170704104726.2">def skew(self, x=0, y=0):
    self._transform.skew(x,y)


</t>
<t tx="karstenw.20170704104726.20">def textmetrics(self, txt, width=None, height=None, **kwargs):
    txt = self.Text(txt, 0, 0, width, height, **kwargs)
    txt.inheritFromContext(kwargs.keys())
    return txt.metrics

</t>
<t tx="karstenw.20170704104726.21">def alltextmetrics(self, txt, width=None, height=None, **kwargs):
    txt = self.Text(txt, 0, 0, width, height, **kwargs)
    txt.inheritFromContext(kwargs.keys())
    return txt.allmetrics


</t>
<t tx="karstenw.20170704104726.22">### Image commands ###

def image(self, path, x, y, width=None, height=None, alpha=1.0,
                data=None, draw=True, **kwargs):
    
    # pdb.set_trace()
    
    img = self.Image(path, x, y, width, height, alpha, data=data, **kwargs)
    img.inheritFromContext( kwargs.keys() )
    if draw:
        img.draw()
    return img

</t>
<t tx="karstenw.20170704104726.23">def imagesize(self, path, data=None):
    img = self.Image(path, data=data)
    return img.size
    
</t>
<t tx="karstenw.20170704104726.24">### Canvas proxy ###

def save(self, fname, format=None):
    self.canvas.save(fname, format)


</t>
<t tx="karstenw.20170704104726.25">## cGeo

def isqrt( self, v):
    return nodebox.geo.isqrt( v )

</t>
<t tx="karstenw.20170704104726.26">def angle(self, x0, y0, x1, y1):
    return nodebox.geo.angle( x0, y0, x1, y1)

</t>
<t tx="karstenw.20170704104726.27">def distance(self, x0, y0, x1, y1):
    return nodebox.geo.distance( x0, y0, x1, y1)

</t>
<t tx="karstenw.20170704104726.28">def coordinates(self, x0, y0, distance, angle):
    return nodebox.geo.coordinates(x0, y0, distance, angle)

</t>
<t tx="karstenw.20170704104726.29">def reflect(self, x0, y0, x1, y1, d=1.0, a=180):
    return nodebox.geo.reflect(x0, y0, x1, y1, d, a)

## 

</t>
<t tx="karstenw.20170704104726.3">### Color Commands ###

color = Color

def colormode(self, mode=None, range=None):
    if mode is not None:
        self._colormode = mode
    if range is not None:
        self._colorrange = float(range)
    return self._colormode

</t>
<t tx="karstenw.20170704104726.4">def colorrange(self, range=None):
    if range is not None:
        self._colorrange = float(range)
    return self._colorrange

</t>
<t tx="karstenw.20170704104726.5">def nofill(self):
    self._fillcolor = None

</t>
<t tx="karstenw.20170704104726.6">def fill(self, *args):
    if len(args) &gt; 0:
        self._fillcolor = self.Color(*args)
    return self._fillcolor

</t>
<t tx="karstenw.20170704104726.7">def nostroke(self):
    self._strokecolor = None

</t>
<t tx="karstenw.20170704104726.8">def stroke(self, *args):
    if len(args) &gt; 0:
        self._strokecolor = self.Color(*args)
    return self._strokecolor

</t>
<t tx="karstenw.20170704104726.9">def strokewidth(self, width=None):
    if width is not None:
        self._strokewidth = max(width, 0.0001)
    return self._strokewidth
    
</t>
<t tx="karstenw.20170704104730.1">@language python
@tabwidth -4
# Bezier - last updated for NodeBox 1.8.3
# Author: Tom De Smedt &lt;tomdesmedt@trapdoor.be&gt;
# Manual: http://nodebox.net/code/index.php/Bezier
# Copyright (c) 2007 by Tom De Smedt.
# Refer to the "Use" section on http://nodebox.net/code
# Thanks to Dr. Florimond De Smedt at the Free University of Brussels for the math routines.

from __future__ import print_function
@others
if __name__=='__main__':
    _test()
</t>
<t tx="karstenw.20170704104742.1">
from nodebox.graphics import BezierPath, PathElement, NodeBoxError, Point
from nodebox.graphics import MOVETO, LINETO, CURVETO, CLOSE


try:
    import cPathmatics
    linepoint = cPathmatics.linepoint
    linelength = cPathmatics.linelength
    curvepoint = cPathmatics.curvepoint
    curvelength = cPathmatics.curvelength
except:
    import nodebox.geo.pathmatics
    linepoint = nodebox.geo.pathmatics.linepoint
    linelength = nodebox.geo.pathmatics.linelength
    curvepoint = nodebox.geo.pathmatics.curvepoint
    curvelength = nodebox.geo.pathmatics.curvelength


</t>
<t tx="karstenw.20170704104742.10">def _test():
    import doctest, bezier
    return doctest.testmod(bezier)

</t>
<t tx="karstenw.20170704104742.2">def segment_lengths(path, relative=False, n=20):
    """Returns a list with the lengths of each segment in the path.
    
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; segment_lengths(path)
    []
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; segment_lengths(path)
    []
    &gt;&gt;&gt; path.lineto(100, 0)
    &gt;&gt;&gt; segment_lengths(path)
    [100.0]
    &gt;&gt;&gt; path.lineto(100, 300)
    &gt;&gt;&gt; segment_lengths(path)
    [100.0, 300.0]
    &gt;&gt;&gt; segment_lengths(path, relative=True)
    [0.25, 0.75]
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; path.moveto(1, 2)
    &gt;&gt;&gt; path.curveto(3, 4, 5, 6, 7, 8)
    &gt;&gt;&gt; segment_lengths(path)
    [8.48528137423857]
    """

    lengths = []
    first = True

    for el in path:
        if first == True:
            close_x, close_y = el.x, el.y
            first = False
        elif el.cmd == MOVETO:
            close_x, close_y = el.x, el.y
            lengths.append(0.0)
        elif el.cmd == CLOSE:
            lengths.append(linelength(x0, y0, close_x, close_y))
        elif el.cmd == LINETO:
            lengths.append(linelength(x0, y0, el.x, el.y))
        elif el.cmd == CURVETO:
            x3, y3, x1, y1, x2, y2 = (el.x, el.y, el.ctrl1.x, el.ctrl1.y,
                                      el.ctrl2.x, el.ctrl2.y)
            lengths.append(curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n))
            
        if el.cmd != CLOSE:
            x0 = el.x
            y0 = el.y

    if relative:
        length = sum(lengths)
        try:
            lengths = list( map(lambda l: l / length, lengths) )
            return lengths
        except ZeroDivisionError:
            # If the length is zero, just return zero for all segments
            return [0.0] * len(lengths)
    else:
        return lengths

</t>
<t tx="karstenw.20170704104742.3">def length(path, segmented=False, n=20):

    """Returns the length of the path.

    Calculates the length of each spline in the path,
    using n as a number of points to measure.

    When segmented is True, returns a list
    containing the individual length of each spline
    as values between 0.0 and 1.0,
    defining the relative length of each spline
    in relation to the total path length.
    
    The length of an empty path is zero:
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; length(path)
    0.0

    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; path.lineto(100, 0)
    &gt;&gt;&gt; length(path)
    100.0

    &gt;&gt;&gt; path.lineto(100, 100)
    &gt;&gt;&gt; length(path)
    200.0

    # Segmented returns a list of each segment
    &gt;&gt;&gt; length(path, segmented=True)
    [0.5, 0.5]
    """

    if not segmented:
        return sum(segment_lengths(path, n=n), 0.0)
    else:
        return segment_lengths(path, relative=True, n=n)

</t>
<t tx="karstenw.20170704104742.4">def _locate(path, t, segments=None):
    
    """Locates t on a specific segment in the path.
    
    Returns (index, t, PathElement)
    
    A path is a combination of lines and curves (segments).
    The returned index indicates the start of the segment
    that contains point t.
    
    The returned t is the absolute time on that segment,
    in contrast to the relative t on the whole of the path.
    The returned point is the last MOVETO,
    any subsequent CLOSETO after i closes to that point.
    
    When you supply the list of segment lengths yourself,
    as returned from length(path, segmented=True),
    point() works about thirty times faster in a for-loop,
    since it doesn't need to recalculate the length
    during each iteration. Note that this has been deprecated:
    the BezierPath now caches the segment lengths the moment you use
    them.
    
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; _locate(path, 0.0)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.moveto(0,0)
    &gt;&gt;&gt; _locate(path, 0.0)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.lineto(100, 100)
    &gt;&gt;&gt; _locate(path, 0.0)
    (0, 0.0, Point(x=0.000, y=0.000))
    &gt;&gt;&gt; _locate(path, 1.0)
    (0, 1.0, Point(x=0.000, y=0.000))
    """
    

    if segments == None:
        segments = list( path.segmentlengths(relative=True) )
    
    if len(segments) == 0:
        raise NodeBoxError("The given path is empty")
    
    for i, el in enumerate(path):
        if i == 0 or el.cmd == MOVETO:
            closeto = Point(el.x, el.y)
        if t &lt;= segments[i] or i == len(segments)-1:
            break
        else:
            t -= segments[i]

    try:
        t = t / segments[i]
    except ZeroDivisionError:
        pass
    if i == len(segments)-1 and segments[i] == 0:
        i -= 1

    # print("_locate( ", i, t, closeto, " )")
    return (i, t, closeto)


</t>
<t tx="karstenw.20170704104742.5">def point(path, t, segments=None):

    """Returns coordinates for point at t on the path.

    Gets the length of the path, based on the length
    of each curve and line in the path.
    Determines in what segment t falls.
    Gets the point on that segment.
    
    When you supply the list of segment lengths yourself,
    as returned from length(path, segmented=True),
    point() works about thirty times faster in a for-loop,
    since it doesn't need to recalculate the length
    during each iteration. Note that this has been deprecated:
    the BezierPath now caches the segment lengths the moment you use
    them.
    
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; point(path, 0.0)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; point(path, 0.0)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.lineto(100, 0)
    &gt;&gt;&gt; point(path, 0.0)
    PathElement(LINETO, ((0.000, 0.000),))
    &gt;&gt;&gt; point(path, 0.1)
    PathElement(LINETO, ((10.000, 0.000),))
    """

    if len(path) == 0:
        raise NodeBoxError("The given path is empty")

    i, t, closeto = _locate(path, t, segments=segments)

    x0, y0 = path[i].x, path[i].y
    p1 = path[i+1]

    if p1.cmd == CLOSE:
        x, y = linepoint(t, x0, y0, closeto.x, closeto.y)
        return PathElement(LINETO, ((x, y),))

    elif p1.cmd == LINETO:
        x1, y1 = p1.x, p1.y
        x, y = linepoint(t, x0, y0, x1, y1)
        return PathElement(LINETO, ((x, y),))

    elif p1.cmd == CURVETO:
        x3, y3, x1, y1, x2, y2 = (p1.x, p1.y,
                                  p1.ctrl1.x, p1.ctrl1.y,
                                  p1.ctrl2.x, p1.ctrl2.y)
        x, y, c1x, c1y, c2x, c2y = curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3)
        return PathElement(CURVETO, ((c1x, c1y), (c2x, c2y), (x, y)))
    else:
        raise NodeBoxError("Unknown cmd for p1 %s" % p1 )


</t>
<t tx="karstenw.20170704104742.6">def points(path, amount=100):
    """Returns an iterator with a list of calculated points for the path.
    This method calls the point method &lt;amount&gt; times, increasing t,
    distributing point spacing linearly.

    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; list(points(path))
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; list(points(path))
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.lineto(100, 0)
    &gt;&gt;&gt; list(points(path, amount=4))
    [PathElement(LINETO, ((0.000, 0.000),)), PathElement(LINETO, ((33.333, 0.000),)), PathElement(LINETO, ((66.667, 0.000),)), PathElement(LINETO, ((100.000, 0.000),))]
    """

    if len(path) == 0:
        raise NodeBoxError("The given path is empty")

    # The delta value is divided by amount - 1, because we also want the last point (t=1.0)
    # If I wouldn't use amount - 1, I fall one point short of the end.
    # E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0,
    # if amount = 2, I want point at t 0.0 and t 1.0
    try:
        delta = 1.0 / (amount-1)
    except ZeroDivisionError:
        delta = 1.0

    for i in range(amount):
        yield point(path, delta*i)


</t>
<t tx="karstenw.20170704104742.7">def contours(path):
    """Returns a list of contours in the path.
    
    A contour is a sequence of lines and curves
    separated from the next contour by a MOVETO.
    
    For example, the glyph "o" has two contours:
    the inner circle and the outer circle.

    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; path.lineto(100, 100)
    &gt;&gt;&gt; len(contours(path))
    1
    
    A new contour is defined as something that starts with a moveto:
    &gt;&gt;&gt; path.moveto(50, 50)
    &gt;&gt;&gt; path.curveto(150, 150, 50, 250, 80, 95)
    &gt;&gt;&gt; len(contours(path))
    2

    Empty moveto's don't do anything:
    &gt;&gt;&gt; path.moveto(50, 50) 
    &gt;&gt;&gt; path.moveto(50, 50)
    &gt;&gt;&gt; len(contours(path))
    2
    
    It doesn't matter if the path is closed or open:
    &gt;&gt;&gt; path.closepath()
    &gt;&gt;&gt; len(contours(path))
    2
    """
    contours = []
    current_contour = None
    empty = True
    for i, el in enumerate(path):
        if el.cmd == MOVETO:
            if not empty:
                contours.append(current_contour)
            current_contour = BezierPath(path._ctx)
            current_contour.moveto(el.x, el.y)
            empty = True
        elif el.cmd == LINETO:
            empty = False
            current_contour.lineto(el.x, el.y)
        elif el.cmd == CURVETO:
            empty = False
            current_contour.curveto(el.ctrl1.x, el.ctrl1.y,
                                    el.ctrl2.x, el.ctrl2.y,
                                    el.x,       el.y)
        elif el.cmd == CLOSE:
            current_contour.closepath()
    if not empty:
        contours.append(current_contour)
    return contours


</t>
<t tx="karstenw.20170704104742.8">def findpath(points, curvature=1.0):
    
    """Constructs a path between the given list of points.
    
    Interpolates the list of points and determines
    a smooth bezier path betweem them.
    
    The curvature parameter offers some control on
    how separate segments are stitched together:
    from straight angles to smooth curves.
    Curvature is only useful if the path has more than  three points.
    """
    
    # The list of points consists of Point objects,
    # but it shouldn't crash on something straightforward
    # as someone supplying a list of (x,y)-tuples.
    
    for i, pt in enumerate(points):
        if type(pt) in (tuple,):
            points[i] = Point(pt[0], pt[1])
    
    if len(points) == 0: return None
    if len(points) == 1:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        return path
    if len(points) == 2:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        path.lineto(points[1].x, points[1].y)
        return path
              
    # Zero curvature means straight lines.
    
    curvature = max(0, min(1, curvature))
    if curvature == 0:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        for i in range(len(points)): 
            path.lineto(points[i].x, points[i].y)
        return path
        
    curvature = 4 + (1.0-curvature)*40
    
    dx = {0: 0, len(points)-1: 0}
    dy = {0: 0, len(points)-1: 0}
    bi = {1: -0.25}
    ax = {1: (points[2].x-points[0].x-dx[0]) / 4}
    ay = {1: (points[2].y-points[0].y-dy[0]) / 4}
    
    for i in range(2, len(points)-1):
        bi[i] = -1 / (curvature + bi[i-1])
        ax[i] = -(points[i+1].x-points[i-1].x-ax[i-1]) * bi[i]
        ay[i] = -(points[i+1].y-points[i-1].y-ay[i-1]) * bi[i]
        
    r = list( range(1, len(points)-1) )
    r.reverse()
    for i in r:
        dx[i] = ax[i] + dx[i+1] * bi[i]
        dy[i] = ay[i] + dy[i+1] * bi[i]

    path = BezierPath(None)
    path.moveto(points[0].x, points[0].y)
    for i in range(len(points)-1):
        path.curveto(points[i].x + dx[i], 
                     points[i].y + dy[i],
                     points[i+1].x - dx[i+1], 
                     points[i+1].y - dy[i+1],
                     points[i+1].x,
                     points[i+1].y)
    
    return path


</t>
<t tx="karstenw.20170704104742.9">def insert_point(path, t):
    
    """Returns a path copy with an extra point at t.
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; insert_point(path, 0.1)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.moveto(0, 0)
    &gt;&gt;&gt; insert_point(path, 0.2)
    Traceback (most recent call last):
        ...
    NodeBoxError: The given path is empty
    &gt;&gt;&gt; path.lineto(100, 50)
    &gt;&gt;&gt; len(path)
    2
    &gt;&gt;&gt; path = insert_point(path, 0.5)
    &gt;&gt;&gt; len(path)
    3
    &gt;&gt;&gt; path[1]
    PathElement(LINETO, ((50.000, 25.000),))
    &gt;&gt;&gt; path = BezierPath(None)
    &gt;&gt;&gt; path.moveto(0, 100)
    &gt;&gt;&gt; path.curveto(0, 50, 100, 50, 100, 100)
    &gt;&gt;&gt; path = insert_point(path, 0.5)
    &gt;&gt;&gt; path[1]
    PathElement(CURVETO, ((0.000, 75.000), (25.000, 62.5), (50.000, 62.500))
    """
    
    i, t, closeto = _locate(path, t)
    
    x0 = path[i].x
    y0 = path[i].y
    p1 = path[i+1]
    p1cmd, x3, y3, x1, y1, x2, y2 = (p1.cmd, p1.x, p1.y,
                                             p1.ctrl1.x, p1.ctrl1.y,
                                             p1.ctrl2.x, p1.ctrl2.y)
    
    if p1cmd == CLOSE:
        pt_cmd = LINETO
        pt_x, pt_y = linepoint(t, x0, y0, closeto.x, closeto.y)
    elif p1cmd == LINETO:
        pt_cmd = LINETO
        pt_x, pt_y = linepoint(t, x0, y0, x3, y3)
    elif p1cmd == CURVETO:
        pt_cmd = CURVETO
        s = curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3, True)
        pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y, pt_h1x, pt_h1y, pt_h2x, pt_h2y = s
    else:
        raise NodeBoxError("Locate should not return a MOVETO")
    
    new_path = BezierPath(None)
    new_path.moveto(path[0].x, path[0].y)
    for j in range(1, len(path)):
        if j == i+1:
            if pt_cmd == CURVETO:
                new_path.curveto(pt_h1x, pt_h1y,
                             pt_c1x, pt_c1y,
                             pt_x, pt_y)
                new_path.curveto(pt_c2x, pt_c2y,
                             pt_h2x, pt_h2y,
                             path[j].x, path[j].y)
            elif pt_cmd == LINETO:
                new_path.lineto(pt_x, pt_y)
                if path[j].cmd != CLOSE:
                    new_path.lineto(path[j].x, path[j].y)
                else:
                    new_path.closepath()
            else:
                raise NodeBoxError("Didn't expect pt_cmd %s here" % pt_cmd)
            
        else:
            if path[j].cmd == MOVETO:
                new_path.moveto(path[j].x, path[j].y)
            if path[j].cmd == LINETO:
                new_path.lineto(path[j].x, path[j].y)
            if path[j].cmd == CURVETO:
                new_path.curveto(path[j].ctrl1.x, path[j].ctrl1.y,
                             path[j].ctrl2.x, path[j].ctrl2.y,
                             path[j].x, path[j].y)
            if path[j].cmd == CLOSE:
                new_path.closepath()
    return new_path
    
</t>
<t tx="karstenw.20170704104743.1">@language python
@tabwidth -4
@others
if __name__=='__main__':
    _test()
</t>
<t tx="karstenw.20170704104751.1">import os
import warnings

import math

# from random import choice, shuffle
import random
choice = random.choice
shuffle = random.shuffle

import objc
super = objc.super

import pdb

# from AppKit import *
import AppKit
NSBezierPath = AppKit.NSBezierPath
NSColor = AppKit.NSColor
NSGraphicsContext = AppKit.NSGraphicsContext

NSView = AppKit.NSView

NSDeviceCMYKColorSpace = AppKit.NSDeviceCMYKColorSpace
NSDeviceRGBColorSpace = AppKit.NSDeviceRGBColorSpace
NSAffineTransform = AppKit.NSAffineTransform
NSImage = AppKit.NSImage
NSImageCacheNever = AppKit.NSImageCacheNever
NSCompositeSourceOver = AppKit.NSCompositeSourceOver
NSLeftTextAlignment = AppKit.NSLeftTextAlignment
NSFont = AppKit.NSFont
NSMutableParagraphStyle = AppKit.NSMutableParagraphStyle
NSLineBreakByWordWrapping = AppKit.NSLineBreakByWordWrapping
NSParagraphStyleAttributeName = AppKit.NSParagraphStyleAttributeName
NSForegroundColorAttributeName = AppKit.NSForegroundColorAttributeName
NSFontAttributeName = AppKit.NSFontAttributeName
NSTextStorage = AppKit.NSTextStorage
NSLayoutManager = AppKit.NSLayoutManager
NSTextContainer = AppKit.NSTextContainer
NSRectFillUsingOperation = AppKit.NSRectFillUsingOperation
NSGIFFileType = AppKit.NSGIFFileType
NSJPEGFileType = AppKit.NSJPEGFileType
NSJPEGFileType = AppKit.NSJPEGFileType
NSPNGFileType = AppKit.NSPNGFileType
NSTIFFFileType = AppKit.NSTIFFFileType
NSBitmapImageRep = AppKit.NSBitmapImageRep
NSString = AppKit.NSString
NSData = AppKit.NSData
NSAffineTransformStruct = AppKit.NSAffineTransformStruct


import nodebox.util
_copy_attr = nodebox.util._copy_attr
_copy_attrs = nodebox.util._copy_attrs
makeunicode = nodebox.util.makeunicode


try:
    import cPolymagic
except ImportError as e:
    warnings.warn('Could not load cPolymagic: %s' % e)

__all__ = [
        "DEFAULT_WIDTH", "DEFAULT_HEIGHT",
        "inch", "cm", "mm",
        "RGB", "HSB", "CMYK",
        "CENTER", "CORNER",
        "MOVETO", "LINETO", "CURVETO", "CLOSE",
        "MITER", "ROUND", "BEVEL", "BUTT", "SQUARE",
        "LEFT", "RIGHT", "CENTER", "JUSTIFY",
        "NORMAL","FORTYFIVE",
        "NUMBER", "TEXT", "BOOLEAN","BUTTON", "MENU",
        "NodeBoxError",
        "Point", "Grob", "BezierPath", "PathElement", "ClippingPath", "Rect",
        "Oval",
        "Color", "Transform", "Image", "Text",
        "Variable", "Canvas",
        ]

DEFAULT_WIDTH, DEFAULT_HEIGHT = 1000, 1000

# unused
inch = 72.0
cm = inch / 2.54
mm = cm * 10.0


RGB = "rgb"
HSB = "hsb"
CMYK = "cmyk"


MOVETO = AppKit.NSMoveToBezierPathElement
LINETO = AppKit.NSLineToBezierPathElement
CURVETO = AppKit.NSCurveToBezierPathElement
CLOSE = AppKit.NSClosePathBezierPathElement

MITER = AppKit.NSMiterLineJoinStyle
ROUND = AppKit.NSRoundLineJoinStyle # Also used for NSRoundLineCapStyle, same value.
BEVEL = AppKit.NSBevelLineJoinStyle
BUTT = AppKit.NSButtLineCapStyle
SQUARE = AppKit.NSSquareLineCapStyle

LEFT = AppKit.NSLeftTextAlignment
RIGHT = AppKit.NSRightTextAlignment
CENTER = AppKit.NSCenterTextAlignment
JUSTIFY = AppKit.NSJustifiedTextAlignment

# don't want to override justification.CENTER
# CENTER = "center"
CORNER = 4 #"corner"


NORMAL=1
FORTYFIVE=2

NUMBER = 1
TEXT = 2
BOOLEAN = 3
BUTTON = 4
MENU = 5

KEY_UP = 126
KEY_DOWN = 125
KEY_LEFT = 123
KEY_RIGHT = 124
KEY_BACKSPACE = 51
KEY_TAB = 48
KEY_ESC = 53

KEY_ENTER = 76
KEY_RETURN = 36
KEY_SPACE = 49


_STATE_NAMES = {
    '_outputmode':    'outputmode',
    '_colorrange':    'colorrange',
    '_fillcolor':     'fill',
    '_strokecolor':   'stroke',
    '_strokewidth':   'strokewidth',
    '_capstyle':      'capstyle',
    '_joinstyle':     'joinstyle',
    '_transform':     'transform',
    '_transformmode': 'transformmode',
    '_fontname':      'font',
    '_fontsize':      'fontsize',
    '_align':         'align',
    '_lineheight':    'lineheight',
}


</t>
<t tx="karstenw.20170704104751.10">class Grob(object):
    """A GRaphic OBject is the base class for all DrawingPrimitives."""

    @others
</t>
<t tx="karstenw.20170704104751.100">def _get_saturation(self):
    return self._rgb.saturationComponent()
</t>
<t tx="karstenw.20170704104751.101">def _set_saturation(self, val):
    val = self._normalize(val)
    h, s, b, a = self._rgb.getHue_saturation_brightness_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(h, val, b, a)
    self._updateCmyk()
s = saturation = property(_get_saturation,
                          _set_saturation,
                          doc="the saturation of the color")

</t>
<t tx="karstenw.20170704104751.102">def _get_brightness(self):
    return self._rgb.brightnessComponent()

</t>
<t tx="karstenw.20170704104751.103">def _set_brightness(self, val):
    val = self._normalize(val)
    h, s, b, a = self._rgb.getHue_saturation_brightness_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(h, s, val, a)
    self._updateCmyk()
v = brightness = property(_get_brightness,
                          _set_brightness,
                          doc="the brightness of the color")

</t>
<t tx="karstenw.20170704104751.104">def _get_hsba(self):
    return self._rgb.getHue_saturation_brightness_alpha_(None, None, None, None)

</t>
<t tx="karstenw.20170704104751.105">def _set_hsba(self, values):
    val = self._normalize(val)
    h, s, b, a = values
    self._rgb = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(h, s, b, a)
    self._updateCmyk()
hsba = property(_get_hsba,
                _set_hsba,
                doc="the hue, saturation, brightness and alpha of the color")

</t>
<t tx="karstenw.20170704104751.106">def _get_red(self):
    return self._rgb.redComponent()

</t>
<t tx="karstenw.20170704104751.107">def _set_red(self, val):
    val = self._normalize(val)
    r, g, b, a = self._rgb.getRed_green_blue_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceRed_green_blue_alpha_(val, g, b, a)
    self._updateCmyk()
r = red = property(_get_red, _set_red, doc="the red component of the color")

</t>
<t tx="karstenw.20170704104751.108">def _get_green(self):
    return self._rgb.greenComponent()

</t>
<t tx="karstenw.20170704104751.109">def _set_green(self, val):
    val = self._normalize(val)
    r, g, b, a = self._rgb.getRed_green_blue_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceRed_green_blue_alpha_(r, val, b, a)
    self._updateCmyk()
g = green = property(_get_green, _set_green, doc="the green component of the color")

</t>
<t tx="karstenw.20170704104751.11">def __init__(self, ctx):
    """Initializes this object with the current context."""
    self._ctx = ctx

</t>
<t tx="karstenw.20170704104751.110">def _get_blue(self):
    return self._rgb.blueComponent()
</t>
<t tx="karstenw.20170704104751.111">def _set_blue(self, val):
    val = self._normalize(val)
    r, g, b, a = self._rgb.getRed_green_blue_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, val, a)
    self._updateCmyk()
b = blue = property(_get_blue, _set_blue, doc="the blue component of the color")

</t>
<t tx="karstenw.20170704104751.112">def _get_alpha(self):
    return self._rgb.alphaComponent()
</t>
<t tx="karstenw.20170704104751.113">def _set_alpha(self, val):
    val = self._normalize(val)
    r, g, b, a = self._rgb.getRed_green_blue_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, b, val)
    self._updateCmyk()
a = alpha = property(_get_alpha, _set_alpha, doc="the alpha component of the color")

</t>
<t tx="karstenw.20170704104751.114">def _get_rgba(self):
    return self._rgb.getRed_green_blue_alpha_(None, None, None, None)

</t>
<t tx="karstenw.20170704104751.115">def _set_rgba(self, val):
    val = self._normalizeList(val)
    r, g, b, a = val
    self._rgb = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, b, a)
    self._updateCmyk()
rgba = property(_get_rgba,
                _set_rgba,
                doc="the red, green, blue and alpha values of the color")

</t>
<t tx="karstenw.20170704104751.116">def _get_cyan(self):
    return self._cmyk.cyanComponent()

</t>
<t tx="karstenw.20170704104751.117">def _set_cyan(self, val):
    val = self._normalize(val)
    c, m, y, k, a = self.cmyka
    self._cmyk = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(val, m, y, k, a)
    self._updateRgb()
c = cyan = property(_get_cyan, _set_cyan, doc="the cyan component of the color")

</t>
<t tx="karstenw.20170704104751.118">def _get_magenta(self):
    return self._cmyk.magentaComponent()

</t>
<t tx="karstenw.20170704104751.119">def _set_magenta(self, val):
    val = self._normalize(val)
    c, m, y, k, a = self.cmyka
    self._cmyk = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(c, val, y, k, a)
    self._updateRgb()
m = magenta = property(_get_magenta,
                       _set_magenta,
                       doc="the magenta component of the color")

</t>
<t tx="karstenw.20170704104751.12">def draw(self):
    """Appends the grob to the canvas.
       This will result in a draw later on, when the scene graph is rendered."""
    self._ctx.canvas.append(self)
    
</t>
<t tx="karstenw.20170704104751.120">def _get_yellow(self):
    return self._cmyk.yellowComponent()

</t>
<t tx="karstenw.20170704104751.121">def _set_yellow(self, val):
    val = self._normalize(val)
    c, m, y, k, a = self.cmyka
    self._cmyk = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(
                                                            c, m, val, k, a)
    self._updateRgb()
y = yellow = property(_get_yellow,
                      _set_yellow,
                      doc="the yellow component of the color")

</t>
<t tx="karstenw.20170704104751.122">def _get_black(self):
    return self._cmyk.blackComponent()

</t>
<t tx="karstenw.20170704104751.123">def _set_black(self, val):
    val = self._normalize(val)
    c, m, y, k, a = self.cmyka
    self._cmyk = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(
                                                            c, m, y, val, a)
    self._updateRgb()
k = black = property(_get_black,
                     _set_black,
                     doc="the black component of the color")

</t>
<t tx="karstenw.20170704104751.124">def _get_cmyka(self):
    return (self._cmyk.cyanComponent(),
            self._cmyk.magentaComponent(),
            self._cmyk.yellowComponent(),
            self._cmyk.blackComponent(),
            self._cmyk.alphaComponent())
cmyka = property(_get_cmyka, doc="a tuple containing the CMYKA values for this color")

</t>
<t tx="karstenw.20170704104751.125">def blend(self, otherColor, factor):
    """Blend the color with otherColor with a factor; return the new color. Factor
    is a float between 0.0 and 1.0.
    """
    if hasattr(otherColor, "color"):
        otherColor = otherColor._rgb
    return self.__class__(color=self._rgb.blendedColorWithFraction_ofColor_(
            factor, otherColor))

</t>
<t tx="karstenw.20170704104751.126">def _normalize(self, v):
    """Bring the color into the 0-1 scale for the current colorrange"""
    if self._ctx._colorrange == 1.0:
        return v
    return v / self._ctx._colorrange

</t>
<t tx="karstenw.20170704104751.127">def _normalizeList(self, lst):
    """Bring the color into the 0-1 scale for the current colorrange"""
    r = self._ctx._colorrange
    if r == 1.0:
        return lst
    return [v / r for v in lst]
</t>
<t tx="karstenw.20170704104751.128">class Transform(object):

    @others
</t>
<t tx="karstenw.20170704104751.129">def __init__(self, transform=None):
    if transform is None:
        transform = NSAffineTransform.transform()
    elif isinstance(transform, Transform):
        matrix = transform._nsAffineTransform.transformStruct()
        transform = NSAffineTransform.transform()
        transform.setTransformStruct_(matrix)
    elif isinstance(transform, (list, tuple, NSAffineTransformStruct)):
        matrix = tuple(transform)
        transform = NSAffineTransform.transform()
        transform.setTransformStruct_(matrix)
    elif isinstance(transform, NSAffineTransform):
        pass
    else:
        raise NodeBoxError("Don't know how to handle transform %s." % transform)
    self._nsAffineTransform = transform
    
</t>
<t tx="karstenw.20170704104751.13">def copy(self):
    """Returns a deep copy of this grob."""
    raise NotImplementedError("Copy is not implemented on this Grob class.")
    
</t>
<t tx="karstenw.20170704104751.130">def _get_transform(self):
    s = ("The 'transform' attribute is deprecated. "
         "Please use _nsAffineTransform instead.")
    warnings.warn(s, DeprecationWarning, stacklevel=2)
    return self._nsAffineTransform
transform = property(_get_transform)

</t>
<t tx="karstenw.20170704104751.131">def set(self):
    self._nsAffineTransform.set()

</t>
<t tx="karstenw.20170704104751.132">def concat(self):
    self._nsAffineTransform.concat()

</t>
<t tx="karstenw.20170704104751.133">def copy(self):
    return self.__class__(self._nsAffineTransform.copy())

</t>
<t tx="karstenw.20170704104751.134">def __repr__(self):
    return "&lt;%s [%.3f %.3f %.3f %.3f %.3f %.3f]&gt;" % ((self.__class__.__name__,)
                                                      + tuple(self))

</t>
<t tx="karstenw.20170704104751.135">def __iter__(self):
    for value in self._nsAffineTransform.transformStruct():
        yield value

</t>
<t tx="karstenw.20170704104751.136">def _get_matrix(self):
    return self._nsAffineTransform.transformStruct()

</t>
<t tx="karstenw.20170704104751.137">def _set_matrix(self, value):
    self._nsAffineTransform.setTransformStruct_(value)
matrix = property(_get_matrix, _set_matrix)

</t>
<t tx="karstenw.20170704104751.138">def rotate(self, degrees=0, radians=0):
    if degrees:
        self._nsAffineTransform.rotateByDegrees_(degrees)
    else:
        self._nsAffineTransform.rotateByRadians_(radians)

</t>
<t tx="karstenw.20170704104751.139">def translate(self, x=0, y=0):
    self._nsAffineTransform.translateXBy_yBy_(x, y)

</t>
<t tx="karstenw.20170704104751.14">def inheritFromContext(self, ignore=()):
    attrs_to_copy = list(self.__class__.stateAttributes)
    [attrs_to_copy.remove(k) for k, v in _STATE_NAMES.items() if v in ignore]
    _copy_attrs(self._ctx, self, attrs_to_copy)
    
</t>
<t tx="karstenw.20170704104751.140">def scale(self, x=1, y=None):
    if y is None:
        y = x
    self._nsAffineTransform.scaleXBy_yBy_(x, y)

</t>
<t tx="karstenw.20170704104751.141">def skew(self, x=0, y=0):
    x = math.pi * x / 180
    y = math.pi * y / 180
    t = Transform()
    t.matrix = 1, math.tan(y), -math.tan(x), 1, 0, 0
    self.prepend(t)

</t>
<t tx="karstenw.20170704104751.142">def invert(self):
    self._nsAffineTransform.invert()

</t>
<t tx="karstenw.20170704104751.143">def append(self, other):
    if isinstance(other, Transform):
        other = other._nsAffineTransform
    self._nsAffineTransform.appendTransform_(other)

</t>
<t tx="karstenw.20170704104751.144">def prepend(self, other):
    if isinstance(other, Transform):
        other = other._nsAffineTransform
    self._nsAffineTransform.prependTransform_(other)

</t>
<t tx="karstenw.20170704104751.145">def transformPoint(self, point):
    return self._nsAffineTransform.transformPoint_(point)

</t>
<t tx="karstenw.20170704104751.146">def transformBezierPath(self, path):
    if isinstance(path, BezierPath):
        path = BezierPath(path._ctx, path)
    else:
        raise NodeBoxError("Can only transform BezierPaths")
    path._nsBezierPath = self._nsAffineTransform.transformBezierPath_(path._nsBezierPath)
    return path


</t>
<t tx="karstenw.20170704104751.147">class Image(Grob, TransformMixin):

    stateAttributes = ('_transform', '_transformmode')
    kwargs = ()

    @others
</t>
<t tx="karstenw.20170704104751.148">def __init__(self, ctx, path=None, x=0, y=0,
                   width=None, height=None, alpha=1.0, image=None, data=None):
    """
    Parameters:
     - path: A path to a certain image on the local filesystem.
     - x: Horizontal position.
     - y: Vertical position.
     - width: Maximum width. Images get scaled according to this factor.
     - height: Maximum height. Images get scaled according to this factor.
          If a width and height are both given, the smallest 
          of the two is chosen.
     - alpha: transparency factor
     - image: optionally, an Image or NSImage object.
     - data: a stream of bytes of image data.
    """
    super(Image, self).__init__(ctx)
    TransformMixin.__init__(self)

    # pdb.set_trace()

    if data is not None:
        if not isinstance(data, NSData):
            data = NSData.dataWithBytes_length_(data, len(data))
        
        self._nsImage = NSImage.alloc().initWithData_(data)
        
        if self._nsImage is None:
            raise NodeBoxError("can't read image %r" % path)
        self._nsImage.setFlipped_(True)
        self._nsImage.setCacheMode_(NSImageCacheNever)

    elif image is not None:
        # TODO: insert PIL.Image handling here
        if isinstance(image, NSImage):
            self._nsImage = image
            self._nsImage.setFlipped_(True)
        else:
            raise NodeBoxError("Don't know what to do with %s." % image)

    elif path is not None:
        if not os.path.exists(path):
            raise NodeBoxError('Image "%s" not found.' % path)
        curtime = os.path.getmtime(path)
        try:
            image, lasttime = self._ctx._imagecache[path]
            if lasttime != curtime:
                image = None
        except KeyError:
            pass
        if image is None:
            image = NSImage.alloc().initWithContentsOfFile_(path)
            if image is None:
                raise NodeBoxError("Can't read image %r" % path)
            image.setFlipped_(True)
            image.setCacheMode_(NSImageCacheNever)
            self._ctx._imagecache[path] = (image, curtime)
        self._nsImage = image
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.alpha = alpha
    self.debugImage = False

</t>
<t tx="karstenw.20170704104751.149">def _get_image(self):
    w = "The 'image' attribute is deprecated. Please use _nsImage instead."
    warnings.warn(w, DeprecationWarning, stacklevel=2)
    return self._nsImage
image = property(_get_image)

</t>
<t tx="karstenw.20170704104751.15">def checkKwargs(self, kwargs):
    remaining = [arg for arg in kwargs.keys() if arg not in self.kwargs]
    if remaining:
        err = "Unknown argument(s) '%s'" % ", ".join(remaining)
        raise NodeBoxError(err)
checkKwargs = classmethod(checkKwargs)


</t>
<t tx="karstenw.20170704104751.150">def copy(self):
    new = self.__class__(self._ctx)
    _copy_attrs(self, new, ('image', 'x', 'y', 'width', 'height',
                            '_transform', '_transformmode', 'alpha', 'debugImage'))
    return new

</t>
<t tx="karstenw.20170704104751.151">def getSize(self):
    return self._nsImage.size()

size = property(getSize)

</t>
<t tx="karstenw.20170704104751.152">def _draw(self):
    """Draw an image on the given coordinates."""

    srcW, srcH = self._nsImage.size()
    srcRect = ((0, 0), (srcW, srcH))

    # Width or height given
    if self.width is not None or self.height is not None:
        if self.width is not None and self.height is not None:
            factor = min(self.width / srcW, self.height / srcH)
        elif self.width is not None:
            factor = self.width / srcW
        elif self.height is not None:
            factor = self.height / srcH
        _save()

        # Center-mode transforms: translate to image center
        if self._transformmode == CENTER:
            # This is the hardest case: center-mode transformations with given
            # width or height.
            # Order is very important in this code.

            # Set the position first, before any of the scaling or transformations
            # are done.
            # Context transformations might change the translation, and we don't
            # want that.
            t = Transform()
            t.translate(self.x, self.y)
            t.concat()

            # Set new width and height factors. Note that no scaling is done yet:
            # they're just here to set the new center of the image according to
            # the scaling factors.
            srcW = srcW * factor
            srcH = srcH * factor

            # Move image to newly calculated center.
            dX = srcW / 2
            dY = srcH / 2
            t = Transform()
            t.translate(dX, dY)
            t.concat()

            # Do current transformation.
            self._transform.concat()

            # Move back to the previous position.
            t = Transform()
            t.translate(-dX, -dY)
            t.concat()

            # Finally, scale the image according to the factors.
            t = Transform()
            t.scale(factor)
            t.concat()
        else:
            # Do current transformation
            self._transform.concat()
            # Scale according to width or height factor
            t = Transform()
            t.translate(self.x, self.y) # Here we add the positioning of the image.
            t.scale(factor)
            t.concat()

        # A debugImage draws a black rectangle instead of an image.
        if self.debugImage:
            Color(self._ctx).set()
            pt = BezierPath()
            pt.rect(0, 0, srcW / factor, srcH / factor)
            pt.fill()
        else:
            self._nsImage.drawAtPoint_fromRect_operation_fraction_((0, 0),
                                        srcRect, NSCompositeSourceOver, self.alpha)
        _restore()
    # No width or height given
    else:
        _save()
        x,y = self.x, self.y
        # Center-mode transforms: translate to image center
        if self._transformmode == CENTER:
            deltaX = srcW / 2
            deltaY = srcH / 2
            t = Transform()
            t.translate(x+deltaX, y+deltaY)
            t.concat()
            x = -deltaX
            y = -deltaY
        # Do current transformation
        self._transform.concat()
        # A debugImage draws a black rectangle instead of an image.
        if self.debugImage:
            Color(self._ctx).set()
            pt = BezierPath()
            pt.rect(x, y, srcW, srcH)
            pt.fill()
        else:
            # The following code avoids a nasty bug in Cocoa/PyObjC.
            # Apparently, EPS files are put on a different position when drawn
            # with a certain position.
            # However, this only happens when the alpha value is set to 1.0: set
            # it to something lower and the positioning is the same as a bitmap
            # file.
            # I could of course make every EPS image have an alpha value of
            # 0.9999, but this solution is better: always use zero coordinates for
            # drawAtPoint and use a transform to set the final position.
            t = Transform()
            t.translate(x,y)
            t.concat()
            self._nsImage.drawAtPoint_fromRect_operation_fraction_(
                            (0,0), srcRect, NSCompositeSourceOver, self.alpha)
        _restore()


</t>
<t tx="karstenw.20170704104751.153">class Text(Grob, TransformMixin, ColorMixin):

    stateAttributes = ('_transform', '_transformmode', '_fillcolor', '_fontname',
                       '_fontsize', '_align', '_lineheight')
    kwargs = ('fill', 'font', 'fontsize', 'align', 'lineheight')

    __dummy_color = NSColor.blackColor()
    
    @others
</t>
<t tx="karstenw.20170704104751.154">def __init__(self, ctx, text, x=0, y=0, width=None, height=None, **kwargs):
    super(Text, self).__init__(ctx)
    TransformMixin.__init__(self)
    ColorMixin.__init__(self, **kwargs)
    self.text = makeunicode(text)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self._fontname = kwargs.get('font', "Helvetica")
    self._fontsize = kwargs.get('fontsize', 24)
    self._lineheight = max(kwargs.get('lineheight', 1.2), 0.01)
    self._align = kwargs.get('align', NSLeftTextAlignment)

</t>
<t tx="karstenw.20170704104751.155">def copy(self):
    new = self.__class__(self._ctx, self.text)
    _copy_attrs(self, new,
        ('x', 'y', 'width', 'height', '_transform', '_transformmode', 
        '_fillcolor', '_fontname', '_fontsize', '_align', '_lineheight'))
    return new
    
</t>
<t tx="karstenw.20170704104751.156">def font_exists(cls, fontname):
    # Check if the font exists.
    f = NSFont.fontWithName_size_(fontname, 12)
    return f is not None
font_exists = classmethod(font_exists)

</t>
<t tx="karstenw.20170704104751.157">def _get_font(self):
    return NSFont.fontWithName_size_(self._fontname, self._fontsize)
font = property(_get_font)

</t>
<t tx="karstenw.20170704104751.158">def _getLayoutManagerTextContainerTextStorage(self, clr=__dummy_color):
    paraStyle = NSMutableParagraphStyle.alloc().init()
    paraStyle.setAlignment_(self._align)
    paraStyle.setLineBreakMode_(NSLineBreakByWordWrapping)
    paraStyle.setLineHeightMultiple_(self._lineheight)

    d = {
        NSParagraphStyleAttributeName:  paraStyle,
        NSForegroundColorAttributeName: clr,
        NSFontAttributeName:            self.font
    }

    t = makeunicode( self.text )
    textStorage = NSTextStorage.alloc().initWithString_attributes_(t, d)
    try:
        textStorage.setFont_(self.font)
    except ValueError:
        raise NodeBoxError("Text.draw(): font '%s' not available.\n" % self._fontname)
        return

    layoutManager = NSLayoutManager.alloc().init()
    textContainer = NSTextContainer.alloc().init()
    if self.width != None:
        textContainer.setContainerSize_((self.width,1000000))
        textContainer.setWidthTracksTextView_(False)
        textContainer.setHeightTracksTextView_(False)
    layoutManager.addTextContainer_(textContainer)
    textStorage.addLayoutManager_(layoutManager)
    return layoutManager, textContainer, textStorage

</t>
<t tx="karstenw.20170704104751.159">def _draw(self):
    if self._fillcolor is None:
        return

    s = self._getLayoutManagerTextContainerTextStorage(self._fillcolor.nsColor)
    layoutManager, textContainer, textStorage = s

    x,y = self.x, self.y
    glyphRange = layoutManager.glyphRangeForTextContainer_(textContainer)
    s = layoutManager.boundingRectForGlyphRange_inTextContainer_(glyphRange,
                                                                textContainer)
    (dx, dy), (w, h) = s
    preferredWidth, preferredHeight = textContainer.containerSize()
    if self.width is not None:
        if self._align == RIGHT:
            x += preferredWidth - w
        elif self._align == CENTER:
            x += preferredWidth/2 - w/2

    _save()
    # Center-mode transforms: translate to image center
    if self._transformmode == CENTER:
        deltaX = w / 2
        deltaY = h / 2
        t = Transform()
        t.translate(x+deltaX, y-self.font.defaultLineHeightForFont()+deltaY)
        t.concat()
        self._transform.concat()
        layoutManager.drawGlyphsForGlyphRange_atPoint_(glyphRange,
                                                       (-deltaX-dx,-deltaY-dy))
    else:
        self._transform.concat()
        layoutManager.drawGlyphsForGlyphRange_atPoint_(glyphRange,
                                (x-dx, y-dy-self.font.defaultLineHeightForFont()))
    _restore()
    return (w, h)

</t>
<t tx="karstenw.20170704104751.16">class TransformMixin(object):

    """Mixin class for transformation support.
    Adds the _transform and _transformmode attributes to the class."""
    
    @others
</t>
<t tx="karstenw.20170704104751.160">def _get_allmetrics(self):
    items = self._getLayoutManagerTextContainerTextStorage()
    layoutManager, textContainer, textStorage = items
    glyphRange = layoutManager.glyphRangeForTextContainer_(textContainer)
    (dx, dy), (w, h) = layoutManager.boundingRectForGlyphRange_inTextContainer_(
                                                        glyphRange, textContainer)
    # print "metrics (dx,dy):", (dx,dy)
    return dx,dy,w,h
allmetrics = property(_get_allmetrics)

</t>
<t tx="karstenw.20170704104751.161">def _get_metrics(self):
    dx,dy,w,h = self._get_allmetrics()
    return w,h
metrics = property(_get_metrics)

</t>
<t tx="karstenw.20170704104751.162">def _get_path(self):
    items = self._getLayoutManagerTextContainerTextStorage()
    layoutManager, textContainer, textStorage = items
    x, y = self.x, self.y
    glyphRange = layoutManager.glyphRangeForTextContainer_(textContainer)
    (dx, dy), (w, h) = layoutManager.boundingRectForGlyphRange_inTextContainer_(
                                                        glyphRange, textContainer)
    preferredWidth, preferredHeight = textContainer.containerSize()
    if self.width is not None:
       if self._align == RIGHT:
           x += preferredWidth - w
       elif self._align == CENTER:
           x += preferredWidth/2 - w/2
    length = layoutManager.numberOfGlyphs()
    path = NSBezierPath.bezierPath()
    for glyphIndex in range(length):
        lineFragmentRect = layoutManager.lineFragmentRectForGlyphAtIndex_effectiveRange_(
                                                                glyphIndex, None)
        # HACK: PyObjc 2.0 and 2.2 are subtly different:
        #  - 2.0 (bundled with OS X 10.5) returns one argument: the rectangle.
        #  - 2.2 (bundled with OS X 10.6) returns two arguments: the rectangle and the range.
        # So we check if we got one or two arguments back (in a tuple) and unpack them.
        if isinstance(lineFragmentRect, tuple):
            lineFragmentRect = lineFragmentRect[0]
        layoutPoint = layoutManager.locationForGlyphAtIndex_(glyphIndex)

        # Here layoutLocation is the location (in container coordinates)
        # where the glyph was laid out. 
        finalPoint = [lineFragmentRect[0][0],lineFragmentRect[0][1]]
        finalPoint[0] += layoutPoint[0] - dx
        finalPoint[1] += layoutPoint[1] - dy
        g = layoutManager.glyphAtIndex_(glyphIndex)
        if g == 0:
            continue
        path.moveToPoint_((finalPoint[0], -finalPoint[1]))
        path.appendBezierPathWithGlyph_inFont_(g, self.font)
        path.closePath()
    path = BezierPath(self._ctx, path)
    trans = Transform()
    trans.translate(x,y-self.font.defaultLineHeightForFont())
    trans.scale(1.0,-1.0)
    path = trans.transformBezierPath(path)
    path.inheritFromContext()
    return path
path = property(_get_path)


</t>
<t tx="karstenw.20170704104751.163">class Variable(object):
    @others
</t>
<t tx="karstenw.20170704104751.164">def __init__(self, name, typ,
                   default=None, minV=0, maxV=100, value=None,
                   handler=None, menuitems=None):
    self.name = makeunicode(name)
    self.type = typ or NUMBER
    self.default = default
    self.min = minV
    self.max = maxV

    self.handler = None
    if handler is not None:
        self.handler = handler

    self.menuitems = None
    if menuitems is not None:
        if type(menuitems) in (list, tuple):
            self.menuitems = [makeunicode(i) for i in menuitems]
    
    if self.type == NUMBER:
        if default is None:
            self.default = 50
        self.min = minV
        self.max = maxV

    elif self.type == TEXT:
        if default is None:
            self.default = makeunicode("hello")
        else:
            self.default = makeunicode(default)

    elif self.type == BOOLEAN:
        if default is None:
            self.default = True
        else:
            self.default = bool(default)

    elif self.type == BUTTON:
        self.default = makeunicode(self.name)

    elif self.type == MENU:
        # value is list of menuitems
        # default is name of function to call with selected menu item name

        # old interface
        if type(value) in (list, tuple): # and type(default) in (function,):
            # print "type(default)", type(default)
            if default is not None:
                self.handler = default
            self.menuitems = [makeunicode(i) for i in value]
            default = None
            value = ""
            

        if default is None:
            if self.menuitems is not None:
                if len(self.menuitems) &gt; 0:
                    default = self.menuitems[0]
            else:
                default = u""
        self.default = default
    self.value = value or self.default
    self.control = None


</t>
<t tx="karstenw.20170704104751.165">def sanitize(self, val):
    """Given a Variable and a value, cleans it out"""
    if self.type == NUMBER:
        try:
            return float(val)
        except ValueError:
            return 0.0
    elif self.type == TEXT:
        # return unicode(str(val), "utf_8", "replace")
        return makeunicode( val )
        try:
            # return unicode(str(val), "utf_8", "replace")
            return makeunicode( val )
        except:
            return ""
    elif self.type == BOOLEAN:
        v = makeunicode( val )
        if v.lower() in (u"true", u"1", u"yes"):
            return True
        else:
            return False

</t>
<t tx="karstenw.20170704104751.166">def compliesTo(self, v):
    """Return whether I am compatible with the given var:
         - Type should be the same
         - My value should be inside the given vars' min/max range.
    """
    if self.type == v.type:
        if self.type == NUMBER:
            if self.value &lt; self.min or self.value &gt; self.max:
                return False
        return True
    return False

</t>
<t tx="karstenw.20170704104751.167">def __repr__(self):
    s = ("Variable(name=%s, typ=%s, default=%s, min=%s, max=%s, value=%s, "
         "handler=%s, menuitems=%s)")
    return s % (self.name, self.type, self.default, self.min, self.max, self.value,
                repr(self.handler), repr(self.menuitems))


</t>
<t tx="karstenw.20170704104751.168">class _PDFRenderView(NSView):
    
    # This view was created to provide PDF data.
    # Strangely enough, the only way to get PDF data from Cocoa is by asking
    # dataWithPDFInsideRect_ from a NSView. So, we create one just to get to
    # the PDF data.

    @others
</t>
<t tx="karstenw.20170704104751.169">def initWithCanvas_(self, canvas):

    # for some unknown reason the following line stopped working
    # Solution: use objc.super -- see import
    super(_PDFRenderView, self).initWithFrame_( ((0, 0), (canvas.width, canvas.height)) )
    # for some unknown reason this is the solution for the preceding problem
    # self.initWithFrame_( ((0, 0), (canvas.width, canvas.height)) )
    # it is the only super in this file, having a NS* superclass

    self.canvas = canvas
    return self
    
</t>
<t tx="karstenw.20170704104751.17">def __init__(self):
    self._reset()
    
</t>
<t tx="karstenw.20170704104751.170">def drawRect_(self, rect):
    self.canvas.draw()
    
</t>
<t tx="karstenw.20170704104751.171">def isOpaque(self):
    return False

</t>
<t tx="karstenw.20170704104751.172">def isFlipped(self):
    return True


</t>
<t tx="karstenw.20170704104751.173">class Canvas(Grob):

    @others
</t>
<t tx="karstenw.20170704104751.174">def __init__(self, width=DEFAULT_WIDTH, height=DEFAULT_HEIGHT):
    self.width = width
    self.height = height
    self.speed = None
    self.mousedown = False
    self.clear()

</t>
<t tx="karstenw.20170704104751.175">def clear(self):
    self._grobs = self._container = []
    self._grobstack = [self._grobs]
    
</t>
<t tx="karstenw.20170704104751.176">def _get_size(self):
    return self.width, self.height
size = property(_get_size)

</t>
<t tx="karstenw.20170704104751.177">def append(self, el):
    self._container.append(el)
    
</t>
<t tx="karstenw.20170704104751.178">def __iter__(self):
    for grob in self._grobs:
        yield grob
        
</t>
<t tx="karstenw.20170704104751.179">def __len__(self):
    return len(self._grobs)
    
</t>
<t tx="karstenw.20170704104751.18">def _reset(self):
    self._transform = Transform()
    self._transformmode = CENTER
    
</t>
<t tx="karstenw.20170704104751.180">def __getitem__(self, index):
    return self._grobs[index]
    
</t>
<t tx="karstenw.20170704104751.181">def push(self, containerGrob):
    self._grobstack.insert(0, containerGrob)
    self._container.append(containerGrob)
    self._container = containerGrob
    
</t>
<t tx="karstenw.20170704104751.182">def pop(self):
    try:
        del self._grobstack[0]
        self._container = self._grobstack[0]
    except IndexError as e:
        raise NodeBoxError("pop: too many canvas pops!")

</t>
<t tx="karstenw.20170704104751.183">def draw(self):
    if self.background is not None:
        self.background.set()
        NSRectFillUsingOperation(((0,0), (self.width, self.height)),
                                 NSCompositeSourceOver)
    for grob in self._grobs:
        grob._draw()
        
</t>
<t tx="karstenw.20170704104751.184">def _get_nsImage(self):
    img = NSImage.alloc().initWithSize_((self.width, self.height))
    img.setFlipped_(True)
    img.lockFocus()
    self.draw()
    img.unlockFocus()
    return img
_nsImage = property(_get_nsImage)

</t>
<t tx="karstenw.20170704104751.185">def _getImageData(self, format):
    if format == 'pdf':
        view = _PDFRenderView.alloc().initWithCanvas_(self)
        return view.dataWithPDFInsideRect_(view.bounds())
    elif format == 'eps':
        view = _PDFRenderView.alloc().initWithCanvas_(self)
        return view.dataWithEPSInsideRect_(view.bounds())
    else:
        imgTypes = {"gif":  NSGIFFileType,
                    "jpg":  NSJPEGFileType,
                    "jpeg": NSJPEGFileType,
                    "png":  NSPNGFileType,
                    "tiff": NSTIFFFileType}
        if format not in imgTypes:
            e = "Filename should end in .pdf, .eps, .tiff, .gif, .jpg or .png"
            raise NodeBoxError(e)
        data = self._nsImage.TIFFRepresentation()
        if format != 'tiff':
            imgType = imgTypes[format]
            rep = NSBitmapImageRep.imageRepWithData_(data)
            return rep.representationUsingType_properties_(imgType, None)
        else:
            return data

</t>
<t tx="karstenw.20170704104751.186">def save(self, fname, format=None):
    if format is None:
        basename, ext = os.path.splitext(fname)
        format = ext[1:].lower() # Skip the dot
    data = self._getImageData(format)
    fname = NSString.stringByExpandingTildeInPath(fname)
    data.writeToFile_atomically_(fname, False)

</t>
<t tx="karstenw.20170704104751.187">def _test():
    import doctest, cocoa
    return doctest.testmod(cocoa)

</t>
<t tx="karstenw.20170704104751.19">def _get_transform(self):
    return self._transform

def _set_transform(self, transform):
    self._transform = Transform(transform)
transform = property(_get_transform, _set_transform)


</t>
<t tx="karstenw.20170704104751.2">def _save():
    NSGraphicsContext.currentContext().saveGraphicsState()


</t>
<t tx="karstenw.20170704104751.21">def _get_transformmode(self):
    return self._transformmode

def _set_transformmode(self, mode):
    self._transformmode = mode
transformmode = property(_get_transformmode, _set_transformmode)
    

</t>
<t tx="karstenw.20170704104751.24">def reset(self):
    self._transform = Transform()

</t>
<t tx="karstenw.20170704104751.25">def rotate(self, degrees=0, radians=0):
    self._transform.rotate(-degrees,-radians)

</t>
<t tx="karstenw.20170704104751.26">def translate(self, x=0, y=0):
    self._transform.translate(x,y)

</t>
<t tx="karstenw.20170704104751.27">def scale(self, x=1, y=None):
    self._transform.scale(x,y)

</t>
<t tx="karstenw.20170704104751.28">def skew(self, x=0, y=0):
    self._transform.skew(x,y)
    
</t>
<t tx="karstenw.20170704104751.29">class ColorMixin(object):
    
    """Mixin class for color support.
    Adds the _fillcolor, _strokecolor and _strokewidth attributes to the class."""

    @others
</t>
<t tx="karstenw.20170704104751.3">def _restore():
    NSGraphicsContext.currentContext().restoreGraphicsState()

</t>
<t tx="karstenw.20170704104751.30">def __init__(self, **kwargs):
    try:
        self._fillcolor = Color(self._ctx, kwargs['fill'])
    except KeyError:
        self._fillcolor = Color(self._ctx)
    try:
        self._strokecolor = Color(self._ctx, kwargs['stroke'])
    except KeyError:
        self._strokecolor = None
    self._strokewidth = kwargs.get('strokewidth', 1.0)
    
</t>
<t tx="karstenw.20170704104751.31">def _get_fill(self):
    return self._fillcolor

def _set_fill(self, *args):
    self._fillcolor = Color(self._ctx, *args)
fill = property(_get_fill, _set_fill)


</t>
<t tx="karstenw.20170704104751.33">def _get_stroke(self):
    return self._strokecolor

def _set_stroke(self, *args):
    self._strokecolor = Color(self._ctx, *args)
stroke = property(_get_stroke, _set_stroke)


</t>
<t tx="karstenw.20170704104751.35">def _get_strokewidth(self):
    return self._strokewidth

def _set_strokewidth(self, strokewidth):
    self._strokewidth = max(strokewidth, 0.0001)
strokewidth = property(_get_strokewidth, _set_strokewidth)


</t>
<t tx="karstenw.20170704104751.37">class BezierPath(Grob, TransformMixin, ColorMixin):
    """A BezierPath provides a wrapper around NSBezierPath."""
    
    stateAttributes = ('_fillcolor', '_strokecolor', '_strokewidth', '_capstyle',
                       '_joinstyle', '_transform', '_transformmode')
    kwargs = ('fill', 'stroke', 'strokewidth', 'capstyle', 'joinstyle')

    @others
</t>
<t tx="karstenw.20170704104751.38">def __init__(self, ctx, path=None, **kwargs):
    super(BezierPath, self).__init__(ctx)
    TransformMixin.__init__(self)
    ColorMixin.__init__(self, **kwargs)
    self.capstyle = kwargs.get('capstyle', BUTT)
    self.joinstyle = kwargs.get('joinstyle', MITER)
    self._segment_cache = None
    if path is None:
        self._nsBezierPath = NSBezierPath.bezierPath()
    elif isinstance(path, (list,tuple)):
        self._nsBezierPath = NSBezierPath.bezierPath()
        self.extend(path)
    elif isinstance(path, BezierPath):
        self._nsBezierPath = path._nsBezierPath.copy()
        _copy_attrs(path, self, self.stateAttributes)
    elif isinstance(path, NSBezierPath):
        self._nsBezierPath = path
    else:
        raise NodeBoxError("Don't know what to do with %s." % path)
        
</t>
<t tx="karstenw.20170704104751.39">def _get_path(self):
    s = "The 'path' attribute is deprecated. Please use _nsBezierPath instead."
    #warnings.warn(s, DeprecationWarning, stacklevel=2)
    return self._nsBezierPath
path = property(_get_path)

</t>
<t tx="karstenw.20170704104751.4">
class NodeBoxError(Exception):
    pass


</t>
<t tx="karstenw.20170704104751.40">def copy(self):
    return self.__class__(self._ctx, self)

</t>
<t tx="karstenw.20170704104751.41">def _get_capstyle(self):
    return self._capstyle

def _set_capstyle(self, style):
    if style not in (BUTT, ROUND, SQUARE):
        raise NodeBoxError('Line cap style should be BUTT, ROUND or SQUARE.')
    self._capstyle = style
capstyle = property(_get_capstyle, _set_capstyle)


</t>
<t tx="karstenw.20170704104751.43">def _get_joinstyle(self):
    return self._joinstyle

def _set_joinstyle(self, style):
    if style not in (MITER, ROUND, BEVEL):
        raise NodeBoxError('Line join style should be MITER, ROUND or BEVEL.')
    self._joinstyle = style
joinstyle = property(_get_joinstyle, _set_joinstyle)


</t>
<t tx="karstenw.20170704104751.45">def moveto(self, x, y):
    self._segment_cache = None
    self._nsBezierPath.moveToPoint_( (x, y) )

</t>
<t tx="karstenw.20170704104751.46">def lineto(self, x, y):
    self._segment_cache = None
    self._nsBezierPath.lineToPoint_( (x, y) )

</t>
<t tx="karstenw.20170704104751.47">def curveto(self, x1, y1, x2, y2, x3, y3):
    self._segment_cache = None
    self._nsBezierPath.curveToPoint_controlPoint1_controlPoint2_(
                                            (x3, y3), (x1, y1), (x2, y2) )

# relativeMoveToPoint_( NSPoint )
# relativeLineToPoint_( NSPoint )
# relativeCurveToPoint:(NSPoint)aPoint
#           controlPoint1:(NSPoint)controlPoint1
#           controlPoint2:(NSPoint)controlPoint2
# appendBezierPathWithOvalInRect_
# appendBezierPathWithArcFromPoint_(NSPoint)fromPoint
#                          toPoint_(NSPoint)toPoint
#                           radius_(CGFloat)radius
# appendBezierPathWithArcWithCenter:(NSPoint)center
#                            radius:(CGFloat)radius
#                        startAngle:(CGFloat)startAngle
#                          endAngle:(CGFloat)endAngle
# appendBezierPathWithArcWithCenter:(NSPoint)center
#                            radius:(CGFloat)radius
#                        startAngle:(CGFloat)startAngle
#                          endAngle:(CGFloat)endAngle
#                         clockwise:(BOOL)clockwise

</t>
<t tx="karstenw.20170704104751.48">def closepath(self):
    self._segment_cache = None
    self._nsBezierPath.closePath()
    
</t>
<t tx="karstenw.20170704104751.49">def setlinewidth(self, width):
    self.linewidth = width

</t>
<t tx="karstenw.20170704104751.5">class Point(object):

    @others
</t>
<t tx="karstenw.20170704104751.50">def _get_bounds(self):
    try:
        if self._nsBezierPath.isEmpty():
            return (0,0) , (0,0)
    except Exception as err:
        print()
        #pdb.set_trace()
        print(err)
        print()
    try:
        cgr = self._nsBezierPath.bounds()
        xy = cgr.origin
        wh = cgr.size
        result = (xy,wh)
        return result
    #try:
    #    return self._nsBezierPath.bounds()
    #except :
    #    # Path is empty -- no bounds
    #    return (0,0) , (0,0)
    except Exception as err:
        print()
        #pdb.set_trace()
        print("Bezierpath._get_bounds() FAILED")
        print(err)
        print()
    return (0,0) , (0,0)

bounds = property(_get_bounds)

</t>
<t tx="karstenw.20170704104751.51">def contains(self, x, y):
    return self._nsBezierPath.containsPoint_((x,y))

</t>
<t tx="karstenw.20170704104751.52">def rect(self, x, y, width, height):
    self._segment_cache = None
    self._nsBezierPath.appendBezierPathWithRect_( ((x, y),
                                                   (width, height)) )
    
</t>
<t tx="karstenw.20170704104751.53">def oval(self, x, y, width, height):
    self._segment_cache = None
    self._nsBezierPath.appendBezierPathWithOvalInRect_( ((x, y),
                                                         (width, height)) )
ellipse = oval

</t>
<t tx="karstenw.20170704104751.54">def arc(self, x, y, r, startAngle, endAngle):
    self._segment_cache = None
    self._nsBezierPath.appendBezierPathWithArcWithCenter_radius_startAngle_endAngle_(
                                    (x,y), r, startAngle, endAngle)
    
</t>
<t tx="karstenw.20170704104751.55">def line(self, x1, y1, x2, y2):
    self._segment_cache = None
    self._nsBezierPath.moveToPoint_( (x1, y1) )
    self._nsBezierPath.lineToPoint_( (x2, y2) )

</t>
<t tx="karstenw.20170704104751.56">def __getitem__(self, index):
    cmd, el = self._nsBezierPath.elementAtIndex_associatedPoints_(index)
    return PathElement(cmd, el)

</t>
<t tx="karstenw.20170704104751.57">def __iter__(self):
    for i in range(len(self)):
        yield self[i]

</t>
<t tx="karstenw.20170704104751.58">def __len__(self):
    return self._nsBezierPath.elementCount()

</t>
<t tx="karstenw.20170704104751.59">def extend(self, pathElements):
    self._segment_cache = None
    for el in pathElements:
        if isinstance(el, (list, tuple)):
            x, y = el
            if len(self) == 0:
                cmd = MOVETO
            else:
                cmd = LINETO
            self.append(PathElement(cmd, ((x, y),)))
        elif isinstance(el, PathElement):
            self.append(el)
        else:
            raise NodeBoxError("Don't know how to handle %s" % el)

</t>
<t tx="karstenw.20170704104751.6">def __init__(self, *args):
    if len(args) == 2:
        self.x, self.y = args
    elif len(args) == 1:
        self.x, self.y = args[0]
    elif len(args) == 0:
        self.x = self.y = 0.0
    else:
        raise NodeBoxError("Wrong initializer for Point object")

</t>
<t tx="karstenw.20170704104751.60">def append(self, el):
    self._segment_cache = None
    if el.cmd == MOVETO:
        self.moveto(el.x, el.y)
    elif el.cmd == LINETO:
        self.lineto(el.x, el.y)
    elif el.cmd == CURVETO:
        self.curveto(el.ctrl1.x, el.ctrl1.y, el.ctrl2.x, el.ctrl2.y, el.x, el.y)
    elif el.cmd == CLOSE:
        self.closepath()
        
</t>
<t tx="karstenw.20170704104751.61">def _get_contours(self):
    from . import bezier
    return bezier.contours(self)
contours = property(_get_contours)

</t>
<t tx="karstenw.20170704104751.62">def _get_transform(self):
    trans = self._transform.copy()
    if (self._transformmode == CENTER):
        try:
            (x, y), (w, h) = self.bounds
        except Exception as err:
            print()
            # pdb.set_trace()
            print(err)
            print
        deltax = x + w / 2
        deltay = y + h / 2
        t = Transform()
        t.translate(-deltax,-deltay)
        trans.prepend(t)
        t = Transform()
        t.translate(deltax,deltay)
        trans.append(t)
    return trans
transform = property(_get_transform)

</t>
<t tx="karstenw.20170704104751.63">def _draw(self):
    _save()
    self.transform.concat()
    if (self._fillcolor):
        self._fillcolor.set()
        self._nsBezierPath.fill()
    if (self._strokecolor):
        self._strokecolor.set()
        self._nsBezierPath.setLineWidth_(self._strokewidth)
        self._nsBezierPath.setLineCapStyle_(self._capstyle)
        self._nsBezierPath.setLineJoinStyle_(self._joinstyle)
        self._nsBezierPath.stroke()
    _restore()

</t>
<t tx="karstenw.20170704104751.64">def fit(self, x=None, y=None, width=None, height=None, stretch=False):

    """Fits this path to the specified bounds.
    
    All parameters are optional; if no parameters are specified,
    nothing will happen. Specifying a parameter will constrain its value:
    
    - x: The path will be positioned at the specified x value 
    - y: The path will be positioned at the specified y value 
    - width: The path will be of the specified width
    - height: The path will be of the specified height
    - stretch: If both width and height are defined, either stretch the path or
               keep the aspect ratio.
    """

    # (px, py), (pw, ph) = self.bounds
    try:
        (px, py), (pw, ph) = self.bounds
    except Exception as err:
        print()
        print("BezierPath.fit() FAILED.")
        # pdb.set_trace()
        print(err)
        print()

    t = Transform()
    if x is not None and y is None:
        t.translate(x, py)
    elif x is None and y is not None:
        t.translate(px, y)
    elif x is not None and y is not None:
        t.translate(x, y)
    else:
        t.translate(px, py)
    if width is not None and height is None:
        t.scale(width / pw)
    elif width is None and height is not None:
        t.scale(height / ph)
    elif width is not None and height is not None:
        if stretch:
            t.scale(width /pw, height / ph)
        else:
            t.scale(min(width /pw, height / ph))
    t.translate(-px, -py)
    self._nsBezierPath = t.transformBezierPath(self)._nsBezierPath

### Mathematics ###

</t>
<t tx="karstenw.20170704104751.65">def segmentlengths(self, relative=False, n=10):
    from . import bezier
    
    if relative:
        # Use the opportunity to store the segment cache.
        if self._segment_cache is None:
            self._segment_cache = bezier.segment_lengths(self,
                                                        relative=True, n=n)
        return self._segment_cache
    else:
        return bezier.segment_lengths(self, relative=False, n=n)

</t>
<t tx="karstenw.20170704104751.66">def _get_length(self, segmented=False, n=10):
    from . import bezier
    
    return bezier.length(self, segmented=segmented, n=n)
length = property(_get_length)
    
</t>
<t tx="karstenw.20170704104751.67">def point(self, t):
    from . import bezier
    
    return bezier.point(self, t)
    
</t>
<t tx="karstenw.20170704104751.68">def points(self, amount=100):
    from . import bezier
    
    if len(self) == 0:
        raise NodeBoxError("The given path is empty")

    # The delta value is divided by amount - 1, because we also want the
    # last point (t=1.0)
    # If I wouldn't use amount - 1, I fall one point short of the end.
    # E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0,
    # if amount = 2, I want point at t 0.0 and t 1.0
    
    amount = int( amount )
    try:
        delta = 1.0 / (amount-1)
    except ZeroDivisionError:
        delta = 1.0

    for i in range(amount):
        yield self.point( delta*i )
        
</t>
<t tx="karstenw.20170704104751.69">def addpoint(self, t):
    from . import bezier
    
    self._nsBezierPath = bezier.insert_point(self, t)._nsBezierPath
    self._segment_cache = None

</t>
<t tx="karstenw.20170704104751.7">def __repr__(self):
    return "Point(x=%.3f, y=%.3f)" % (self.x, self.y)
    
</t>
<t tx="karstenw.20170704104751.70">def intersects(self, other):
    return cPolymagic.intersects(self._nsBezierPath, other._nsBezierPath)
    
</t>
<t tx="karstenw.20170704104751.71">def union(self, other, flatness=0.6):
    return BezierPath(self._ctx, cPolymagic.union( self._nsBezierPath,
                                                  other._nsBezierPath,
                                                  flatness))

</t>
<t tx="karstenw.20170704104751.72">def intersect(self, other, flatness=0.6):
    return BezierPath(self._ctx,
                      cPolymagic.intersect( self._nsBezierPath,
                                           other._nsBezierPath,
                                           flatness))

</t>
<t tx="karstenw.20170704104751.73">def difference(self, other, flatness=0.6):
    return BezierPath(self._ctx,
                      cPolymagic.difference( self._nsBezierPath,
                                            other._nsBezierPath,
                                            flatness))

</t>
<t tx="karstenw.20170704104751.74">def xor(self, other, flatness=0.6):
    return BezierPath(self._ctx,
                      cPolymagic.xor( self._nsBezierPath,
                                     other._nsBezierPath,
                                     flatness))


</t>
<t tx="karstenw.20170704104751.75">class PathElement(object):

    @others
</t>
<t tx="karstenw.20170704104751.76">def __init__(self, cmd=None, pts=None):
    self.cmd = cmd
    if cmd == MOVETO:
        assert len(pts) == 1
        self.x, self.y = pts[0]
        self.ctrl1 = Point(pts[0])
        self.ctrl2 = Point(pts[0])
    elif cmd == LINETO:
        assert len(pts) == 1
        self.x, self.y = pts[0]
        self.ctrl1 = Point(pts[0])
        self.ctrl2 = Point(pts[0])
    elif cmd == CURVETO:
        assert len(pts) == 3
        self.ctrl1 = Point(pts[0])
        self.ctrl2 = Point(pts[1])
        self.x, self.y = pts[2]
    elif cmd == CLOSE:
        assert pts is None or len(pts) == 0
        self.x = self.y = 0.0
        self.ctrl1 = Point(0.0, 0.0)
        self.ctrl2 = Point(0.0, 0.0)
    else:
        self.x = self.y = 0.0
        self.ctrl1 = Point()
        self.ctrl2 = Point()

</t>
<t tx="karstenw.20170704104751.77">def __repr__(self):
    if self.cmd == MOVETO:
        return "PathElement(MOVETO, ((%.3f, %.3f),))" % (self.x, self.y)
    elif self.cmd == LINETO:
        return "PathElement(LINETO, ((%.3f, %.3f),))" % (self.x, self.y)
    elif self.cmd == CURVETO:
        s = "PathElement(CURVETO, ((%.3f, %.3f), (%.3f, %.3f), (%.3f, %.3f))"
        return s % (self.ctrl1.x, self.ctrl1.y,
                    self.ctrl2.x, self.ctrl2.y,
                    self.x, self.y)
    elif self.cmd == CLOSE:
        return "PathElement(CLOSE)"
        
</t>
<t tx="karstenw.20170704104751.78">def __eq__(self, other):
    if other is None:
        return False
    if self.cmd != other.cmd:
        return False
    return (    self.x == other.x and self.y == other.y
            and self.ctrl1 == other.ctrl1 and self.ctrl2 == other.ctrl2 )
    
</t>
<t tx="karstenw.20170704104751.79">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="karstenw.20170704104751.8">def __eq__(self, other):
    if other is None:
        return False
    return self.x == other.x and self.y == other.y
    
</t>
<t tx="karstenw.20170704104751.80">class ClippingPath(Grob):

    @others
</t>
<t tx="karstenw.20170704104751.81">def __init__(self, ctx, path):
    self._ctx = ctx
    self.path = path
    self._grobs = []
    
</t>
<t tx="karstenw.20170704104751.82">def append(self, grob):
    self._grobs.append(grob)
    
</t>
<t tx="karstenw.20170704104751.83">def _draw(self):
    _save()
    cp = self.path.transform.transformBezierPath(self.path)
    cp._nsBezierPath.addClip()
    for grob in self._grobs:
        grob._draw()
    _restore()


</t>
<t tx="karstenw.20170704104751.84">class Rect(BezierPath):

    @others
</t>
<t tx="karstenw.20170704104751.85">def __init__(self, ctx, x, y, width, height, **kwargs):
    warnings.warn("Rect is deprecated. Use BezierPath's rect method.",
                                        DeprecationWarning, stacklevel=2)
    r = (x,y), (width,height)
    super(Rect, self).__init__(ctx, NSBezierPath.bezierPathWithRect_(r),
                                    **kwargs)

</t>
<t tx="karstenw.20170704104751.86">def copy(self):
    raise NotImplementedError("Please don't use Rect anymore")


</t>
<t tx="karstenw.20170704104751.87">class Oval(BezierPath):

    @others
</t>
<t tx="karstenw.20170704104751.88">def __init__(self, ctx, x, y, width, height, **kwargs):
    warnings.warn("Oval is deprecated. Use BezierPath's oval method.",
                  DeprecationWarning, stacklevel=2)
    r = (x,y), (width,height)
    super(Oval, self).__init__(ctx, NSBezierPath.bezierPathWithOvalInRect_(r),
                                    **kwargs)

</t>
<t tx="karstenw.20170704104751.89">def copy(self):
    raise NotImplementedError("Please don't use Oval anymore")


</t>
<t tx="karstenw.20170704104751.9">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="karstenw.20170704104751.90">class Color(object):

    @others
color = Color


</t>
<t tx="karstenw.20170704104751.91">def __init__(self, ctx, *args):
    self._ctx = ctx
    params = len(args)

    # Decompose the arguments into tuples. 
    if params == 1 and isinstance(args[0], tuple):
        args = args[0]
        params = len(args)

    if params == 1 and args[0] is None:
        clr = NSColor.colorWithDeviceWhite_alpha_(0.0, 0.0)
    elif params == 1 and isinstance(args[0], Color):
        if self._ctx._outputmode == RGB:
            clr = args[0]._rgb
        else:
            clr = args[0]._cmyk
    elif params == 1 and isinstance(args[0], NSColor):
        clr = args[0]
    elif (    params == 1
          and isinstance(args[0], (pstr,punicode))
          and len(args[0]) in (3,4,5,6,7,8,9)):
        # hex param
        try:
            a = args[0]
            # kill hash char
            if a[0] == '#':
                a = a[1:]
            alpha = 1.0
            n = len(a)
            if n in (3,4):
                div = 15.0
                if n == 3:
                    r, g, b = a[:]
                else:
                    r, g, b, alpha = a[:]
            else:
                div = 255.0
                if n == 6:
                    r, g, b = a[:2], a[2:4], a[4:6]
                else:
                    r, g, b, alpha = a[:2], a[2:4], a[4:6], a[6:8]
            r = int(r, 16) / div
            g = int(g, 16) / div
            b = int(b, 16) / div
            if n in (4,8):
                alpha = int(alpha, 16) / div
            clr = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, b, alpha)
        except Exception as err:
            print("Color parsing error: %s" % err)
            clr = NSColor.colorWithDeviceWhite_alpha_(0, 1)

    elif params == 1: # Gray, no alpha
        args = self._normalizeList(args)
        g, = args
        clr = NSColor.colorWithDeviceWhite_alpha_(g, 1)
    elif params == 2: # Gray and alpha
        args = self._normalizeList(args)
        g, a = args
        clr = NSColor.colorWithDeviceWhite_alpha_(g, a)
    elif params == 3 and self._ctx._colormode == RGB: # RGB, no alpha
        args = self._normalizeList(args)
        r,g,b = args
        clr = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, b, 1)
    elif params == 3 and self._ctx._colormode == HSB: # HSB, no alpha
        args = self._normalizeList(args)
        h, s, b = args
        clr = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(h, s, b, 1)
    elif params == 4 and self._ctx._colormode == RGB: # RGB and alpha
        args = self._normalizeList(args)
        r,g,b, a = args
        clr = NSColor.colorWithDeviceRed_green_blue_alpha_(r, g, b, a)
    elif params == 4 and self._ctx._colormode == HSB: # HSB and alpha
        args = self._normalizeList(args)
        h, s, b, a = args
        clr = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(h, s, b, a)
    elif params == 4 and self._ctx._colormode == CMYK: # CMYK, no alpha
        args = self._normalizeList(args)
        c, m, y, k  = args
        clr = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(c, m, y, k, 1)
    elif params == 5 and self._ctx._colormode == CMYK: # CMYK and alpha
        args = self._normalizeList(args)
        c, m, y, k, a  = args
        clr = NSColor.colorWithDeviceCyan_magenta_yellow_black_alpha_(c, m, y, k, a)
    else:
        clr = NSColor.colorWithDeviceWhite_alpha_(0, 1)

    self._cmyk = clr.colorUsingColorSpaceName_(NSDeviceCMYKColorSpace)
    self._rgb = clr.colorUsingColorSpaceName_(NSDeviceRGBColorSpace)

</t>
<t tx="karstenw.20170704104751.92">def __repr__(self):
    return "%s(%.3f, %.3f, %.3f, %.3f)" % (self.__class__.__name__, self.red,
            self.green, self.blue, self.alpha)

</t>
<t tx="karstenw.20170704104751.93">def set(self):
    self.nsColor.set()

</t>
<t tx="karstenw.20170704104751.94">def _get_nsColor(self):
    if self._ctx._outputmode == RGB:
        return self._rgb
    else:
        return self._cmyk
nsColor = property(_get_nsColor)
    

</t>
<t tx="karstenw.20170704104751.95">def copy(self):
    new = self.__class__(self._ctx)
    new._rgb = self._rgb.copy()
    new._updateCmyk()
    return new

</t>
<t tx="karstenw.20170704104751.96">def _updateCmyk(self):
    self._cmyk = self._rgb.colorUsingColorSpaceName_(NSDeviceCMYKColorSpace)

</t>
<t tx="karstenw.20170704104751.97">def _updateRgb(self):
    self._rgb = self._cmyk.colorUsingColorSpaceName_(NSDeviceRGBColorSpace)

</t>
<t tx="karstenw.20170704104751.98">def _get_hue(self):
    return self._rgb.hueComponent()

</t>
<t tx="karstenw.20170704104751.99">def _set_hue(self, val):
    val = self._normalize(val)
    h, s, b, a = self._rgb.getHue_saturation_brightness_alpha_(None, None, None, None)
    self._rgb = NSColor.colorWithDeviceHue_saturation_brightness_alpha_(val, s, b, a)
    self._updateCmyk()
h = hue = property(_get_hue, _set_hue, doc="the hue of the color")

</t>
<t tx="karstenw.20170704104824.1"></t>
<t tx="karstenw.20170704104856.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104908.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104918.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104926.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104934.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104947.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704104953.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704105032.1">import sys
import os
import io
import traceback, linecache
import re
import time
import random
import signal
import atexit

import pprint
pp = pprint.pprint

# import pdb
kwdbg = True

# set to true to have stdio on the terminal for pdb
debugging = True

# if true print out some debug info on stdout
kwlog = True

import objc
objc.options.deprecation_warnings=1


import Foundation
import AppKit
NSObject = AppKit.NSObject

NSMutableDictionary = AppKit.NSMutableDictionary
NSArray = AppKit.NSArray
NSMutableArray = AppKit.NSMutableArray

NSColor = AppKit.NSColor
NSScriptCommand = AppKit.NSScriptCommand
NSApplication = AppKit.NSApplication
NSUserDefaults = AppKit.NSUserDefaults

NSDocument = AppKit.NSDocument
NSDocumentController = AppKit.NSDocumentController

NSNotificationCenter = AppKit.NSNotificationCenter

NSFontAttributeName = AppKit.NSFontAttributeName
NSScreen = AppKit.NSScreen
NSMenu = AppKit.NSMenu
NSCursor = AppKit.NSCursor
NSTimer = AppKit.NSTimer
NSForegroundColorAttributeName = AppKit.NSForegroundColorAttributeName

NSPasteboard = AppKit.NSPasteboard
NSPDFPboardType = AppKit.NSPDFPboardType
NSPostScriptPboardType = AppKit.NSPostScriptPboardType
NSTIFFPboardType = AppKit.NSTIFFPboardType

NSBundle = AppKit.NSBundle
NSSavePanel = AppKit.NSSavePanel
NSLog = AppKit.NSLog
NSApp = AppKit.NSApp
NSPrintOperation = AppKit.NSPrintOperation
NSWindow = AppKit.NSWindow
NSBorderlessWindowMask = AppKit.NSBorderlessWindowMask
NSBackingStoreBuffered = AppKit.NSBackingStoreBuffered
NSView = AppKit.NSView
NSGraphicsContext = AppKit.NSGraphicsContext
NSRectFill = AppKit.NSRectFill
NSAffineTransform = AppKit.NSAffineTransform
NSFocusRingTypeExterior = AppKit.NSFocusRingTypeExterior
NSResponder = AppKit.NSResponder

NSURL = AppKit.NSURL
NSWorkspace = AppKit.NSWorkspace
NSBezierPath = AppKit.NSBezierPath


import threading
Thread = threading.Thread

from . import ValueLadder
MAGICVAR = ValueLadder.MAGICVAR

from . import PyDETextView

from . import preferences
NodeBoxPreferencesController = preferences.NodeBoxPreferencesController
LibraryFolder = preferences.LibraryFolder

from . import util
errorAlert = util.errorAlert


# from nodebox import util
import nodebox.util
util = nodebox.util
makeunicode = nodebox.util.makeunicode

import nodebox.util.ottobot
genProgram = nodebox.util.ottobot.genProgram


#import nodebox.util.QTSupport
#QTSupport = nodebox.util.QTSupport

# from nodebox import graphics
import nodebox.graphics
graphics = nodebox.graphics

# AppleScript enumerator codes for PDF and Quicktime export
PDF = 0x70646678 # 'pdfx'
QUICKTIME = 0x71747878 # 'qt  '


black = NSColor.blackColor()
VERY_LIGHT_GRAY = black.blendedColorWithFraction_ofColor_(0.95,
                                                          NSColor.whiteColor())
DARKER_GRAY = black.blendedColorWithFraction_ofColor_(0.8,
                                                      NSColor.whiteColor())

# from nodebox.gui.mac.dashboard import *
# from nodebox.gui.mac.progressbar import ProgressBarController
from . import dashboard
DashboardController = dashboard.DashboardController

from . import progressbar
ProgressBarController = progressbar.ProgressBarController

</t>
<t tx="karstenw.20170704105032.10">def close(self):
    self.stopScript()
    try:
        if len(self.vars) &gt; 0:
            self.dashboardController.panel.close()
    except Wxception as err:
        if kwlog:
            print("ERROR window.close()")
            print( err )
    objc.super(NodeBoxDocument, self).close()

</t>
<t tx="karstenw.20170704105032.100">def acceptsFirstResponder(self):
    return True


</t>
<t tx="karstenw.20170704105032.101">class NodeBoxAppDelegate(NSObject):

    @others
</t>
<t tx="karstenw.20170704105032.102">def awakeFromNib(self):
    if kwlog:
        print("AppDelegate.awakeFromNib")
    self._prefsController = None
    
    userdefaults = NSMutableDictionary.dictionary()
    userdefaults.setObject_forKey_([], u'lastSessionURLs')
    
    defaults = NSUserDefaults.standardUserDefaults()
    
    if not 'lastSessionURLs' in defaults:
        defaults.setObject_forKey_([], u'lastSessionURLs')
        defaults.registerDefaults_( defaults )

    libpath = LibraryFolder()

</t>
<t tx="karstenw.20170704105032.103">@objc.IBAction
def showPreferencesPanel_(self, sender):
    if self._prefsController is None:
        self._prefsController = NodeBoxPreferencesController.alloc().init()
    self._prefsController.showWindow_(sender)

</t>
<t tx="karstenw.20170704105032.104">@objc.IBAction
def generateCode_(self, sender):
    """Generate a piece of NodeBox code using OttoBot"""
    # from nodebox.util.ottobot import genProgram
    controller = NSDocumentController.sharedDocumentController()
    doc = controller.newDocument_(sender)
    doc = controller.currentDocument()
    doc.textView.setString_(genProgram())
    doc.runScript()

</t>
<t tx="karstenw.20170704105032.105">@objc.IBAction
def showHelp_(self, sender):
    url = NSURL.URLWithString_("http://nodebox.net/code/index.php/Reference")
    NSWorkspace.sharedWorkspace().openURL_(url)

</t>
<t tx="karstenw.20170704105032.106">@objc.IBAction
def showSite_(self, sender):
    url = NSURL.URLWithString_("http://nodebox.net/")
    NSWorkspace.sharedWorkspace().openURL_(url)

</t>
<t tx="karstenw.20170704105032.107">@objc.IBAction
def showLibrary_(self, sender):
    libpath = LibraryFolder()
    url = NSURL.fileURLWithPath_( makeunicode(libpath.libDir) )
    NSWorkspace.sharedWorkspace().openURL_(url)

</t>
<t tx="karstenw.20170704105032.108">def applicationWillTerminate_(self, note):
    
    controller = NSDocumentController.sharedDocumentController()
    opendocuments = controller.documents()
    defaults = NSUserDefaults.standardUserDefaults()
    ns = NSMutableArray.arrayWithCapacity_( len(opendocuments) )
    #print("opendocuments:")
    #pp(opendocuments)
    for document in opendocuments:
        try:
            ns.addObject_( document.fileURL().absoluteString() )
        except Exception as err:
            print(err)
    defaults.setObject_forKey_( ns, u'lastSessionURLs')
    #pp(ns)
    atexit._run_exitfuncs()
</t>
<t tx="karstenw.20170704105032.11">def __del__(self):
    nc = NSNotificationCenter.defaultCenter()
    nc.removeObserver_name_object_(self, "PyDETextFontChanged", None)
    # text view has a couple of circular refs, it can let go of them now
    self.textView._cleanup()

</t>
<t tx="karstenw.20170704105032.12">def textFontChanged_(self, notification):
    font = PyDETextView.getBasicTextAttributes()[NSFontAttributeName]
    self.outputView.setFont_(font)

</t>
<t tx="karstenw.20170704105032.13">def readFromFile_ofType_(self, path, tp):
    # pdb.set_trace()
    if self.textView is None:
        # we're not yet fully loaded
        self.path = path
    else:
        # "revert"
        self.readFromUTF8_(path)
    return True

</t>
<t tx="karstenw.20170704105032.14">def writeToFile_ofType_(self, path, tp):
    # pdb.set_trace()
    f = io.open(path, "wb")
    text = self.textView.string()
    f.write( text.encode("utf8") )
    f.close()
    return True

</t>
<t tx="karstenw.20170704105032.15">def windowControllerDidLoadNib_(self, controller):
    # pdb.set_trace()
    if self.path:
        self.readFromUTF8_(self.path)
    font = PyDETextView.getBasicTextAttributes()[NSFontAttributeName]
    self.outputView.setFont_(font)
    self.textView.window().makeFirstResponder_(self.textView)
    self.windowControllers()[0].setWindowFrameAutosaveName_("NodeBoxDocumentWindow")

    # switch off automatic substitutions
    try:
        self.textView.setAutomaticQuoteSubstitutionEnabled_( False )
        self.textView.setAutomaticDashSubstitutionEnabled_( False )

        # This does not work well with syntax coloring
        #self.textView.setAutomaticLinkDetectionEnabled_( True )
        #self.textView.setDisplaysLinkToolTips_( True )

        self.outputView.setAutomaticQuoteSubstitutionEnabled_( False )
        self.outputView.setAutomaticDashSubstitutionEnabled_( False )
        #self.outputView.setAutomaticLinkDetectionEnabled_( True )
        #self.outputView.setDisplaysLinkToolTips_( True )
    except Exception as err:
        if kwlog:
            print("ERROR windowControllerDidLoadNib_()")
            print( err )


</t>
<t tx="karstenw.20170704105032.16">def readFromUTF8_(self, path):
    # pdb.set_trace()
    f = io.open(path, 'r', encoding="utf-8")
    s = f.read()
    f.close()
    text = makeunicode( s )
    f.close()
    self.textView.setString_(text)
    self.textView.usesTabs = "\t" in text
    
</t>
<t tx="karstenw.20170704105032.17">def cleanRun_newSeed_buildInterface_(self, fn, newSeed, buildInterface):
    # pdb.set_trace()
    self.animationSpinner.startAnimation_(None)

    # Prepare everything for running the script
    self.prepareRun()

    # Run the actual script
    success = self.fastRun_newSeed_(fn, newSeed)
    self.animationSpinner.stopAnimation_(None)

    if success and buildInterface:

        # Build the interface
        self.vars = self.namespace["_ctx"]._vars
        if len(self.vars) &gt; 0:
            self.buildInterface_(None)

    return success

</t>
<t tx="karstenw.20170704105032.18">def prepareRun(self):

    # Compile the script
    success, output = self.boxedRun_args_(self._compileScript, [])
    self.flushOutput_(output)
    if not success:
        return False

    # Initialize the namespace
    self._initNamespace()
    
    # Reset the pagenum
    self._pageNum = 1
    
    # Reset the frame
    self._frame = 1

    self.speed = self.canvas.speed = None

</t>
<t tx="karstenw.20170704105032.19">def fastRun_newSeed_(self, fn, newSeed=False):
    """This is the old signature. Dispatching to the new with args"""
    return self.fastRun_newSeed_args_( fn, newSeed, [])


</t>
<t tx="karstenw.20170704105032.2">class ExportCommand(NSScriptCommand):
    pass    

</t>
<t tx="karstenw.20170704105032.20">@objc.IBAction
def runFullscreen_(self, sender):
    if self.fullScreen is not None:
        return
    # self.clearMessageArea_( None )
    self.stopScript()
    self.currentView = FullscreenView.alloc().init()
    self.currentView.canvas = None
    fullRect = NSScreen.mainScreen().frame()
    self.fullScreen = FullscreenWindow.alloc().initWithRect_(fullRect)
    # self.fullScreen.oneShot = True
    self.fullScreen.setContentView_(self.currentView)
    self.fullScreen.makeKeyAndOrderFront_(self)
    self.fullScreen.makeFirstResponder_(self.currentView)
    NSMenu.setMenuBarVisible_(False)
    NSCursor.hide()
    self._runScript()

</t>
<t tx="karstenw.20170704105032.21">@objc.IBAction
def runScript_(self, sender):
    # self.clearMessageArea_( None )
    self.runScript()
    
</t>
<t tx="karstenw.20170704105032.22">def runScript(self, compile=True, newSeed=True):
    if self.fullScreen is not None:
        return
    self.currentView = self.graphicsView
    self._runScript(compile, newSeed)

</t>
<t tx="karstenw.20170704105032.23">def _runScript(self, compile=True, newSeed=True):
    # pdb.set_trace()
    if not self.cleanRun_newSeed_buildInterface_(self._execScript, True, True):
        pass

    # Check whether we are dealing with animation
    if self.canvas.speed is not None:
        if not "draw" in self.namespace:
            errorAlert("Not a proper NodeBox animation",
                "NodeBox animations should have at least a draw() method.")
            return

        # Check if animationTimer is already running
        if self.animationTimer is not None:
            self.stopScript()

        self.speed = self.canvas.speed

        # Run setup routine
        if "setup" in self.namespace:
            self.fastRun_newSeed_(self.namespace["setup"], False)
        window = self.currentView.window()
        window.makeFirstResponder_(self.currentView)

        # Start the timer
        timer = NSTimer.scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_
        self.animationTimer = timer(1.0 / self.speed,
                                    self,
                                    objc.selector(self.doFrame, signature=b"v@:@"),
                                    None,
                                    True)

        # Start the spinner
        self.animationSpinner.startAnimation_(None)

</t>
<t tx="karstenw.20170704105032.24">def runScriptFast(self):        
    if self.animationTimer is None:
        self.fastRun_newSeed_(self._execScript, False)
    else:
        # XXX: This can be sped up. We just run _execScript to get the
        # method with __MAGICVAR__ into the namespace, and execute
        # that, so it should only be called once for animations.
        self.fastRun_newSeed_(self._execScript, False)
        self.fastRun_newSeed_(self.namespace["draw"], False)

</t>
<t tx="karstenw.20170704105032.25">def doFrame(self):
    self.fastRun_newSeed_(self.namespace["draw"], True)
    self._frame += 1
    
</t>
<t tx="karstenw.20170704105032.26">def source(self):
    return self.textView.string()

</t>
<t tx="karstenw.20170704105032.27">def setSource_(self, source):
    self.textView.setString_(source)

</t>
<t tx="karstenw.20170704105032.28">@objc.IBAction
def stopScript_(self, sender=None):
    self.stopScript()
    
</t>
<t tx="karstenw.20170704105032.29">def stopScript(self):
    if "stop" in self.namespace:
        success, output = self.boxedRun_args_(self.namespace["stop"], [])
        self.flushOutput_(output)
    self.animationSpinner.stopAnimation_(None)

    if self.animationTimer is not None:
        self.animationTimer.invalidate()
        self.animationTimer = None

    if self.fullScreen is not None:
        self.currentView = self.graphicsView
        self.fullScreen.orderOut_(None)
        self.fullScreen = None
        
    NSMenu.setMenuBarVisible_(True)
    NSCursor.unhide()
    self.textView.hideValueLadder()
    window = self.textView.window()
    window.makeFirstResponder_(self.textView)

</t>
<t tx="karstenw.20170704105032.3">class OutputFile(object):

    @others

</t>
<t tx="karstenw.20170704105032.30">def _compileScript(self, source=None):
    if source is None:
        source = self.textView.string()

    # if this is activated, all unicode carrying scripts NEED a "encoding"
    # line
    # OTOH if this is on, NB accepts scripts with an encoding line.
    # currently an error
    # source = source.encode("utf-8")
    self._code = None
    self._code = compile(source + "\n\n",
                         self.scriptName.encode('ascii', 'ignore'),
                         "exec")

</t>
<t tx="karstenw.20170704105032.31">def _initNamespace(self):

    self.namespace.clear()
    # Add everything from the namespace
    for name in graphics.__all__:
        self.namespace[name] = getattr(graphics, name)
    for name in util.__all__:
        self.namespace[name] = getattr(util, name)

    # debug print all collected keywords
    if kwlog:
        #print "util.__all__:"
        #pp(util.__all__)
        #print "graphics.__all__:"
        #pp(graphics.__all__)
        # print("namespace.keys():")
        # pp(namespace.keys())
        pass

    # Add everything from the context object
    self.namespace["_ctx"] = self.context
    for attrName in dir(self.context):
        self.namespace[attrName] = getattr(self.context, attrName)
    # Add the document global
    self.namespace["__doc__"] = self.__doc__
    # Add the page number
    self.namespace["PAGENUM"] = self._pageNumber
    # Add the frame number
    self.namespace["FRAME"] = self._frame
    # Add the magic var
    self.namespace[MAGICVAR] = self.magicvar
    # XXX: will be empty after reset.
    #for var in self.vars:
    #    self.namespace[var.name] = var.value

</t>
<t tx="karstenw.20170704105032.32">def _execScript(self):
    exec(self._code, self.namespace)
    self.__doc__ = self.namespace.get("__doc__", self.__doc__)

</t>
<t tx="karstenw.20170704105032.33">def boxedRun_args_(self, method, args):
    """
    Runs the given method in a boxed environment.
    Boxed environments:
     - Have their current directory set to the directory of the file
     - Have their argument set to the filename
     - Have their outputs redirect to an output stream.
    Returns:
       A tuple containing:
         - A boolean indicating whether the run was successful
         - The OutputFile
    """

    # pdb.set_trace()

    self.scriptName = self.fileName()
    libpath = LibraryFolder()
    libDir = libpath.libDir

    if not self.scriptName:
        curDir = os.getenv("HOME")
        self.scriptName = "&lt;untitled&gt;"
    else:
        curDir = os.path.dirname(self.scriptName)

    save = sys.stdout, sys.stderr
    saveDir = os.getcwd()
    saveArgv = sys.argv
    sys.argv = [self.scriptName]
    if os.path.exists(libDir):
        sys.path.insert(0, libDir)
    os.chdir(curDir)
    sys.path.insert(0, curDir)
    output = []
    
    # for pdb debugging in terminal this needs to be switched off
    if not debugging:
        sys.stdout = OutputFile(output, False)
        sys.stderr = OutputFile(output, True)
    self._scriptDone = False
    try:
        if self.animationTimer is None:
            pass
            # Creating a thread is a heavy operation,
            # don't install it when animating, where speed is crucial
            #t = Thread(target=self._userCancelledMonitor,
            #           name="UserCancelledMonitor")
            #t.start()
        try:
            method(*args)
        except KeyboardInterrupt:
            self.stopScript()
        except:
            etype, value, tb = sys.exc_info()
            if tb.tb_next is not None:
                tb = tb.tb_next  # skip the frame doing the exec
            traceback.print_exception(etype, value, tb)
            etype = value = tb = None
            return False, output
    finally:
        self._scriptDone = True
        sys.stdout, sys.stderr = save
        os.chdir(saveDir)
        sys.path.remove(curDir)
        try:
            sys.path.remove(libDir)
        except ValueError:
            pass
        sys.argv = saveArgv
        #self.flushOutput_()
    return True, output

</t>
<t tx="karstenw.20170704105032.34"># UNUSED - Referenced in commented out Thread section of boxedRun_args_
# Should be removed since Carbon is not available anymore

# from Mac/Tools/IDE/PyEdit.py
def _userCancelledMonitor(self):
    from Carbon import Evt
    while not self._scriptDone:
        if Evt.CheckEventQueueForUserCancel():
            # Send a SIGINT signal to ourselves.
            # This gets delivered to the main thread,
            # cancelling the running script.
            os.kill(os.getpid(), signal.SIGINT)
            break
        time.sleep(0.25)

</t>
<t tx="karstenw.20170704105032.35">def flushOutput_(self, output):
    outAttrs = PyDETextView.getBasicTextAttributes()
    errAttrs = outAttrs.copy()
    # XXX err color from user defaults...
    errAttrs[NSForegroundColorAttributeName] = NSColor.redColor()

    outputView = self.outputView
    outputView.setSelectedRange_((outputView.textStorage().length(), 0))
    lastErr = None
    for isErr, data in output:
        if isErr != lastErr:
            attrs = [outAttrs, errAttrs][isErr]
            outputView.setTypingAttributes_(attrs)
            lastErr = isErr
        outputView.insertText_(data)
    # del self.output

</t>
<t tx="karstenw.20170704105032.36">@objc.IBAction
def copyImageAsPDF_(self, sender):
    pboard = NSPasteboard.generalPasteboard()
    # graphicsView implements the pboard delegate method to provide the data
    pboard.declareTypes_owner_( [NSPDFPboardType,
                                 NSPostScriptPboardType,
                                 NSTIFFPboardType],
                                self.graphicsView)

</t>
<t tx="karstenw.20170704105032.37">@objc.IBAction
def exportAsImage_(self, sender):
    exportPanel = NSSavePanel.savePanel()
    exportPanel.setRequiredFileType_("pdf")
    exportPanel.setNameFieldLabel_("Export To:")
    exportPanel.setPrompt_("Export")
    exportPanel.setCanSelectHiddenExtension_(True)
    if not NSBundle.loadNibNamed_owner_("ExportImageAccessory", self):
        NSLog("Error -- could not load ExportImageAccessory.")
    self.exportImagePageCount.setIntValue_(1)
    exportPanel.setAccessoryView_(self.exportImageAccessory)
    path = self.fileName()
    if path:
        dirName, fileName = os.path.split(path)
        fileName, ext = os.path.splitext(fileName)
        fileName += ".pdf"
    else:
        dirName, fileName = None, "Untitled.pdf"
    # If a file was already exported, use that folder as the default.
    if self.exportDir is not None:
        dirName = self.exportDir
    exportPanel.beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo_(
        dirName,
        fileName,
        NSApp().mainWindow(),
        self,
        "exportPanelDidEnd:returnCode:contextInfo:", 0)

</t>
<t tx="karstenw.20170704105032.38">def exportPanelDidEnd_returnCode_contextInfo_(self, panel, returnCode, context):
    if returnCode:
        fname = panel.filename()
        self.exportDir = os.path.split(fname)[0] # Save the directory we exported to.
        pages = self.exportImagePageCount.intValue()
        format = panel.requiredFileType()
        panel.close()
        self.doExportAsImage_fmt_pages_(fname, format, pages)
exportPanelDidEnd_returnCode_contextInfo_ = objc.selector( exportPanelDidEnd_returnCode_contextInfo_, signature=b"v@:@ii")
        
</t>
<t tx="karstenw.20170704105032.39">@objc.IBAction
def exportImageFormatChanged_(self, sender):
    image_formats = ('pdf', 'eps', 'png', 'tiff', 'jpg', 'gif')
    panel = sender.window()
    panel.setRequiredFileType_(image_formats[sender.indexOfSelectedItem()])

</t>
<t tx="karstenw.20170704105032.4">def __init__(self, data, isErr=False):
    self.data = data
    self.isErr = isErr

</t>
<t tx="karstenw.20170704105032.40">def doExportAsImage_fmt_pages_(self, fname, format, pages):
    basename, ext = os.path.splitext(fname)
    # When saving one page (the default), just save the current graphics
    # context. When generating multiple pages, we run the script again 
    # (so we don't use the current displayed view) for the first page,
    # and then for every next page.
    if pages == 1:
        if self.graphicsView.canvas is None:
            self.runScript()
        self.canvas.save(fname, format)
    elif pages &gt; 1:
        pb = ProgressBarController.alloc().init()
        pb.begin_maxval_("Generating %s images..." % pages, pages)
        try:
            if not self.cleanRun_newSeed_buildInterface_(self._execScript,
                                                                    True, True):
                return
            self._pageNumber = 1
            self._frame = 1

            # If the speed is set, we are dealing with animation
            if self.canvas.speed is None:
                for i in range(pages):
                    if i &gt; 0: # Run has already happened first time
                        self.fastRun_newSeed_(self._execScript, True)
                    counterAsString = "-%5d" % self._pageNumber
                    counterAsString = counterAsString.replace(' ', '0')
                    exportName = basename + counterAsString + ext

                    self.canvas.save(exportName, format)
                    self.graphicsView.setNeedsDisplay_(True)
                    self._pageNumber += 1
                    self._frame += 1
                    pb.inc()
            else:
                if "setup" in self.namespace:
                    self.fastRun_newSeed_(self.namespace["setup"], False)
                for i in range(pages):
                    self.fastRun_newSeed_(self.namespace["draw"], True)
                    # 1-based
                    counterAsString = "-%5d" % self._pageNumber
                    # 0-based
                    # counterAsString = "-%5d" % i 
                    counterAsString = counterAsString.replace(' ', '0')
                    exportName = basename + counterAsString + ext
                    self.canvas.save(exportName, format)
                    self.graphicsView.setNeedsDisplay_(True)
                    self._pageNumber += 1
                    self._frame += 1
                    pb.inc()
                if "stop" in self.namespace:
                    success, output = self.boxedRun_args_(self.namespace["stop"], [])
                    self.flushOutput_(output)
        except KeyboardInterrupt:
            pass
        pb.end()
        del pb
    self._pageNumber = 1
    self._frame = 1

</t>
<t tx="karstenw.20170704105032.41">@objc.IBAction
def exportAsMovie_(self, sender):
    exportPanel = NSSavePanel.savePanel()
    exportPanel.setRequiredFileType_("pdf")
    exportPanel.setNameFieldLabel_("Export To:")
    exportPanel.setPrompt_("Export")
    exportPanel.setCanSelectHiddenExtension_(True)
    exportPanel.setAllowedFileTypes_(["mov"])
    if not NSBundle.loadNibNamed_owner_("ExportMovieAccessory", self):
        NSLog("Error -- could not load ExportMovieAccessory.")
    self.exportMovieFrames.setIntValue_(150)
    self.exportMovieFps.setIntValue_(30)
    exportPanel.setAccessoryView_(self.exportMovieAccessory)
    path = self.fileName()
    if path:
        dirName, fileName = os.path.split(path)
        fileName, ext = os.path.splitext(fileName)
        fileName += ".mov"
    else:
        dirName, fileName = None, "Untitled.mov"
    # If a file was already exported, use that folder as the default.
    if self.exportDir is not None:
        dirName = self.exportDir
    exportPanel.beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo_(
        dirName,
        fileName,
        NSApp().mainWindow(),
        self,
        "qtPanelDidEnd:returnCode:contextInfo:", 0)
            
</t>
<t tx="karstenw.20170704105032.42">def qtPanelDidEnd_returnCode_contextInfo_(self, panel, returnCode, context):
    if returnCode:
        fname = panel.filename()
        self.exportDir = os.path.split(fname)[0] # Save the directory we exported to.
        frames = self.exportMovieFrames.intValue()
        fps = self.exportMovieFps.floatValue()
        panel.close()

        if frames &lt;= 0 or fps &lt;= 0: return
        self.doExportAsMovie_frames_fps_(fname, frames, fps)

qtPanelDidEnd_returnCode_contextInfo_ = objc.selector(qtPanelDidEnd_returnCode_contextInfo_,
                                                      signature=b"v@:@ii")

</t>
<t tx="karstenw.20170704105032.43">def doExportAsMovie_frames_fps_(self, fname, frames, fps):
    # Only load QTSupport when necessary. 
    # QTSupport loads QTKit, which wants to establish a connection to the window
    # server.
    # If we load QTSupport before something is on screen, the connection to the
    # window server cannot be established.

    try:
        os.unlink(fname)
    except:
        pass
    try:
        fp = io.open(fname, 'wb')
        fp.close()
    except:
        errorAlert("File Error", ("Could not create file '%s'. "
                                  "Perhaps it is locked or busy.") % fname)
        return

    movie = None

    pb = ProgressBarController.alloc().init()
    pb.begin_maxval_("Generating %s frames..." % frames, frames)
    try:
        if not self.cleanRun_newSeed_buildInterface_(self._execScript, True, True):
            return
        self._pageNumber = 1
        self._frame = 1

        movie = QTSupport.Movie(fname, fps)
        # If the speed is set, we are dealing with animation
        if self.canvas.speed is None:
            for i in range(frames):
                if i &gt; 0: # Run has already happened first time
                    self.fastRun_newSeed_(self._execScript, True)
                movie.add(self.canvas)
                self.graphicsView.setNeedsDisplay_(True)
                pb.inc()
                self._pageNumber += 1
                self._frame += 1
        else:
            if "setup" in self.namespace:
                self.fastRun_newSeed_(self.namespace["setup"], False)
            for i in range(frames):
                self.fastRun_newSeed_(self.namespace["draw"], True)
                movie.add(self.canvas)
                self.graphicsView.setNeedsDisplay_(True)
                pb.inc()
                self._pageNumber += 1
                self._frame += 1
            if "stop" in self.namespace:
                success, output = self.boxedRun_args_(self.namespace["stop"], [])
                self.flushOutput_(output)
    except KeyboardInterrupt:
        pass
    pb.end()
    del pb
    movie.save()
    self._pageNumber = 1
    self._frame = 1

</t>
<t tx="karstenw.20170704105032.44">@objc.IBAction
def printDocument_(self, sender):
    op = NSPrintOperation.printOperationWithView_printInfo_(self.graphicsView,
                                                            self.printInfo())
    op.runOperationModalForWindow_delegate_didRunSelector_contextInfo_(
        NSApp().mainWindow(), self, "printOperationDidRun:success:contextInfo:",
        0)

</t>
<t tx="karstenw.20170704105032.45">def printOperationDidRun_success_contextInfo_(self, op, success, info):
    if success:
        self.setPrintInfo_(op.printInfo())

printOperationDidRun_success_contextInfo_ = objc.selector(
                                        printOperationDidRun_success_contextInfo_,
                                        signature=b"v@:@ci")

</t>
<t tx="karstenw.20170704105032.46">@objc.IBAction
def buildInterface_(self, sender):
    # print( "NIB.buildInterface_() klicked. %s" % repr(sender) )
    self.dashboardController.buildInterface_(self.vars)

</t>
<t tx="karstenw.20170704105032.47">def validateMenuItem_(self, menuItem):
    if menuItem.action() in ("exportAsImage:", "exportAsMovie:"):
        return self.canvas is not None
    return True
    

</t>
<t tx="karstenw.20170704105032.48">@objc.IBAction
def zoomIn_(self, sender):
    if self.fullScreen is not None: return
    self.graphicsView.zoomIn_(sender)

</t>
<t tx="karstenw.20170704105032.49">@objc.IBAction
def zoomOut_(self, sender):
    if self.fullScreen is not None: return
    self.graphicsView.zoomOut_(sender)
    
</t>
<t tx="karstenw.20170704105032.5">def write(self, data):
    t = type( data )
    if t in (pstr, punicode):
        try:
            data = makeunicode( data )
            if not py3:
                data = data.encode( "utf-8" )
        except UnicodeDecodeError:
            data = "XXX " + repr(data)
    self.data.append( (self.isErr, data) )


</t>
<t tx="karstenw.20170704105032.50">@objc.IBAction
def zoomToTag_(self, sender):
    if self.fullScreen is not None: return
    self.graphicsView.zoomTo_(sender.tag() / 100.0)

</t>
<t tx="karstenw.20170704105032.51">@objc.IBAction
def zoomToFit_(self, sender):
    if self.fullScreen is not None: return
    self.graphicsView.zoomToFit_(sender)
    
</t>
<t tx="karstenw.20170704105032.52">class FullscreenWindow(NSWindow):
    @others
</t>
<t tx="karstenw.20170704105032.53">def initWithRect_(self, fullRect):
    objc.super(FullscreenWindow,
               self).initWithContentRect_styleMask_backing_defer_(
                                    fullRect,
                                    NSBorderlessWindowMask,
                                    NSBackingStoreBuffered,
                                    True)
    return self
    
</t>
<t tx="karstenw.20170704105032.54">def canBecomeKeyWindow(self):
    return True

</t>
<t tx="karstenw.20170704105032.55">class FullscreenView(NSView):
    
    @others
</t>
<t tx="karstenw.20170704105032.56">def init(self):
    objc.super(FullscreenView, self).init()
    self.mousedown = False
    self.keydown = False
    self.key = None
    self.keycode = None
    self.scrollwheel = False
    self.wheeldelta = 0.0
    return self
    
</t>
<t tx="karstenw.20170704105032.57">def setCanvas_(self, canvas):
    self.canvas = canvas
    self.setNeedsDisplay_(True)
    if not hasattr(self, "screenRect"):
        self.screenRect = NSScreen.mainScreen().frame()
        cw, ch = self.canvas.size
        sw, sh = self.screenRect[1]
        self.scalingFactor = calc_scaling_factor(cw, ch, sw, sh)
        nw, nh = cw * self.scalingFactor, ch * self.scalingFactor
        self.scaledSize = nw, nh
        self.dx = (sw - nw) / 2.0
        self.dy = (sh - nh) / 2.0

</t>
<t tx="karstenw.20170704105032.58">def drawRect_(self, rect):
    NSGraphicsContext.currentContext().saveGraphicsState()
    NSColor.blackColor().set()
    NSRectFill(rect)
    if self.canvas is not None:
        t = NSAffineTransform.transform()
        t.translateXBy_yBy_(self.dx, self.dy)
        t.scaleBy_(self.scalingFactor)
        t.concat()
        clip = NSBezierPath.bezierPathWithRect_(
                            ((0, 0), (self.canvas.width, self.canvas.height)) )
        clip.addClip()
        self.canvas.draw()
    NSGraphicsContext.currentContext().restoreGraphicsState()

</t>
<t tx="karstenw.20170704105032.59">def isFlipped(self):
    return True

</t>
<t tx="karstenw.20170704105032.6">class NodeBoxDocument(NSDocument):
    # class defined in NodeBoxDocument.xib

    graphicsView = objc.IBOutlet()
    outputView = objc.IBOutlet() 
    textView = objc.IBOutlet()
    window = objc.IBOutlet()
    variablesController = objc.IBOutlet()
    dashboardController = objc.IBOutlet()
    animationSpinner = objc.IBOutlet()

    # The ExportImageAccessory adds:
    exportImageAccessory = objc.IBOutlet()
    exportImageFormat = objc.IBOutlet()
    exportImagePageCount = objc.IBOutlet()

    # The ExportMovieAccessory adds:
    exportMovieAccessory = objc.IBOutlet()
    exportMovieFrames = objc.IBOutlet()
    exportMovieFps = objc.IBOutlet()

    # When the PageCount accessory is loaded, we also add:
    pageCount = objc.IBOutlet()
    pageCountAccessory = objc.IBOutlet()

    # When the ExportSheet is loaded, we also add:
    exportSheet = objc.IBOutlet()
    exportSheetIndicator = objc.IBOutlet()

    path = None
    exportDir = None
    magicvar = None # Used for value ladders.
    _code = None
    vars = []
    movie = None

    @others

</t>
<t tx="karstenw.20170704105032.60">def mouseDown_(self, event):
    self.mousedown = True

</t>
<t tx="karstenw.20170704105032.61">def mouseUp_(self, event):
    self.mousedown = False

</t>
<t tx="karstenw.20170704105032.62">def keyDown_(self, event):
    self.keydown = True
    self.key = event.characters()
    self.keycode = event.keyCode()

</t>
<t tx="karstenw.20170704105032.63">def keyUp_(self, event):
    self.keydown = False
    self.key = event.characters()
    self.keycode = event.keyCode()

</t>
<t tx="karstenw.20170704105032.64">def scrollWheel_(self, event):
    self.scrollwheel = True
    self.wheeldelta = event.deltaY()

</t>
<t tx="karstenw.20170704105032.65">def canBecomeKeyView(self):
    return True

</t>
<t tx="karstenw.20170704105032.66">def acceptsFirstResponder(self):
    return True

</t>
<t tx="karstenw.20170704105032.67">def calc_scaling_factor(width, height, maxwidth, maxheight):
    return min(float(maxwidth) / width, float(maxheight) / height)
        
</t>
<t tx="karstenw.20170704105032.68">class ZoomPanel(NSView):
    pass

# class defined in NodeBoxGraphicsView.xib
</t>
<t tx="karstenw.20170704105032.69">class NodeBoxGraphicsView(NSView):
    document = objc.IBOutlet()
    zoomLevel = objc.IBOutlet()
    zoomField = objc.IBOutlet()
    zoomSlider = objc.IBOutlet()
    
    # The zoom levels are 10%, 25%, 50%, 75%, 100%, 200% and so on up to 2000%.
    zoomLevels = [0.1, 0.25, 0.5, 0.75]
    zoom = 1.0
    while zoom &lt;= 20.0:
        zoomLevels.append(zoom)
        zoom += 1.0
        
    @others
</t>
<t tx="karstenw.20170704105032.7">def windowNibName(self):
    return "NodeBoxDocument"

</t>
<t tx="karstenw.20170704105032.70">def awakeFromNib(self):
    self.canvas = None
    self._dirty = False
    self.mousedown = False
    self.keydown = False
    self.key = None
    self.keycode = None
    self.scrollwheel = False
    self.wheeldelta = 0.0
    self._zoom = 1.0
    self.setFrameSize_( (graphics.DEFAULT_WIDTH, graphics.DEFAULT_HEIGHT) )
    self.setFocusRingType_(NSFocusRingTypeExterior)
    if self.superview() is not None:
        self.superview().setBackgroundColor_(VERY_LIGHT_GRAY)

</t>
<t tx="karstenw.20170704105032.71">def setCanvas_(self, canvas):
    self.canvas = canvas
    if canvas is not None:
        w, h = self.canvas.size
        self.setFrameSize_([w*self._zoom, h*self._zoom])
    self.markDirty()

</t>
<t tx="karstenw.20170704105032.72">def getZoom(self):
    return self._zoom

</t>
<t tx="karstenw.20170704105032.73">def setZoom_(self, zoom):
    self._zoom = zoom
    self.zoomLevel.setTitle_("%i%%" % (self._zoom * 100.0))
    self.zoomSlider.setFloatValue_(self._zoom * 100.0)
    self.setCanvas_(self.canvas)
zoom = property(getZoom, setZoom_)
    
</t>
<t tx="karstenw.20170704105032.74">@objc.IBAction
def dragZoom_(self, sender):
    self.zoom = self.zoomSlider.floatValue() / 100.0
    self.setCanvas_(self.canvas)
    
</t>
<t tx="karstenw.20170704105032.75">def findNearestZoomIndex_(self, zoom):
    """Returns the nearest zoom level, and whether we found a direct, exact
    match or a fuzzy match."""
    try: # Search for a direct hit first.
        idx = self.zoomLevels.index(zoom)
        return idx, True
    except ValueError: # Can't find the zoom level, try looking at the indexes.
        idx = 0
        try:
            while self.zoomLevels[idx] &lt; zoom:
                idx += 1
        except KeyError: # End of the list
            idx = len(self.zoomLevels) - 1 # Just return the last index.
        return idx, False
    
</t>
<t tx="karstenw.20170704105032.76">@objc.IBAction
def zoomIn_(self, sender):
    idx, direct = self.findNearestZoomIndex_(self.zoom)
    # Direct hits are perfect, but indirect hits require a bit of help.
    # Because of the way indirect hits are calculated, they are already 
    # rounded up to the upper zoom level; this means we don't need to add 1.
    if direct:
        idx += 1
    idx = max(min(idx, len(self.zoomLevels)-1), 0)
    self.zoom = self.zoomLevels[idx]

</t>
<t tx="karstenw.20170704105032.77">@objc.IBAction
def zoomOut_(self, sender):
    idx, direct = self.findNearestZoomIndex_(self.zoom)
    idx -= 1
    idx = max(min(idx, len(self.zoomLevels)-1), 0)
    self.zoom = self.zoomLevels[idx]
    
</t>
<t tx="karstenw.20170704105032.78">@objc.IBAction
def resetZoom_(self, sender):
    self.zoom = 1.0
    
</t>
<t tx="karstenw.20170704105032.79">def zoomTo_(self, zoom):
    self.zoom = zoom
    
</t>
<t tx="karstenw.20170704105032.8">def init(self):
    # pdb.set_trace()
    self = objc.super(NodeBoxDocument, self).init()
    nc = NSNotificationCenter.defaultCenter()
    nc.addObserver_selector_name_object_(self,
                                         "textFontChanged:",
                                         "PyDETextFontChanged",
                                         None)
    self.namespace = {}
    self.canvas = graphics.Canvas()
    self.context = graphics.Context(self.canvas, self.namespace)
    self.animationTimer = None
    self.__doc__ = {}
    self._pageNumber = 1
    self._frame = 150
    self.fullScreen = None
    self._seed = time.time()

    # this is None
    self.currentView = self.graphicsView
    return self

</t>
<t tx="karstenw.20170704105032.80">@objc.IBAction
def zoomToFit_(self, sender):
    w, h = self.canvas.size
    fw, fh = self.superview().frame()[1]
    factor = min(fw / w, fh / h)
    self.zoom = factor

</t>
<t tx="karstenw.20170704105032.81">def markDirty(self, redraw=True):
    self._dirty = True
    if redraw:
        self.setNeedsDisplay_(True)

</t>
<t tx="karstenw.20170704105032.82">def setFrameSize_(self, size):
    self._image = None
    NSView.setFrameSize_(self, size)

</t>
<t tx="karstenw.20170704105032.83">def isOpaque(self):
    return False

</t>
<t tx="karstenw.20170704105032.84">def isFlipped(self):
    return True
    
</t>
<t tx="karstenw.20170704105032.85">def drawRect_(self, rect):
    if self.canvas is not None:
        NSGraphicsContext.currentContext().saveGraphicsState()
        try:
            if self.zoom != 1.0:
                t = NSAffineTransform.transform()
                t.scaleBy_(self.zoom)
                t.concat()
                clip = NSBezierPath.bezierPathWithRect_( ( (0, 0),
                                                           (self.canvas.width,
                                                            self.canvas.height)) )
                clip.addClip()
            self.canvas.draw()
        except:
            # A lot of code just to display the error in the output view.
            etype, value, tb = sys.exc_info()
            if tb.tb_next is not None:
                tb = tb.tb_next  # skip the frame doing the exec
            traceback.print_exception(etype, value, tb)
            data = "".join(traceback.format_exception(etype, value, tb))
            attrs = PyDETextView.getBasicTextAttributes()
            attrs[NSForegroundColorAttributeName] = NSColor.redColor()
            outputView = self.document.outputView
            outputView.setSelectedRange_((outputView.textStorage().length(), 0))
            outputView.setTypingAttributes_(attrs)
            outputView.insertText_(data)
        NSGraphicsContext.currentContext().restoreGraphicsState()

</t>
<t tx="karstenw.20170704105032.86">def _updateImage(self):
    if self._dirty:
        self._image = self.canvas._nsImage
        self._dirty = False

# pasteboard delegate method
</t>
<t tx="karstenw.20170704105032.87">def pasteboard_provideDataForType_(self, pboard, type):
    if NSPDFPboardType:
        pboard.setData_forType_(self.pdfData, NSPDFPboardType)
    elif NSPostScriptPboardType:
        pboard.setData_forType_(self.epsData, NSPostScriptPboardType)
    elif NSTIFFPboardType:
        pboard.setData_forType_(self.tiffData, NSTIFFPboardType)
        
</t>
<t tx="karstenw.20170704105032.88">def _get_pdfData(self):
    if self.canvas:
        return self.canvas._getImageData('pdf')
pdfData = property(_get_pdfData)

</t>
<t tx="karstenw.20170704105032.89">def _get_epsData(self):
    if self.canvas:
        return self.canvas._getImageData('eps')
epsData = property(_get_epsData)

</t>
<t tx="karstenw.20170704105032.9">def autosavesInPlace(self):
    return True

</t>
<t tx="karstenw.20170704105032.90">def _get_tiffData(self):
    return self.canvas._getImageData('tiff')
tiffData = property(_get_tiffData)
 
</t>
<t tx="karstenw.20170704105032.91">def _get_pngData(self):
    return self.canvas._getImageData('png')
pngData = property(_get_pngData)

</t>
<t tx="karstenw.20170704105032.92">def _get_gifData(self):
    return self.canvas._getImageData('gif')
gifData = property(_get_gifData)

</t>
<t tx="karstenw.20170704105032.93">def _get_jpegData(self):
    return self.canvas._getImageData('jpeg')
jpegData = property(_get_jpegData)

</t>
<t tx="karstenw.20170704105032.94">def mouseDown_(self, event):
    self.mousedown = True
    
</t>
<t tx="karstenw.20170704105032.95">def mouseUp_(self, event):
    self.mousedown = False
    
</t>
<t tx="karstenw.20170704105032.96">def keyDown_(self, event):
    self.keydown = True
    self.key = event.characters()
    self.keycode = event.keyCode()
    
</t>
<t tx="karstenw.20170704105032.97">def keyUp_(self, event):
    self.keydown = False
    self.key = event.characters()
    self.keycode = event.keyCode()
    
</t>
<t tx="karstenw.20170704105032.98">def scrollWheel_(self, event):
    NSResponder.scrollWheel_(self, event)
    self.scrollwheel = True
    self.wheeldelta = event.deltaY()

</t>
<t tx="karstenw.20170704105032.99">def canBecomeKeyView(self):
    return True

</t>
<t tx="karstenw.20170704105043.1">import sys, os, pdb

import objc

import Foundation

import AppKit
NSApp = AppKit.NSApplication

</t>
<t tx="karstenw.20170704105043.2"># class defined in AskString.xib
class AskStringWindowController(AppKit.NSWindowController):
    questionLabel = objc.IBOutlet()
    textField = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20170704105043.3">def setup_cb_default_parent_( self, question, resultCallback, default, parentWindow):
    self.question = question
    self.resultCallback = resultCallback
    self.default = default
    self.parentWindow = parentWindow
    self.window().setFrameUsingName_( u"AskStringPanel" )
    self.setWindowFrameAutosaveName_( u"AskStringPanel" )
    self.showWindow_( self.window() )

</t>
<t tx="karstenw.20170704105043.4">def windowWillClose_(self, notification):
    self.autorelease()
    return objc.super(AskStringWindowController, self).windowWillClose_(
                                                self, notification)

</t>
<t tx="karstenw.20170704105043.5">def awakeFromNib(self):
    self.questionLabel.setStringValue_( self.question )
    self.textField.setStringValue_( self.default )
    return objc.super(AskStringWindowController, self).awakeFromNib()

</t>
<t tx="karstenw.20170704105043.6">def done(self):
    if self.parentWindow is None:
        self.close()
    else:
        sheet = self.window()
        # NSApp().endSheet_(sheet)
        sheet.endSheet_(self)
        sheet.orderOut_(self)

</t>
<t tx="karstenw.20170704105043.7">@objc.IBAction
def ok_(self, sender):
    value = self.textField.stringValue()
    self.done()
    self.resultCallback(value)

</t>
<t tx="karstenw.20170704105043.8">@objc.IBAction
def cancel_(self, sender):
    self.done()
    self.resultCallback(None)


</t>
<t tx="karstenw.20170704105051.1">

from __future__ import print_function

import pdb
kwdbg = False


import AppKit

NSObject = AppKit.NSObject
NSFont = AppKit.NSFont
NSMiniControlSize = AppKit.NSMiniControlSize
NSOnState = AppKit.NSOnState
NSOffState = AppKit.NSOffState
NSTextField = AppKit.NSTextField
NSRightTextAlignment = AppKit.NSRightTextAlignment
NSSlider = AppKit.NSSlider
NSMiniControlSize = AppKit.NSMiniControlSize
NSGraphiteControlTint = AppKit.NSGraphiteControlTint
NSButton = AppKit.NSButton
NSSwitchButton = AppKit.NSSwitchButton
NSSmallControlSize = AppKit.NSSmallControlSize
NSPopUpButton = AppKit.NSPopUpButton


import objc

from nodebox import graphics

# just to make the next lines print better
smfontsize = NSFont.smallSystemFontSize()
smctrlsize = NSFont.systemFontSizeForControlSize_(NSMiniControlSize)

SMALL_FONT = NSFont.systemFontOfSize_(smfontsize)
MINI_FONT = NSFont.systemFontOfSize_(smctrlsize)

</t>
<t tx="karstenw.20170704105051.10">def addSlider_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    control = NSSlider.alloc().init()
    control.setMaxValue_(v.max)
    control.setMinValue_(v.min)
    control.setFloatValue_(v.value)
    control.setFrame_( frame ) #((108,y-1),(172,16)))
    control.cell().setControlSize_(NSMiniControlSize)
    control.cell().setControlTint_(NSGraphiteControlTint)
    control.setContinuous_(True)
    control.setTarget_(self)
    control.setTag_(cnt)
    control.setAction_(objc.selector(self.numberChanged_, signature=b"v@:@@"))
    control.setAutoresizingMask_( AppKit.NSViewWidthSizable ) #+ AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control

</t>
<t tx="karstenw.20170704105051.11">def addTextField_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    control = NSTextField.alloc().init()
    control.setStringValue_(v.value)
    control.setFrame_( frame ) #((108,y-2),(172,16)))
    control.cell().setControlSize_(NSMiniControlSize)
    control.cell().setControlTint_(NSGraphiteControlTint)
    control.setFont_(MINI_FONT)
    control.setTarget_(self)
    control.setTag_(cnt)
    control.setAction_(objc.selector(self.textChanged_, signature=b"v@:@@"))
    control.setAutoresizingMask_( AppKit.NSViewWidthSizable ) #+ AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control

</t>
<t tx="karstenw.20170704105051.12">def addSwitch_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    control = NSButton.alloc().init()
    control.setButtonType_(NSSwitchButton)
    if v.value:
        control.setState_(NSOnState)
    else:
        control.setState_(NSOffState)
    control.setFrame_( frame ) #((108,y-2),(172,16)))
    control.setTitle_(v.name)
    control.setFont_(SMALL_FONT)
    control.cell().setControlSize_(NSSmallControlSize)
    control.cell().setControlTint_(NSGraphiteControlTint)
    control.setTarget_(self)
    control.setTag_(cnt)
    control.setAction_(objc.selector(self.booleanChanged_, signature=b"v@:@@"))
    control.setAutoresizingMask_( AppKit.NSViewWidthSizable ) # + AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control
    
</t>
<t tx="karstenw.20170704105051.13">def addButton_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    control = NSButton.alloc().init()
    control.setFrame_( frame ) #((108, y-2),(172,16)))
    control.setTitle_(v.name)
    control.setBezelStyle_(1)
    control.setFont_(SMALL_FONT)
    control.cell().setControlSize_(NSMiniControlSize)
    control.cell().setControlTint_(NSGraphiteControlTint)
    control.setTarget_(self)
    control.setTag_(cnt)
    control.setAction_(objc.selector(self.buttonClicked_, signature=b"v@:@@"))
    control.setAutoresizingMask_( AppKit.NSViewWidthSizable ) # + AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control

</t>
<t tx="karstenw.20170704105051.2"># class defined in NodeBoxDocument.xib
class DashboardController(NSObject):
    document = objc.IBOutlet()
    documentWindow = objc.IBOutlet()
    panel = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20170704105051.3">def clearInterface(self):
    for s in list(self.panel.contentView().subviews()):
        s.removeFromSuperview()

</t>
<t tx="karstenw.20170704105051.4">def numberChanged_(self, sender):
    var = self.document.vars[sender.tag()]
    var.value = sender.floatValue()
    if var.handler is not None:
        args = [var.value,var.name]
        argcount = getFunctionArgCount( var.handler )
        if argcount &lt; 2:
            args = [var.value]
        self.document.fastRun_newSeed_args_(var.handler, False, args)
    else:
        self.document.runScript(compile=False, newSeed=False)

</t>
<t tx="karstenw.20170704105051.5">def textChanged_(self, sender):
    var = self.document.vars[sender.tag()]
    var.value = sender.stringValue()
    if var.handler is not None:
        args = [var.value,var.name]
        argcount = getFunctionArgCount( var.handler )
        if argcount &lt; 2:
            args = [var.value]
        self.document.fastRun_newSeed_args_(var.handler, False, args)
    else:
        self.document.runScript(compile=False, newSeed=False)

</t>
<t tx="karstenw.20170704105051.6">def booleanChanged_(self, sender):
    var = self.document.vars[sender.tag()]
    if sender.state() == NSOnState:
        var.value = True
    else:
        var.value = False
    if var.handler is not None:
        args = [var.value,var.name]
        argcount = getFunctionArgCount( var.handler )
        if argcount &lt; 2:
            args = [var.value]
        self.document.fastRun_newSeed_args_(var.handler, False, args)
    else:
        self.document.runScript(compile=False, newSeed=False)

</t>
<t tx="karstenw.20170704105051.7">def buttonClicked_(self, sender):
    var = self.document.vars[sender.tag()]
    # self.document.fastRun_newSeed_(self.document.namespace[var.name], True)
    #self.document.runFunction_(var.name)
    if var.handler is not None:
        args = ["",var.name]
        argcount = getFunctionArgCount( var.handler )
        if argcount &lt; 2:
            args = [var.value]
        self.document.fastRun_newSeed_args_(var.handler, False, args)
    else:
        self.document.runScript(compile=False, newSeed=False)

</t>
<t tx="karstenw.20170704105051.8">def buildInterface_(self, variables):
    panelwidth = 300

    label_x = 0
    label_w = 100
    ctrl_x = 108
    ctrl_w = 172
    ctrlheight = 26 # 21
    ctrltop = 5
    ctrlheader = 11
    ctrlfooter = 38
    ctrlheaderfooter = ctrlheader + ctrlfooter
    ncontrols = len( variables )
    varsheight = ncontrols * ctrlheight
    
    sizes = {
        'label': 13,
        graphics.NUMBER: 13,
        graphics.TEXT: 15,
        graphics.BOOLEAN: 16,
        graphics.BUTTON: 16,
        graphics.MENU: 16 }

    ctrlfluff = ctrltop + ctrlheader + ctrlfooter

    self.vars = variables
    self.clearInterface()
    if len(self.vars) &gt; 0:
        self.panel.orderFront_(None)
    else:
        self.panel.orderOut_(None)
        return


    # Set the title of the parameter panel to the title of the window
    self.panel.setTitle_(self.documentWindow.title())

    # pdb.set_trace()

    # reset panel
    self.panel.setContentSize_( (panelwidth, 97) )
    (panelx,panely),(panelwidth,panelheight) = self.panel.frame()

    # Height of the window. Each element has a height of ctrlheight.
    # The extra "fluff" is 38 pixels.
    # panelheight = len(self.vars) * 21 + 54
    panelheight = varsheight + ctrlfluff
    # print("panelheight: ", panelheight )
    self.panel.setMinSize_( (panelwidth, panelheight) )

    # Start of first element
    # First element is the height minus the fluff.
    # y = panelheight - 49
    y = panelheight - ( ctrlheader + ctrlfooter )
    
    cnt = 0
    widthlabel = 0
    widthctrl = 0
    y = panelheight - (ctrltop + ctrlheight + 20)
    for v in self.vars:
        leftheight = sizes.get('label', ctrlheight)
        rightheight = sizes.get(v.type, ctrlheight)
        left_coord = (label_x, y)
        right_coord = (ctrl_x, y)
        leftframe =  ( ( label_x, y), (label_w, leftheight) )
        rightframe = ( ( ctrl_x, y), (ctrl_w, rightheight) )

        if v.type == graphics.NUMBER:
            l = self.addLabel_idx_frame_(v, cnt, leftframe)
            c = self.addSlider_idx_frame_(v, cnt, rightframe)
            v.control = (l,c)

        elif v.type == graphics.TEXT:
            l = self.addLabel_idx_frame_(v, cnt, leftframe)
            c = self.addTextField_idx_frame_(v, cnt, rightframe)
            v.control = (l,c)

        elif v.type == graphics.BOOLEAN:
            c = self.addSwitch_idx_frame_(v, cnt, rightframe)
            v.control = (None,c)

        elif v.type == graphics.BUTTON:
            c = self.addButton_idx_frame_(v, cnt, rightframe)
            v.control = (None,c)

        elif v.type == graphics.MENU:
            l = self.addLabel_idx_frame_(v, cnt, leftframe)
            c = self.addMenu_idx_frame_(v, cnt, rightframe)
            v.control = (l,c)
        # print("cnt/y  %i   %i" % (cnt, y) )
        y -= ctrlheight
        cnt += 1

    self.panel.setFrame_display_animate_( ((panelx,panely),(panelwidth,panelheight)), True, 0 )


</t>
<t tx="karstenw.20170704105051.9">def addLabel_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    y += 3
    frame = ((x,y),(w,h))
    control = NSTextField.alloc().init()
    control.setFrame_( frame ) #((0,y),(100,16)) )
    control.setStringValue_(v.name + ":")
    control.setAlignment_(NSRightTextAlignment)
    control.setEditable_(False)
    control.setBordered_(False)
    control.setDrawsBackground_(False)
    control.setFont_(SMALL_FONT)
    # control.setAutoresizingMask_( AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control

</t>
<t tx="karstenw.20170704105106.1">import sys
import os
# import pdb

import objc

import AppKit
NSWindowController = AppKit.NSWindowController
NSForegroundColorAttributeName = AppKit.NSForegroundColorAttributeName
NSNotificationCenter = AppKit.NSNotificationCenter
NSFontManager = AppKit.NSFontManager
NSFontAttributeName = AppKit.NSFontAttributeName
NSUserDefaults = AppKit.NSUserDefaults
NSOpenPanel = AppKit.NSOpenPanel


from . import PyDETextView
getBasicTextAttributes = PyDETextView.getBasicTextAttributes
getSyntaxTextAttributes = PyDETextView.getSyntaxTextAttributes
setTextFont = PyDETextView.setTextFont
setBasicTextAttributes = PyDETextView.setBasicTextAttributes
setSyntaxTextAttributes = PyDETextView.setSyntaxTextAttributes


</t>
<t tx="karstenw.20170704105106.10">@objc.IBAction
def chooseFont_(self, sender):
    fm = NSFontManager.sharedFontManager()
    basicAttrs = getBasicTextAttributes()
    fm.setSelectedFont_isMultiple_(basicAttrs[NSFontAttributeName], False)
    fm.orderFrontFontPanel_(sender)
    fp = fm.fontPanel_(False)
    fp.setDelegate_(self)

</t>
<t tx="karstenw.20170704105106.11">@objc.IBAction
def chooseLibrary_(self, sender):
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(False)
    panel.setCanChooseDirectories_(True)
    panel.setAllowsMultipleSelection_(False)
    rval = panel.runModalForTypes_([])
    if rval:
        s = [t for t in panel.filenames()]
        s = s[0]
        NSUserDefaults.standardUserDefaults().setObject_forKey_( s,
                                                                "libraryPath")
        libpath = LibraryFolder()
        self.libraryPath.setStringValue_( libpath.libDir )


</t>
<t tx="karstenw.20170704105106.12">@objc.IBAction
def changeFont_(self, sender):
    oldFont = getBasicTextAttributes()[NSFontAttributeName]
    newFont = sender.convertFont_(oldFont)
    if oldFont != newFont:
        setTextFont(newFont)

</t>
<t tx="karstenw.20170704105106.13">def textFontChanged_(self, notification):
    basicAttrs = getBasicTextAttributes()
    font = basicAttrs[NSFontAttributeName]
    self.fontPreview.setFont_(font)
    size = font.pointSize()
    if size == int(size):
        size = int(size)
    s = u"%s %s" % (font.displayName(), size)
    self.fontPreview.setStringValue_(s)
</t>
<t tx="karstenw.20170704105106.2">class LibraryFolder(object):
    @others
# class defined in NodeBoxPreferences.xib
</t>
<t tx="karstenw.20170704105106.3">def __init__(self):
    self.libDir = ""
    prefpath = ""
    defaults = NSUserDefaults.standardUserDefaults()
    try:
        prefpath = defaults.objectForKey_("libraryPath")
    except Exception as err:
        print("LibraryFolder: prefpath: %s" % repr(prefpath))
        prefpath = ""
    stdpath = os.path.join(os.getenv("HOME"), "Library", "Application Support", "NodeBox")

    if prefpath and os.path.exists( prefpath ):
        self.libDir = prefpath
        NSUserDefaults.standardUserDefaults().setObject_forKey_( self.libDir,
                                                                "libraryPath")
    else:
        self.libDir = stdpath
        try:
            if not os.path.exists(self.libDir):
                os.mkdir(self.libDir)
        except OSError:
            pass
        except IOError:
            pass


</t>
<t tx="karstenw.20170704105106.4">class NodeBoxPreferencesController(NSWindowController):
    commentsColorWell = objc.IBOutlet()
    fontPreview = objc.IBOutlet()
    libraryPath = objc.IBOutlet()
    funcClassColorWell = objc.IBOutlet()
    keywordsColorWell = objc.IBOutlet()
    stringsColorWell = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20170704105106.5">def init(self):

    self = self.initWithWindowNibName_("NodeBoxPreferences")
    self.setWindowFrameAutosaveName_("NodeBoxPreferencesPanel")
    self.timer = None
    return self

</t>
<t tx="karstenw.20170704105106.6">def awakeFromNib(self):
    self.textFontChanged_(None)
    syntaxAttrs = syntaxAttrs = getSyntaxTextAttributes()
    self.stringsColorWell.setColor_(syntaxAttrs["string"][NSForegroundColorAttributeName])
    self.keywordsColorWell.setColor_(syntaxAttrs["keyword"][NSForegroundColorAttributeName])
    self.funcClassColorWell.setColor_(syntaxAttrs["identifier"][NSForegroundColorAttributeName])
    self.commentsColorWell.setColor_(syntaxAttrs["comment"][NSForegroundColorAttributeName])
    libpath = LibraryFolder()
    self.libraryPath.setStringValue_( libpath.libDir )

    nc = NSNotificationCenter.defaultCenter()
    nc.addObserver_selector_name_object_(self, "textFontChanged:", "PyDETextFontChanged", None)

</t>
<t tx="karstenw.20170704105106.7">def windowWillClose_(self, notification):
    fm = NSFontManager.sharedFontManager()
    fp = fm.fontPanel_(False)
    if fp is not None:
        fp.setDelegate_(None)
        fp.close()

</t>
<t tx="karstenw.20170704105106.8">@objc.IBAction
def updateColors_(self, sender):
    if self.timer is not None:
        self.timer.invalidate()
    self.timer = NSTimer.scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(
            1.0, self, "timeToUpdateTheColors:", None, False)

</t>
<t tx="karstenw.20170704105106.9">def timeToUpdateTheColors_(self, sender):
    syntaxAttrs = getSyntaxTextAttributes()
    syntaxAttrs["string"][NSForegroundColorAttributeName] = self.stringsColorWell.color()
    syntaxAttrs["keyword"][NSForegroundColorAttributeName] = self.keywordsColorWell.color()
    syntaxAttrs["identifier"][NSForegroundColorAttributeName] = self.funcClassColorWell.color()
    syntaxAttrs["comment"][NSForegroundColorAttributeName] = self.commentsColorWell.color()
    setSyntaxTextAttributes(syntaxAttrs)

</t>
<t tx="karstenw.20170704105113.1">from bisect import bisect
import re
import objc
super = objc.super

import AppKit

NSBackgroundColorAttributeName = AppKit.NSBackgroundColorAttributeName
NSBeep = AppKit.NSBeep
NSColor = AppKit.NSColor
NSCommandKeyMask = AppKit.NSCommandKeyMask
NSDictionary = AppKit.NSDictionary
NSEvent = AppKit.NSEvent
NSFont = AppKit.NSFont
NSFontAttributeName = AppKit.NSFontAttributeName
NSForegroundColorAttributeName = AppKit.NSForegroundColorAttributeName
NSLigatureAttributeName = AppKit.NSLigatureAttributeName
NSLiteralSearch = AppKit.NSLiteralSearch
NSNotificationCenter = AppKit.NSNotificationCenter
NSObject = AppKit.NSObject
NSStringPboardType = AppKit.NSStringPboardType
NSTextStorage = AppKit.NSTextStorage
NSTextStorageEditedCharacters = AppKit.NSTextStorageEditedCharacters
NSTextView = AppKit.NSTextView
NSURL = AppKit.NSURL
NSURLPboardType = AppKit.NSURLPboardType
NSViewWidthSizable = AppKit.NSViewWidthSizable

NSCalibratedRGBColorSpace = AppKit.NSCalibratedRGBColorSpace
NSUserDefaults = AppKit.NSUserDefaults


import nodebox.PyFontify
fontify = nodebox.PyFontify.fontify

import pdb

from nodebox.gui.mac.ValueLadder import ValueLadder

# from nodebox.gui.mac.AskStringWindowController import AskStringWindowController
from nodebox.gui.mac.AskStringWindowController import AskString

from nodebox.util import _copy_attr, _copy_attrs, makeunicode

whiteRE = re.compile(r"[ \t]+")
commentRE = re.compile(r"[ \t]*(#)")


</t>
<t tx="karstenw.20170704105113.10">def mouseDown_(self, event):
    if event.modifierFlags() &amp; NSCommandKeyMask:
        screenPoint = NSEvent.mouseLocation()
        viewPoint =   self.superview().convertPoint_fromView_(event.locationInWindow(),
                                                    self.window().contentView())

        c = self.characterIndexForPoint_(screenPoint)

        txt = self.string()
        # XXX move code into ValueLadder
        try:
            if txt[c] in "1234567890.":
                # Find full number
                begin = c
                end = c
                try:
                    while txt[begin-1] in "1234567890.":
                        begin-=1
                except IndexError as err:
                    print( "PyDETextView.mouseDown_() failed to scan number 1." )
                    print( err )
                    # pass
                try:
                    while txt[end+1] in "1234567890.":
                        end+=1
                except IndexError as err:
                    print( "PyDETextView.mouseDown_() failed to scan number 2." )
                    print( err )
                    # pass
                end+=1
                self.valueLadder = ValueLadder(self,
                                               eval(txt[begin:end]),
                                               (begin,end),
                                               screenPoint, viewPoint)
        except IndexError:
            print( "PyDETextView.mouseDown_() failed to scan number 3." )
            print( err )
            # pass
    else:
        NSTextView.mouseDown_(self,event)

</t>
<t tx="karstenw.20170704105113.11">def acceptableDragTypes(self):
    return list(super(PyDETextView, self).acceptableDragTypes()) + [NSURLPboardType]

</t>
<t tx="karstenw.20170704105113.12">def draggingEntered_(self, dragInfo):
    pboard = dragInfo.draggingPasteboard()
    types = pboard.types()
    if NSURLPboardType in pboard.types():
        # Convert URL to string, replace pboard entry, let NSTextView
        # handle the drop as if it were a plain text drop.
        url = NSURL.URLFromPasteboard_(pboard)
        if url.isFileURL():
            s = url.path()
        else:
            s = url.absoluteString()
        s = 'u"%s"' % s.replace('"', '\\"')
        pboard.declareTypes_owner_([NSStringPboardType], self)
        pboard.setString_forType_(s, NSStringPboardType)
    return super(PyDETextView, self).draggingEntered_(dragInfo)

</t>
<t tx="karstenw.20170704105113.13">def _cleanup(self):
    # delete two circular references
    del self._string
    del self._storageDelegate

</t>
<t tx="karstenw.20170704105113.14">def __del__(self):
    nc = NSNotificationCenter.defaultCenter()
    nc.removeObserver_name_object_(self, "PyDETextFontChanged", None)

</t>
<t tx="karstenw.20170704105113.15">@objc.IBAction
def jumpToLine_(self, sender):
    # from nodebox.gui.mac.AskString import AskString
    AskString( u"Jump to line number:", self.jumpToLineCallback_, u"", self.window() )

</t>
<t tx="karstenw.20170704105113.16">def jumpToLineCallback_(self, value):
    if value is None:
        return  # user cancelled
    try:
        lineNo = int(value.strip())
    except ValueError:
        NSBeep()
    else:
        self.jumpToLineNr_(lineNo)

</t>
<t tx="karstenw.20170704105113.17">def jumpToLineNr_(self, lineNo):
    lines = self.textStorage().string().splitlines()
    lineNo = min(max(0, lineNo - 1), len(lines))
    length_of_prevs = sum([len(line)+1 for line in lines[:lineNo]])
    curlen = len(lines[lineNo])
    rng = (length_of_prevs, curlen)
    self.setSelectedRange_(rng)
    self.scrollRangeToVisible_(rng)
    self.setNeedsDisplay_(True)

</t>
<t tx="karstenw.20170704105113.18">def textFontChanged_(self, notification):
    basicAttrs = getBasicTextAttributes()
    self.setTypingAttributes_(basicAttrs)
    # Somehow the next line is needed, we crash otherwise :(
    self.layoutManager().invalidateDisplayForCharacterRange_(
                                                    (0, self._string.length()))
    self._storageDelegate.textFontChanged_(notification)

</t>
<t tx="karstenw.20170704105113.19">def setTextStorage_str_tabs_(self, storage, string, usesTabs):
    storage.addLayoutManager_(self.layoutManager())
    self._string = string
    self.usesTabs = usesTabs

</t>
<t tx="karstenw.20170704105113.2">def findWhitespace(s, pos=0):
    m = whiteRE.match(s, pos)
    if m is None:
        return pos
    return m.end()


stringPat = r"q[^\\q\n]*(\\[\000-\377][^\\q\n]*)*q"
stringOrCommentPat = stringPat.replace("q", "'") + "|" + stringPat.replace('q', '"') + "|#.*"
stringOrCommentRE = re.compile(stringOrCommentPat)


</t>
<t tx="karstenw.20170704105113.20">@objc.IBAction
def changeFont_(self, sender):
    # Change the font through the user prefs API, we'll get notified
    # through textFontChanged_
    font = getBasicTextAttributes()[NSFontAttributeName]
    font = sender.convertFont_(font)
    setTextFont(font)

</t>
<t tx="karstenw.20170704105113.21">def getLinesForRange_(self, rng):
    rng = self._string.lineRangeForRange_(rng)
    return self._string.substringWithRange_(rng), rng

</t>
<t tx="karstenw.20170704105113.22">def getIndent(self):
    if self.usesTabs:
        return "\t"
    else:
        return self.indentSize * " "

</t>
<t tx="karstenw.20170704105113.23">def drawInsertionPointInRect_color_turnedOn_(self, pt, color, on):
    self.insertionPoint = pt
    super(PyDETextView, self).drawInsertionPointInRect_color_turnedOn_(pt, color, on)

</t>
<t tx="karstenw.20170704105113.24">def keyDown_(self, event):
    super(PyDETextView, self).keyDown_(event)
    char = event.characters()[:1]
    if char in ")]}":
        selRng = self.selectedRange()
        line, lineRng, pos = self.findMatchingIndex_paren_(selRng[0] - 1, char)
        if pos is not None:
            self.balanceParens_(lineRng[0] + pos)

</t>
<t tx="karstenw.20170704105113.25">def balanceParens_(self, index):
    rng = (index, 1)
    oldAttrs, effRng = self.textStorage().attributesAtIndex_effectiveRange_(index,
                                                                            None)
    balancingAttrs = {
        NSBackgroundColorAttributeName: NSColor.selectedTextBackgroundColor()
    }
    # Must use temp attrs otherwise the attrs get reset right away due to colorizing.
    self.layoutManager().setTemporaryAttributes_forCharacterRange_(balancingAttrs,
                                                                            rng)
    self.performSelector_withObject_afterDelay_("resetBalanceParens:",
            (oldAttrs, effRng), 0.2)

</t>
<t tx="karstenw.20170704105113.26">def resetBalanceParens_(self, params):
    attrs, rng = params
    self.layoutManager().setTemporaryAttributes_forCharacterRange_(attrs, rng)

</t>
<t tx="karstenw.20170704105113.27">def iterLinesBackwards_maxChars_(self, end, maxChars):
    begin = max(0, end - maxChars)
    if end &gt; 0:
        prevChar = self._string.characterAtIndex_(end - 1)
        if prevChar == "\n":
            end += 1
    lines, linesRng = self.getLinesForRange_((begin, end - begin))
    lines = lines[:end - linesRng[0]]
    linesRng = (linesRng[0], len(lines))
    lines = lines.splitlines(True)
    lines.reverse()
    for line in lines:
        nChars = len(line)
        yield line, (end - nChars, nChars)
        end -= nChars
    assert end == linesRng[0]

</t>
<t tx="karstenw.20170704105113.28">def findMatchingIndex_paren_(self, index, paren):
    openToCloseMap = {"(": ")", "[": "]", "{": "}"}
    if paren:
        stack = [paren]
    else:
        stack = []
    line, lineRng, pos = None, None, None
    for line, lineRng in self.iterLinesBackwards_maxChars_(index, 8192):
        line = removeStringsAndComments(line)
        pos = None
        for i in range(len(line)-1, -1, -1):
            c = line[i]
            if c in ")]}":
                stack.append(c)
            elif c in "([{":
                if not stack:
                    if not paren:
                        pos = i
                    break
                elif stack[-1] != openToCloseMap[c]:
                    # mismatch
                    stack = []
                    break
                else:
                    stack.pop()
                    if paren and not stack:
                        pos = i
                        break
        if not stack:
            break
    return line, lineRng, pos

</t>
<t tx="karstenw.20170704105113.29">def insertNewline_(self, sender):
    selRng = self.selectedRange()
    super(PyDETextView, self).insertNewline_(sender)
    line, lineRng, pos = self.findMatchingIndex_paren_(selRng[0], None)
    if line is None:
        return
    leadingSpace = ""
    if pos is None:
        m = whiteRE.match(line)
        if m is not None:
            leadingSpace = m.group()
    else:
        leadingSpace = re.sub(r"[^\t]", " ", line[:pos + 1])
    line, lineRng = self.getLinesForRange_((selRng[0], 0))
    line = removeStringsAndComments(line).strip()
    if line and line[-1] == ":":
        leadingSpace += self.getIndent()

    if leadingSpace:
        self.insertText_(leadingSpace)

</t>
<t tx="karstenw.20170704105113.3">def removeStringsAndComments(s):
    items = []
    while 1:
        m = stringOrCommentRE.search(s)
        if m:
            start = m.start()
            end = m.end()
            items.append(s[:start])
            if s[start] != "#":
                items.append("X" * (end - start))  # X-out strings
            s = s[end:]
        else:
            items.append(s)
            break
    return "".join(items)


</t>
<t tx="karstenw.20170704105113.30">def insertTab_(self, sender):
    if self.usesTabs:
        return super(PyDETextView, self).insertTab_(sender)
    self.insertText_("")
    selRng = self.selectedRange()
    assert selRng[1] == 0
    lines, linesRng = self.getLinesForRange_(selRng)
    sel = selRng[0] - linesRng[0]
    whiteEnd = findWhitespace(lines, sel)
    nSpaces = self.indentSize - (whiteEnd % self.indentSize)
    self.insertText_(nSpaces * " ")
    sel += nSpaces
    whiteEnd += nSpaces
    sel = min(whiteEnd, sel + (sel % self.indentSize))
    self.setSelectedRange_((sel + linesRng[0], 0))

</t>
<t tx="karstenw.20170704105113.31">def deleteBackward_(self, sender):
    self.delete_fwd_superf_(sender, False, super(PyDETextView, self).deleteBackward_)

</t>
<t tx="karstenw.20170704105113.32">def deleteForward_(self, sender):
    self.delete_fwd_superf_(sender, True, super(PyDETextView, self).deleteForward_)

</t>
<t tx="karstenw.20170704105113.33">def delete_fwd_superf_(self, sender, isForward, superFunc):
    selRng = self.selectedRange()
    if self.usesTabs or selRng[1]:
        return superFunc(sender)
    lines, linesRng = self.getLinesForRange_(selRng)
    sel = selRng[0] - linesRng[0]
    whiteEnd = findWhitespace(lines, sel)
    whiteBegin = sel
    while whiteBegin and lines[whiteBegin-1] == " ":
        whiteBegin -= 1
    if not isForward:
        white = whiteBegin
    else:
        white = whiteEnd
    if white == sel or (whiteEnd - whiteBegin) &lt;= 1:
        return superFunc(sender)
    nSpaces = (whiteEnd % self.indentSize)
    if nSpaces == 0:
        nSpaces = self.indentSize
    offset = sel % self.indentSize
    if not isForward and offset == 0:
        offset = nSpaces
    delBegin = sel - offset
    delEnd = delBegin + nSpaces
    delBegin = max(delBegin, whiteBegin)
    delEnd = min(delEnd, whiteEnd)
    self.setSelectedRange_((linesRng[0] + delBegin, delEnd - delBegin))
    self.insertText_("")

</t>
<t tx="karstenw.20170704105113.34">@objc.IBAction
def indent_(self, sender):
    def indentFilter(lines):
        indent = self.getIndent()
        indentedLines = []
        for line in lines:
            if line.strip():
                indentedLines.append(indent + line)
            else:
                indentedLines.append(line)
        [indent + line for line in lines[:-1]]
        return indentedLines
    self.filterLines_(indentFilter)

</t>
<t tx="karstenw.20170704105113.35">@objc.IBAction
def dedent_(self, sender):
    def dedentFilter(lines):
        indent = self.getIndent()
        dedentedLines = []
        indentSize = len(indent)
        for line in lines:
            if line.startswith(indent):
                line = line[indentSize:]
            dedentedLines.append(line)
        return dedentedLines
    self.filterLines_(dedentFilter)

</t>
<t tx="karstenw.20170704105113.36">@objc.IBAction
def comment_(self, sender):
    def commentFilter(lines):
        commentedLines = []
        indent = self.getIndent()
        pos = 100
        for line in lines:
            if not line.strip():
                continue
            pos = min(pos, findWhitespace(line))
        for line in lines:
            if line.strip():
                commentedLines.append(line[:pos] + "#" + line[pos:])
            else:
                commentedLines.append(line)
        return commentedLines
    self.filterLines_(commentFilter)

</t>
<t tx="karstenw.20170704105113.37">@objc.IBAction
def uncomment_(self, sender):
    def uncommentFilter(lines):
        commentedLines = []
        commentMatch = commentRE.match
        for line in lines:
            m = commentMatch(line)
            if m is not None:
                pos = m.start(1)
                line = line[:pos] + line[pos+1:]
            commentedLines.append(line)
        return commentedLines
    self.filterLines_(uncommentFilter)

</t>
<t tx="karstenw.20170704105113.38">def filterLines_(self, filterFunc):
    selRng = self.selectedRange()
    lines, linesRng = self.getLinesForRange_(selRng)

    filteredLines = filterFunc(lines.splitlines(True))

    filteredLines = "".join(filteredLines)
    if lines == filteredLines:
        return
    self.setSelectedRange_(linesRng)
    self.insertText_(filteredLines)
    newSelRng = linesRng[0], len(filteredLines)
    self.setSelectedRange_(newSelRng)

</t>
<t tx="karstenw.20170704105113.39">class PyDETextStorageDelegate(NSObject):

    @others
</t>
<t tx="karstenw.20170704105113.4">class PyDETextView(NSTextView):

    document = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20170704105113.40">def __new__(cls, *args, **kwargs):
    return cls.alloc().init()

</t>
<t tx="karstenw.20170704105113.41">def __init__(self, textStorage=None):
    self._syntaxColors = getSyntaxTextAttributes()
    self._haveScheduledColorize = False
    self._source = None  # XXX
    self._dirty = []
    if textStorage is None:
        textStorage = NSTextStorage.alloc().init()
    self._storage = textStorage
    self._storage.setAttributes_range_(getBasicTextAttributes(),
            (0, textStorage.length()))
    self._string = self._storage.mutableString().nsstring()
    self._lineTracker = LineTracker(self._string)
    self._storage.setDelegate_(self)

</t>
<t tx="karstenw.20170704105113.42">def textFontChanged_(self, notification):
    self._storage.setAttributes_range_(getBasicTextAttributes(),
            (0, self._storage.length()))
    self._syntaxColors = getSyntaxTextAttributes()
    self._dirty = [0]
    self.scheduleColorize()

</t>
<t tx="karstenw.20170704105113.43">def textStorage(self):
    return self._storage

</t>
<t tx="karstenw.20170704105113.44">def string(self):
    return self._string

</t>
<t tx="karstenw.20170704105113.45">def lineIndexFromCharIndex_(self, charIndex):
    return self._lineTracker.lineIndexFromCharIndex_(charIndex)

</t>
<t tx="karstenw.20170704105113.46">def charIndexFromLineIndex_(self, lineIndex):
    return self._lineTracker.charIndexFromLineIndex_(lineIndex)

</t>
<t tx="karstenw.20170704105113.47">def numberOfLines(self):
    return self._lineTracker.numberOfLines()

</t>
<t tx="karstenw.20170704105113.48">def getSource(self):
    if self._source is None:
        # self._source = makeunicode(self._string)
        self._source = self._string
    return self._source

</t>
<t tx="karstenw.20170704105113.49">def textStorageWillProcessEditing_(self, notification):
    if not self._storage.editedMask() &amp; NSTextStorageEditedCharacters:
        return
    rng = self._storage.editedRange()
    # make darn sure we don't get infected with return chars
    s = self._string
    s.replaceOccurrencesOfString_withString_options_range_("\r", "\n",
                                                        NSLiteralSearch , rng)

</t>
<t tx="karstenw.20170704105113.5">def awakeFromNib(self):
    # Can't use a subclass of NSTextView as an NSTextView in IB,
    # so we need to set some attributes programmatically
    scrollView = self.superview().superview()
    self.setFrame_(((0, 0), scrollView.contentSize()))
    self.setAutoresizingMask_(NSViewWidthSizable)
    self.textContainer().setWidthTracksTextView_(True)
    self.setAllowsUndo_(True)
    self.setRichText_(False)
    self.setTypingAttributes_(getBasicTextAttributes())
    self.setUsesFindPanel_(True)
    self.usesTabs = 0
    self.indentSize = 4
    self._string = self.textStorage().mutableString().nsstring()
    self._storageDelegate = PyDETextStorageDelegate(self.textStorage())
    
    # FDB: no wrapping
    # Thanks to http://cocoa.mamasam.com/COCOADEV/2003/12/2/80304.php
    scrollView = self.enclosingScrollView()
    scrollView.setHasHorizontalScroller_(True)
    self.setHorizontallyResizable_(True)
    layoutSize = self.maxSize()
    layoutSize = (layoutSize[1], layoutSize[1])
    self.setMaxSize_(layoutSize)
    self.textContainer().setWidthTracksTextView_(False)
    self.textContainer().setContainerSize_(layoutSize)

    # FDB: value ladder
    self.valueLadder = None
    
    nc = NSNotificationCenter.defaultCenter()
    nc.addObserver_selector_name_object_(self, "textFontChanged:",
                                               "PyDETextFontChanged", None)

</t>
<t tx="karstenw.20170704105113.50">def textStorageDidProcessEditing_(self, notification):
    if not self._storage.editedMask() &amp; NSTextStorageEditedCharacters:
        return
    self._source = None
    rng = self._storage.editedRange()
    try:
        self._lineTracker._update(rng, self._storage.changeInLength())
    except:
        import traceback
        traceback.print_exc()
    start = rng[0]
    rng = (0, 0)
    count = 0
    while start &gt; 0:
        # find the last colorized token and start from there.
        start -= 1
        attrs, rng = self._storage.attributesAtIndex_effectiveRange_(start, None)
        value = attrs.objectForKey_(NSForegroundColorAttributeName)
        if value != None:
            count += 1
            if count &gt; 1:
                break
        # uncolorized section, track back
        start = rng[0] - 1
    rng = self._string.lineRangeForRange_((rng[0], 0))
    self._dirty.append(rng[0])
    self.scheduleColorize()

</t>
<t tx="karstenw.20170704105113.51">def scheduleColorize(self):
    if not self._haveScheduledColorize:
        self.performSelector_withObject_afterDelay_("colorize", None, 0.0)
        self._haveScheduledColorize = True

</t>
<t tx="karstenw.20170704105113.52">def colorize(self):
    self._haveScheduledColorize = False
    self._storage.beginEditing()
    try:
        try:
            self._colorize()
        except:
            import traceback
            traceback.print_exc()
    finally:
        self._storage.endEditing()

</t>
<t tx="karstenw.20170704105113.53">def _colorize(self):
    if not self._dirty:
        return
    storage = self._storage
    source = self.getSource()
    source = source.copy()
    sourceLen = len(source)
    dirtyStart = self._dirty.pop()

    getColor = self._syntaxColors.get
    setAttrs = storage.setAttributes_range_
    getAttrs = storage.attributesAtIndex_effectiveRange_
    basicAttrs = getBasicTextAttributes()

    lastEnd = end = dirtyStart
    count = 0
    sameCount = 0
    
    #plainlength = source.length
    #(void)getCharacters:(unsigned short*)arg1 range:(NSRange)arg2
    #plaintext = source.mutableAttributedString.mutableString
    #for tag, start, end, sublist in fontify(plaintext, dirtyStart):
    for tag, start, end, sublist in fontify(source, dirtyStart):
        end = min(end, sourceLen)
        rng = (start, end - start)
        attrs = getColor(tag)
        oldAttrs, oldRng = getAttrs(rng[0], None)
        if attrs is not None:
            clearRng = (lastEnd, start - lastEnd)
            if clearRng[1]:
                setAttrs(basicAttrs, clearRng)
            setAttrs(attrs, rng)
            if rng == oldRng and attrs == oldAttrs:
                sameCount += 1
                if sameCount &gt; 4:
                    # due to backtracking we have to account for a few more
                    # tokens, but if we've seen a few tokens that were already
                    # colorized the way we want, we're done
                    return
            else:
                sameCount = 0
        else:
            rng = (lastEnd, end - lastEnd)
            if rng[1]:
                setAttrs(basicAttrs, rng)
        count += 1
        if count &gt; 200:
            # enough for now, schedule a new chunk
            self._dirty.append(end)
            self.scheduleColorize()
            break
        lastEnd = end
    else:
        # reset coloring at the end
        end = min(sourceLen, end)
        rng = (end, sourceLen - end)
        if rng[1]:
            setAttrs(basicAttrs, rng)


</t>
<t tx="karstenw.20170704105113.54">class LineTracker(object):

    @others
_basicFont = NSFont.userFixedPitchFontOfSize_(11)

_BASICATTRS = {NSFontAttributeName: _basicFont,
               NSLigatureAttributeName: 0}
_SYNTAXCOLORS = {
    "keyword": {NSForegroundColorAttributeName: NSColor.blueColor()},
    "identifier": {
        NSForegroundColorAttributeName: NSColor.redColor().shadowWithLevel_(0.2)},
    "string": {NSForegroundColorAttributeName: NSColor.magentaColor()},
    "comment": {NSForegroundColorAttributeName: NSColor.grayColor()},
}
for key, value in _SYNTAXCOLORS.items():
    newVal = _BASICATTRS.copy()
    newVal.update(value)
    _SYNTAXCOLORS[key] = NSDictionary.dictionaryWithDictionary_(newVal)
_BASICATTRS = NSDictionary.dictionaryWithDictionary_(_BASICATTRS)


</t>
<t tx="karstenw.20170704105113.55">def __init__(self, string):
    self.string = string
    self.lines, self.lineStarts, self.lineLengths = self._makeLines()

</t>
<t tx="karstenw.20170704105113.56">def _makeLines(self, start=0, end=None):
    lines = []
    lineStarts = []
    lineLengths = []
    string = self.string
    if end is None:
        end = string.length()
    else:
        end = min(end, string.length())
    rng = string.lineRangeForRange_((start, end - start))
    pos = rng[0]
    end = pos + rng[1]
    while pos &lt; end:
        lineRng = string.lineRangeForRange_((pos, 0))
        line = makeunicode(string.substringWithRange_(lineRng))
        assert len(line) == lineRng[1]
        lines.append(line)
        lineStarts.append(lineRng[0])
        lineLengths.append(lineRng[1])
        if not lineRng[1]:
            break
        pos += lineRng[1]
    return lines, lineStarts, lineLengths

</t>
<t tx="karstenw.20170704105113.57">def _update(self, editedRange, changeInLength):
    oldRange = editedRange[0], editedRange[1] - changeInLength
    start = self.lineIndexFromCharIndex_(oldRange[0])
    if oldRange[1]:
        end = self.lineIndexFromCharIndex_(oldRange[0] + oldRange[1])
    else:
        end = start

    lines, lineStarts, lineLengths = self._makeLines(
        editedRange[0], editedRange[0] + editedRange[1] + 1)
    self.lines[start:end + 1] = lines
    self.lineStarts[start:] = lineStarts  # drop invalid tail
    self.lineLengths[start:end + 1] = lineLengths
    # XXX: This assertion doesn't actually assert
    # assert "".join(self.lines) == unicode(self.string)

</t>
<t tx="karstenw.20170704105113.58">def lineIndexFromCharIndex_(self, charIndex):
    lineIndex = bisect(self.lineStarts, charIndex)
    if lineIndex == 0:
        return 0
    nLines = len(self.lines)
    nLineStarts = len(self.lineStarts)
    if lineIndex == nLineStarts and nLineStarts != nLines:
        # update line starts
        i = nLineStarts - 1
        assert i &gt;= 0
        pos = self.lineStarts[i]
        while pos &lt;= charIndex and i &lt; nLines:
            pos = pos + self.lineLengths[i]
            self.lineStarts.append(pos)
            i += 1
        lineIndex = i

    lineIndex -= 1
    start = self.lineStarts[lineIndex]
    line = self.lines[lineIndex]
    if (    line[-1:] == "\n"
        and not (start &lt;= charIndex &lt; start + self.lineLengths[lineIndex])):
        lineIndex += 1
    return lineIndex

</t>
<t tx="karstenw.20170704105113.59">def charIndexFromLineIndex_(self, lineIndex):
    if not self.lines:
        return 0
    if lineIndex == len(self.lines):
        return self.lineStarts[-1] + self.lineLengths[-1]
    try:
        return self.lineStarts[lineIndex]
    except IndexError:
        # update lineStarts
        for i in range(min(len(self.lines), lineIndex + 1) - len(self.lineStarts)):
            self.lineStarts.append(self.lineStarts[-1] + self.lineLengths[-1])
        # XXX: Assertion doesn't actually assert.
        #assert len(self.lineStarts) == len(self.lineLengths) == len(self.lines)
        if lineIndex == len(self.lineStarts):
            return self.lineStarts[-1] + self.lineLengths[-1]
        return self.lineStarts[lineIndex]

</t>
<t tx="karstenw.20170704105113.6">def drawRect_(self, rect):
    NSTextView.drawRect_(self, rect)
    if self.valueLadder is not None and self.valueLadder.visible:
        self.valueLadder.draw()
        
</t>
<t tx="karstenw.20170704105113.60">def numberOfLines(self):
    return len(self.lines)

</t>
<t tx="karstenw.20170704105113.61">def unpackAttrs(d):
    unpacked = {}
    for key, value in d.items():
        if key == NSFontAttributeName:
            name = value["name"]
            size = value["size"]
            value = NSFont.fontWithName_size_(name, size)
        elif key in (NSForegroundColorAttributeName, NSBackgroundColorAttributeName):
            r, g, b, a = map(float, value.split())
            value = NSColor.colorWithCalibratedRed_green_blue_alpha_(r, g, b, a)
        elif isinstance(value, (dict, NSDictionary)):
            value = unpackAttrs(value)
        unpacked[key] = value
    return unpacked

</t>
<t tx="karstenw.20170704105113.62">def packAttrs(d):
    packed = {}
    for key, value in d.items():
        if key == NSFontAttributeName:
            value = {"name": value.fontName(), "size": value.pointSize()}
        elif key in (NSForegroundColorAttributeName, NSBackgroundColorAttributeName):
            col = value.colorUsingColorSpaceName_(NSCalibratedRGBColorSpace)
            channels = col.getRed_green_blue_alpha_(None, None, None, None)
            value = " ".join(map(str, channels))
        elif isinstance(value, (dict, NSDictionary)):
            value = packAttrs(value)
        packed[key] = value
    return packed


</t>
<t tx="karstenw.20170704105113.63">def getBasicTextAttributes():
    attrs = NSUserDefaults.standardUserDefaults().objectForKey_(
            "PyDEDefaultTextAttributes")
    return unpackAttrs(attrs)

</t>
<t tx="karstenw.20170704105113.64">def getSyntaxTextAttributes():
    attrs = NSUserDefaults.standardUserDefaults().objectForKey_(
            "PyDESyntaxTextAttributes")
    return unpackAttrs(attrs)

</t>
<t tx="karstenw.20170704105113.65">def setBasicTextAttributes(basicAttrs):
    if basicAttrs != getBasicTextAttributes():
        NSUserDefaults.standardUserDefaults().setObject_forKey_(
                packAttrs(basicAttrs), "PyDEDefaultTextAttributes")
        nc = NSNotificationCenter.defaultCenter()
        nc.postNotificationName_object_("PyDETextFontChanged", None)

</t>
<t tx="karstenw.20170704105113.66">def setSyntaxTextAttributes(syntaxAttrs):
    if syntaxAttrs != getSyntaxTextAttributes():
        NSUserDefaults.standardUserDefaults().setObject_forKey_(
                packAttrs(syntaxAttrs), "PyDESyntaxTextAttributes")
        nc = NSNotificationCenter.defaultCenter()
        nc.postNotificationName_object_("PyDETextFontChanged", None)

</t>
<t tx="karstenw.20170704105113.67">def setTextFont(font):
    basicAttrs = getBasicTextAttributes()
    syntaxAttrs = getSyntaxTextAttributes()
    basicAttrs[NSFontAttributeName] = font
    for v in syntaxAttrs.values():
        v[NSFontAttributeName] = font
    setBasicTextAttributes(basicAttrs)
    setSyntaxTextAttributes(syntaxAttrs)

_defaultUserDefaults = {
    "PyDEDefaultTextAttributes": packAttrs(_BASICATTRS),
    "PyDESyntaxTextAttributes": packAttrs(_SYNTAXCOLORS),
}

NSUserDefaults.standardUserDefaults().registerDefaults_(_defaultUserDefaults)
</t>
<t tx="karstenw.20170704105113.7">def hideValueLadder(self):
    if self.valueLadder is not None:            
        self.valueLadder.hide()
        if self.valueLadder.dirty:
            self.document.updateChangeCount_(True)
    self.valueLadder = None

</t>
<t tx="karstenw.20170704105113.8">def mouseUp_(self, event):
    self.hideValueLadder()
    NSTextView.mouseUp_(self, event)
        
</t>
<t tx="karstenw.20170704105113.9">def mouseDragged_(self,event):
    if self.valueLadder is not None:
        self.valueLadder.mouseDragged_(event)
    else:
        NSTextView.mouseDragged_(self, event)

</t>
<t tx="karstenw.20170704105119.1">import AppKit

</t>
<t tx="karstenw.20170704105119.2">def errorAlert(msgText, infoText):
    # Force NSApp initialisation.
    AppKit.NSApplication.sharedApplication().activateIgnoringOtherApps_(0)
    alert = AppKit.NSAlert.alloc().init()
    alert.setMessageText_(msgText)
    alert.setInformativeText_(infoText)
    alert.setAlertStyle_(AppKit.NSCriticalAlertStyle)
    btn = alert.addButtonWithTitle_("OK")
    return alert.runModal()

</t>
<t tx="karstenw.20170704105126.1">    import compiler
    parse = compiler.parse
    import compiler.ast
    Sub = compiler.ast.Sub
    UnarySub = compiler.ast.UnarySub
    Add = compiler.ast.Add



kwdbg = False
# import pdb

import Foundation

import AppKit
NSObject = AppKit.NSObject
NSColor = AppKit.NSColor
NSMutableParagraphStyle = AppKit.NSMutableParagraphStyle
NSCenterTextAlignment = AppKit.NSCenterTextAlignment
NSFont = AppKit.NSFont
NSForegroundColorAttributeName = AppKit.NSForegroundColorAttributeName
NSCursor = AppKit.NSCursor
NSGraphicsContext = AppKit.NSGraphicsContext
NSBezierPath = AppKit.NSBezierPath
NSString = AppKit.NSString
NSEvent = AppKit.NSEvent
NSAlternateKeyMask = AppKit.NSAlternateKeyMask
NSShiftKeyMask = AppKit.NSShiftKeyMask
NSParagraphStyleAttributeName = AppKit.NSParagraphStyleAttributeName
NSFontAttributeName = AppKit.NSFontAttributeName


</t>
<t tx="karstenw.20170704105126.2">class ValueLadder:

    view = None
    visible = False
    value = None
    origValue = None
    dirty = False
    type = None
    negative = False
    unary = False
    add = False

    @others


</t>
<t tx="karstenw.20170704105126.3">def __init__(self, textView, value, clickPos, screenPoint, viewPoint):
    self.textView = textView
    self.value = value
    self.origValue = value
    self.type = type(value)
    self.clickPos = clickPos
    self.origX, self.origY = screenPoint
    self.x, self.y = screenPoint
    self.viewPoint = viewPoint
    (x,y),(self.width,self.height) = self.textView.bounds()
    self.originalString = self.textView.string()
    self.backgroundColor = gBGCol 
    self.strokeColor = gStrCol
    self.textColor = gTxtCol
    paraStyle = NSMutableParagraphStyle.alloc().init()
    paraStyle.setAlignment_(NSCenterTextAlignment)
    font = NSFont.fontWithName_size_("Monaco", 10)
    self.textAttributes = {
        NSForegroundColorAttributeName: self.textColor,
        NSParagraphStyleAttributeName:  paraStyle,
        NSFontAttributeName:            font}

    # To speed things up, the code is compiled only once. 
    # The number is replaced with a magic variable, that is set in the 
    # namespace when executing the code.
    begin,end = self.clickPos
    self.patchedSource = (self.originalString[:begin]
                            + MAGICVAR
                            + self.originalString[end:])

    #ast = parse(self.patchedSource + "\n\n")
    #self._checkSigns(ast)
    success, output = self.textView.document.boxedRun_args_(self._parseAndCompile, [])
    if success:
        self.show()
    else:
        self.textView.document._flushOutput(output)

</t>
<t tx="karstenw.20170704105126.4">def _parseAndCompile(self):
    s = self.patchedSource.encode('ascii', 'replace') + b"\n\n"
    ast = parse( s )
    # pdb.set_trace()
    self._checkSigns( ast )
    self.textView.document._compileScript(self.patchedSource)

</t>
<t tx="karstenw.20170704105126.5">def _checkSigns(self, node):
    """Recursively check for special sign cases.
    
    The following cases are special:
    - Substraction. When you select the last part of a substraction 
      (e.g. the 5 of "10-5"), it might happen that you drag the number to
      a positive value. In that case, the result should be "10+5".
    - Unary substraction. Values like "-5" should have their sign removed 
      when you drag them to a positive value.
    - Addition. When you select the last part of an addition 
      (e.g. the 5 of "10+5"), and drag the number to a negative value, 
      the result should be "10-5".
      
    This algorithm checks for these cases. It tries to find the magic var, 
    and then checks the parent node to see if it is one of these cases, 
    then sets the appropriate state variables in the object.
    
    This algorithm is recursive. Because we have to differ between a 
    "direct hit" (meaning the current child was the right one) and a 
    "problem resolved" (meaning the algorithm found the node, did its
    work and now needs to bail out), we have three return codes:
    - -1: nothing was found in this node and its child nodes.
    -  1: direct hit. The child you just searched contains the magicvar.
          check the current node to see if it is one of the special cases.
    -  0: bail out. Somewhere, a child contained the magicvar, and we
          acted upon it. Now leave this algorithm as soon as possible.
    """

    # Check whether I am the correct node
    try:
        if node.name == MAGICVAR:
            # If i am, return the "direct hit" code.
            return 1
    except AttributeError:
        pass

    # We keep an index to see what child we are checking. This 
    # is important for binary operations, were we are only interested
    # in the second part. ("a-10" has to change to "a+10", 
    # but "10-a" shouldn't change to "+10-a")
    index = 0

    # Recursively check my children
    for child in ast.iter_child_nodes( node ):
        retVal = self._checkSigns( child )
        # Direct hit. The child I just searched contains the magicvar.
        # Check whether this node is one of the special cases.
        if retVal == 1:
            # Unary substitution.
            if isinstance(node, UnarySub):
                self.negative = True
                self.unary = True
            # Binary substitution. Only the second child is of importance.
            elif isinstance(node, Sub) and index == 1:
                self.negative = True
            # Binary addition. Only the second child is of importance.
            elif isinstance(node, Add) and index == 1:
                self.add = True
            # Return the "bail out" code, whether we found some
            # special case or not. There can only be one magicvar in the
            # code, so once that is found we can stop looking.
            return 0
        # If the child returns a bail out code, we leave this routine
        # without checking the other children, passing along the
        # bail out code.
        elif retVal == 0:
            return 0 # Nothing more needs to be done.

        # Next child.
        index += 1

    # We searched all children, but couldn't find any magicvars. 
    return -1

</t>
<t tx="karstenw.20170704105126.6">def show(self):
    self.visible = True
    self.textView.setNeedsDisplay_(True)
    NSCursor.hide()

</t>
<t tx="karstenw.20170704105126.7">def hide(self):
    """Hide the ValueLadder and update the code.
    
    Updating the code means we have to replace the current value with
    the new value, and account for any special cases."""

    self.visible = False
    begin,end = self.clickPos

    # Potentionally change the sign on the number.
    # The following cases are valid:
    # - A subtraction where the value turned positive
    #       "random(5-8)" --&gt; "random(5+8)"
    # - A unary subtraction where the value turned positive
    #       "random(-5)" --&gt; "random(5)"
    #   Note that the sign dissapears here.
    # - An addition where the second part turns negative
    #       "random(5+8)" --&gt; "random(5-8)"
    # Note that the code replaces the sign on the place where it was,
    # leaving the code intact.

    # Case 1: Negative numbers where the new value is negative as well.
    # This means the numbers turn positive.
    if self.negative and self.value &lt; 0:
        # Find the minus sign.
        i = begin - 1
        notFound = True
        while True:
            if self.originalString[i] == '-':
                # Unary subtractions will have the sign removed.
                if self.unary: 
                    # Re-create the string: the spaces between
                    # the value and the '-' + the value
                    value = (  self.originalString[i+1:begin]
                             + str(abs(self.value)) )
                else:
                    # Binary subtractions get a '+'                        
                    value = '+' + self.originalString[i+1:begin] + str(abs(self.value))
                range = (i,end-i)
                break
            i -= 1

    # Case 2: Additions (only additions where we are the second part
    # interests us, this is checked already on startup)
    elif self.add and self.value &lt; 0:
        # Find the plus sign.
        i = begin - 1
        notFound = True
        while True:
            if self.originalString[i] == '+':
                # Re-create the string: 
                # - a '+' (instead of the minus)
                # - the spaces between the '-' and the constant
                # - the constant itself                    
                value = '-' + self.originalString[i+1:begin] + str(abs(self.value))
                range = (i,end-i)
                break
            i -= 1
    # Otherwise, it's a normal case. Note that here also, positive numbers
    # can turn negative, but no existing signs have to be changed.        
    else:
        value = str(self.value)
        range = (begin, end-begin)

    # The following textView methods make sure that an undo operation
    # is registered, so users can undo their drag.
    self.textView.shouldChangeTextInRange_replacementString_(range, value)
    self.textView.textStorage().replaceCharactersInRange_withString_(range, value)
    self.textView.didChangeText()
    self.textView.setNeedsDisplay_(True)
    self.textView.document.currentView.direct = False
    NSCursor.unhide()

</t>
<t tx="karstenw.20170704105126.8">def draw(self):
    mx,my=self.viewPoint

    x = mx-20
    w = 80
    h = 20
    h2 = h*2

    context = NSGraphicsContext.currentContext()
    aa = context.shouldAntialias()
    context.setShouldAntialias_(False)
    r = ((mx-w/2,my+12),(w,h))
    NSBezierPath.setDefaultLineWidth_(0)
    self.backgroundColor.set()
    NSBezierPath.fillRect_(r)
    self.strokeColor.set()
    NSBezierPath.strokeRect_(r)

    # A standard value just displays the value that you have been dragging.
    if not self.negative:
        v = str(self.value)
    # When the value is negative, we don't display a double negative,
    # but a positive.
    elif self.value &lt; 0:
        v = str(abs(self.value))
    # When the value is positive, we have to add a minus sign.
    else:
        v = "-" + str(self.value)

    NSString.drawInRect_withAttributes_(v, ((mx-w/2,my+14),(w,h2)), self.textAttributes)
    context.setShouldAntialias_(aa)

</t>
<t tx="karstenw.20170704105126.9">def mouseDragged_(self, event):
    mod = event.modifierFlags()
    newX, newY = NSEvent.mouseLocation()
    deltaX = newX-self.x
    delta = deltaX
    if self.negative:
        delta = -delta
    if mod &amp; NSAlternateKeyMask:
        delta /= 100.0
    elif mod &amp; NSShiftKeyMask:
        delta *= 10.0
    self.value = self.type(self.value + delta)
    self.x, self.y = newX, newY
    self.dirty = True
    self.textView.setNeedsDisplay_(True)
    self.textView.document.magicvar = self.value
    self.textView.document.currentView.direct = True
    self.textView.document.runScriptFast()

</t>
<t tx="karstenw.20170704105258.1"></t>
<t tx="karstenw.20170704105327.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170704105353.1">import os
import time
import datetime
import glob

import tempfile

import functools
cmp_to_key = functools.cmp_to_key

import random as librandom
choice = librandom.choice

import unicodedata

import pdb
import pprint
pp = pprint.pprint

import PIL
import numpy as np

import objc
import Foundation
import AppKit
import PyObjCTools.Conversion

from . import kgp


__all__ = (
    'grid', 'random', 'choice', 'files', 'autotext',
    '_copy_attr', '_copy_attrs',
    
    'datestring','makeunicode', 'filelist', 'imagefiles',
    
    'fontnames', 'fontfamilies',
    
    'voices', 'voiceattributes', 'anySpeakers', 'say',
    
    'imagepalette', 'aspectRatio', 'dithertypes', 'ditherimage',
    
    'sortlistfunction')


</t>
<t tx="karstenw.20170704105353.10">class FontRecord:
    @others
</t>
<t tx="karstenw.20170704105353.11">def __init__(self, psname, familyname, style, weight, traits, traitnames):
    self.psname = psname
    self.familyname = familyname
    self.style = style
    self.weight = weight
    self.traits = traits
    self.traitnames = traitnames
</t>
<t tx="karstenw.20170704105353.12">def __repr__(self):
    return (u'FontRecord( psname="%s", familyname="%s", style="%s", '
            u'weight=%.2f, traits="%s", traitnames=%s)') % (
                        self.psname, self.familyname, self.style,
                        self.weight, self.traits, self.traitnames)


</t>
<t tx="karstenw.20170704105353.13">def fontfamilies(flat=False):
    fm = AppKit.NSFontManager.sharedFontManager()
    l = fm.availableFontFamilies()

    def makeTraitsList( traits ):
        appleTraits = {
            0x00000001: u"italic",
            0x00000002: u"bold",
            0x00000004: u"unbold",
            0x00000008: u"nonstandardcharacterset",
            0x00000010: u"narrow",
            0x00000020: u"expanded",
            0x00000040: u"condensed",
            0x00000080: u"smallcaps",
            0x00000100: u"poster",
            0x00000200: u"compressed",
            0x00000400: u"fixedpitch",
            0x01000000: u"unitalic"}
        result = []
        keys = appleTraits.keys()
        for key in keys:
            if traits &amp; key == key:
                result.append( appleTraits[key])
        return result

    def makeFontRecord(fnt):
        psname, styl, weight, traits = fnt
        psname = makeunicode(psname)
        styl = makeunicode(styl)
        weight = float( weight )
        traits = int(traits)
        traitNames = makeTraitsList( traits )
        return FontRecord(psname, familyName, styl, weight, traits, traitNames)
        
    if flat:
        result = []
    else:
        result = {}
    for fn in l:
        familyName = makeunicode( fn )
        if not flat:
            result[familyName] = famfonts = {}

        subs = fm.availableMembersOfFontFamily_( familyName )
        for fnt in subs:
            fontRec = makeFontRecord( fnt )
            if not flat:
                result[familyName][fontRec.style] = fontRec
            else:
                result.append( fontRec )
    return result


</t>
<t tx="karstenw.20170704105353.14">def autotext(sourceFile):
    k = kgp.KantGenerator(sourceFile)
    return k.output()


</t>
<t tx="karstenw.20170704105353.15">def _copy_attr(v):
    if v is None:
        return None
    elif hasattr(v, "copy"):
        return v.copy()
    elif isinstance(v, list):
        return list(v)
    elif isinstance(v, tuple):
        return tuple(v)
    elif isinstance(v, (int, pstr, punicode, float, bool, long)):
        return v
    else:
        raise NodeBoxError("Don't know how to copy '%s'." % v)


</t>
<t tx="karstenw.20170704105353.16">def _copy_attrs(source, target, attrs):
    for attr in attrs:
        setattr(target, attr, _copy_attr(getattr(source, attr)))


</t>
<t tx="karstenw.20170704105353.2">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    if type(s) in ( int, long, float, bool ):
        s = str( s )
    if type(s) in ( pstr, ):
        s = punicode(s, srcencoding)

    if type(s) not in ( #pstr,
                    punicode,
                    Foundation.NSMutableAttributedString,
                    objc.pyobjc_unicode,
                    Foundation.NSMutableStringProxyForMutableAttributedString,
                    Foundation.NSString):
        #s = str(s)
        s = punicode(s, srcencoding)
    if type(s) not in (
            punicode,
            #Foundation.NSMutableAttributedString,
            #objc.pyobjc_unicode,
            #Foundation.NSMutableStringProxyForMutableAttributedString
            ):
        try:
            s = punicode(s, srcencoding)
        except TypeError as err:
            
            #print() 
            #print("makeunicode(): %s" % err)
            #print(repr(s))
            #print(type(s))
            #print()
            pass
    if type(s) in ( punicode,
                    #Foundation.NSMutableAttributedString,
                    #objc.pyobjc_unicode,
                    #Foundation.NSMutableStringProxyForMutableAttributedString,
                    #Foundation.NSString
                    ):
        s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20170704105353.3">def datestring(dt = None, dateonly=False, nospaces=True, nocolons=True):
    """Make an ISO datestring. The defaults are good for using the result of
    'datestring()' in a filename.
    """
    if not dt:
        now = str(datetime.datetime.now())
    else:
        now = str(dt)
    if not dateonly:
        now = now[:19]
    else:
        now = now[:10]
    if nospaces:
        now = now.replace(" ", "_")
    if nocolons:
        now = now.replace(":", "")
    return now


</t>
<t tx="karstenw.20170704105353.4">def grid(cols, rows, colSize=1, rowSize=1, shuffled=False):
    """Returns an iterator that contains coordinate tuples.
    
    The grid can be used to quickly create grid-like structures.
    A common way to use them is:
        for x, y in grid(10,10,12,12):
            rect(x,y, 10,10)
    """
    # Prefer using generators.
    rowRange = range( int(rows) )
    colRange = range( int(cols) )
    # Shuffled needs a real list, though.
    if (shuffled):
        rowRange = list(rowRange)
        colRange = list(colRange)
        librandom.shuffle(rowRange)
        librandom.shuffle(colRange)
    for y in rowRange:
        for x in colRange:
            yield (x*colSize, y*rowSize)


</t>
<t tx="karstenw.20170704105353.5">def random(v1=None, v2=None):
    """Returns a random value.
    
    This function does a lot of things depending on the parameters:
    - If one or more floats is given, the random value will be a float.
    - If all values are ints, the random value will be an integer.
    
    - If one value is given, random returns a value from 0 to the given value.
      This value is not inclusive.
    - If two values are given, random returns a value between the two; if two
      integers are given, the two boundaries are inclusive.
    """
    if v1 != None and v2 == None: # One value means 0 -&gt; v1
        if isinstance(v1, float):
            return librandom.random() * v1
        else:
            return int(librandom.random() * v1)
    elif v1 != None and v2 != None: # v1 -&gt; v2
        if isinstance(v1, float) or isinstance(v2, float):
            start = min(v1, v2)
            end = max(v1, v2)
            return start + librandom.random() * (end-start)
        else:
            start = min(v1, v2)
            end = max(v1, v2) + 1
            return int(start + librandom.random() * (end-start))
    else: # No values means 0.0 -&gt; 1.0
        return librandom.random()


</t>
<t tx="karstenw.20170704105353.6">def files(path="*"):
    """Returns a list of files.
    
    You can use wildcards to specify which files to pick, e.g.
        f = files('*.gif')
    """
    f = glob.glob(path)
    f = [makeunicode(t) for t in f]
    return f


</t>
<t tx="karstenw.20170704105353.7">def filelist( folderpathorlist, pathonly=True, extensions=None ):
    """Walk a folder or a list of folders and return
    paths or ((filepath, size, lastmodified, mode) tuples..
    """

    folders = folderpathorlist
    if type(folderpathorlist) in (pstr,):
        folderpathorlist = makeunicode( folderpathorlist )

    if type(folderpathorlist) in ( punicode, ):
        folders = [folderpathorlist]
    
    for folder in folders:
        folder = os.path.expanduser( folder )
        folder = os.path.abspath( folder )
        for root, dirs, files in os.walk( folder ):
            root = makeunicode( root )

            # skip if dir starts with '.'
            _, parentfolder = os.path.split(root)
            if parentfolder and parentfolder[0] == u".":
                continue

            for thefile in files:
                thefile = makeunicode( thefile )
                basename, ext = os.path.splitext(thefile)

                if extensions:
                    if ext.lower() not in extensions:
                        continue
                # exclude dotfiles
                if thefile.startswith('.'):
                    continue

                # exclude the specials
                for item in (u'\r', u'\n', u'\t'):
                    if item in thefile:
                        continue

                filepath = os.path.join( root, thefile )
                record = filepath
                if not pathonly:
                    islink = os.path.islink( filepath )
                    if islink:
                        info = os.lstat( filepath )
                    else:
                        info = os.stat( filepath )
                    lastmodified = datetime.datetime.fromtimestamp( info.st_mtime )
                    record = (filepath, info.st_size, lastmodified,
                              oct(info.st_mode), islink )
                yield record


</t>
<t tx="karstenw.20170704105353.8">def imagefiles( folderpathorlist, pathonly=True ):
    """Use filelist to extract all imagefiles"""
    
    filetuples = filelist( folderpathorlist, pathonly=pathonly )

    # 2017-06-23 - kw .eps dismissed
    extensions = tuple(".pdf .tif .tiff .gif .jpg .jpeg .png".split())
    for filetuple in filetuples:
        path = filetuple
        if not pathonly:
            path = filetuple[0]
        _, ext = os.path.splitext( path )
        if ext.lower() not in extensions:
            continue
        if pathonly:
            yield path
        else:
            yield filetuple


</t>
<t tx="karstenw.20170704105353.9">def fontnames():
    fm = AppKit.NSFontManager.sharedFontManager()
    l = fm.availableFonts()
    result = []
    for i in l:
        # filter out the weird fontnames
        if i.startswith(u'.'):
            continue
        result.append( makeunicode(i) )
    return result


</t>
<t tx="karstenw.20170704105406.1"></t>
<t tx="karstenw.20170704105412.1">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    print(genProgram())
</t>
<t tx="karstenw.20170704105416.1"></t>
<t tx="karstenw.20170704105442.1">@language python
@tabwidth -4
#!/usr/bin/env python2
@others
if __name__ == "__main__":
    main(sys.argv[1:])
</t>
<t tx="karstenw.20170704105455.1">"""Kant Generator for Python

Generates mock philosophy based on a context-free grammar

Usage: python kgp.py [options] [source]

Options:
  -g ..., --grammar=...   use specified grammar file or URL
  -h, --help              show this help
  -d                      show debugging information while parsing

Examples:
  kgp.py                  generates several paragraphs of Kantian philosophy
  kgp.py -g husserl.xml   generates several paragraphs of Husserl
  kpg.py "&lt;xref id='paragraph'/&gt;"  generates a paragraph of Kant
  kgp.py template.xml     reads from template.xml to decide what to generate

This program is part of "Dive Into Python", a free Python book for
experienced programmers.  Visit http://diveintopython.org/ for the
latest version.
"""

from __future__ import print_function

import sys
import os
import unicodedata


try:
    import urllib2
    urlopen = urllib2.urlopen
except ModuleNotFoundError:
    import urllib.request
    urlopen = urllib.request.urlopen
from xml.dom import minidom
import random
import getopt
import io
StringIO = io.StringIO


__author__ = "Mark Pilgrim (f8dy@diveintopython.org)"
__version__ = "$Revision: 1.3 $"
__date__ = "$Date: 2002/05/28 17:05:23 $"
__copyright__ = "Copyright (c) 2001 Mark Pilgrim"
__license__ = "Python"


_debug = 0


</t>
<t tx="karstenw.20170704105455.10">def reset(self):
    """reset parser"""
    self.pieces = []
    self.capitalizeNextWord = 0

</t>
<t tx="karstenw.20170704105455.11">def refresh(self):
    """reset output buffer, re-parse entire source file, and return output
    
    Since parsing involves a good deal of randomness, this is an
    easy way to get new output without having to reload a grammar file
    each time.
    """
    self.reset()
    self.parse(self.source)
    return self.output()

</t>
<t tx="karstenw.20170704105455.12">def output(self):
    """output generated text"""
    return "".join(self.pieces)

</t>
<t tx="karstenw.20170704105455.13">def randomChildElement(self, node):
    """choose a random child element of a node
    
    This is a utility method used by do_xref and do_choice.
    """
    choices = [e for e in node.childNodes
               if e.nodeType == e.ELEMENT_NODE]
    chosen = random.choice(choices)
    if _debug:
        sys.stderr.write('%s available choices: %s\n' % \
            (len(choices), [e.toxml() for e in choices]))
        sys.stderr.write('Chosen: %s\n' % chosen.toxml())
    return chosen

</t>
<t tx="karstenw.20170704105455.14">def parse(self, node):
    """parse a single XML node
    
    A parsed XML document (from minidom.parse) is a tree of nodes
    of various types.  Each node is represented by an instance of the
    corresponding Python class (Element for a tag, Text for
    text data, Document for the top-level document).  The following
    statement constructs the name of a class method based on the type
    of node we're parsing ("parse_Element" for an Element node,
    "parse_Text" for a Text node, etc.) and then calls the method.
    """
    parseMethod = getattr(self, "parse_%s" % node.__class__.__name__)
    parseMethod(node)

</t>
<t tx="karstenw.20170704105455.15">def parse_Document(self, node):
    """parse the document node
    
    The document node by itself isn't interesting (to us), but
    its only child, node.documentElement, is: it's the root node
    of the grammar.
    """
    self.parse(node.documentElement)

</t>
<t tx="karstenw.20170704105455.16">def parse_Text(self, node):
    """parse a text node
    
    The text of a text node is usually added to the output buffer
    verbatim.  The one exception is that &lt;p class='sentence'&gt; sets
    a flag to capitalize the first letter of the next word.  If
    that flag is set, we capitalize the text and reset the flag.
    """
    text = node.data
    if self.capitalizeNextWord:
        self.pieces.append(text[0].upper())
        self.pieces.append(text[1:])
        self.capitalizeNextWord = 0
    else:
        self.pieces.append(text)

</t>
<t tx="karstenw.20170704105455.17">def parse_Element(self, node):
    """parse an element
    
    An XML element corresponds to an actual tag in the source:
    &lt;xref id='...'&gt;, &lt;p chance='...'&gt;, &lt;choice&gt;, etc.
    Each element type is handled in its own method.  Like we did in
    parse(), we construct a method name based on the name of the
    element ("do_xref" for an &lt;xref&gt; tag, etc.) and
    call the method.
    """
    handlerMethod = getattr(self, "do_%s" % node.tagName)
    handlerMethod(node)

</t>
<t tx="karstenw.20170704105455.18">def parse_Comment(self, node):
    """parse a comment
    
    The grammar can contain XML comments, but we ignore them
    """
    pass

</t>
<t tx="karstenw.20170704105455.19">def do_xref(self, node):
    """handle &lt;xref id='...'&gt; tag
    
    An &lt;xref id='...'&gt; tag is a cross-reference to a &lt;ref id='...'&gt;
    tag.  &lt;xref id='sentence'/&gt; evaluates to a randomly chosen child of
    &lt;ref id='sentence'&gt;.
    """
    id = node.attributes["id"].value
    self.parse(self.randomChildElement(self.refs[id]))

</t>
<t tx="karstenw.20170704105455.2">def openAnything(source):
    """URI, filename, or string --&gt; stream

    This function lets you define parsers that take any input source
    (URL, pathname to local or network file, or actual data as a string)
    and deal with it in a uniform manner.  Returned object is guaranteed
    to have all the basic stdio read methods (read, readline, readlines).
    Just .close() the object when you're done with it.
    
    Examples:
    &gt;&gt;&gt; from xml.dom import minidom
    &gt;&gt;&gt; sock = openAnything("http://localhost/kant.xml")
    &gt;&gt;&gt; doc = minidom.parse(sock)
    &gt;&gt;&gt; sock.close()
    &gt;&gt;&gt; sock = openAnything("c:\\inetpub\\wwwroot\\kant.xml")
    &gt;&gt;&gt; doc = minidom.parse(sock)
    &gt;&gt;&gt; sock.close()
    &gt;&gt;&gt; sock = openAnything("&lt;ref id='conjunction'&gt;&lt;text&gt;and&lt;/text&gt;&lt;text&gt;or&lt;/text&gt;&lt;/ref&gt;")
    &gt;&gt;&gt; doc = minidom.parse(sock)
    &gt;&gt;&gt; sock.close()
    """
    if hasattr(source, "read"):
        return source
    
    if source == "-":
        return sys.stdin

    # try to open with urllib (if source is http, ftp, or file URL)
    try:
        return urlopen(source)
    except (IOError, OSError, ValueError):
        pass
    
    # try to open with native open function (if source is pathname)
    try:
        path = makeunicode( source )
        path = os.path.abspath( path )
        # return io.open(source, 'rb')
        return io.open(path, 'rb')

    except (IOError, OSError):
        pass
    
    # treat source as string
    return StringIO( makeunicode(source) )

</t>
<t tx="karstenw.20170704105455.20">def do_p(self, node):
    """handle &lt;p&gt; tag
    
    The &lt;p&gt; tag is the core of the grammar.  It can contain almost
    anything: freeform text, &lt;choice&gt; tags, &lt;xref&gt; tags, even other
    &lt;p&gt; tags.  If a "class='sentence'" attribute is found, a flag
    is set and the next word will be capitalized.  If a "chance='X'"
    attribute is found, there is an X% chance that the tag will be
    evaluated (and therefore a (100-X)% chance that it will be
    completely ignored)
    """
    keys = node.attributes.keys()
    if "class" in keys:
        if node.attributes["class"].value == "sentence":
            self.capitalizeNextWord = 1
    if "chance" in keys:
        chance = int(node.attributes["chance"].value)
        doit = (chance &gt; random.randrange(100))
    else:
        doit = 1
    if doit:
        for child in node.childNodes: self.parse(child)

</t>
<t tx="karstenw.20170704105455.21">def do_choice(self, node):
    """handle &lt;choice&gt; tag
    
    A &lt;choice&gt; tag contains one or more &lt;p&gt; tags.  One &lt;p&gt; tag
    is chosen at random and evaluated; the rest are ignored.
    """
    self.parse(self.randomChildElement(node))

</t>
<t tx="karstenw.20170704105455.22">def usage():
    print(__doc__)

</t>
<t tx="karstenw.20170704105455.23">def main(argv):
    grammar = "kant.xml"
    try:
        opts, args = getopt.getopt(argv, "hg:d", ["help", "grammar="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit()
        elif opt == '-d':
            global _debug
            _debug = 1
        elif opt in ("-g", "--grammar"):
            grammar = arg
    
    source = "".join(args)
    k = KantGenerator(grammar, source)
    print(k.output())

</t>
<t tx="karstenw.20170704105455.3">class NoSourceError(Exception): pass

</t>
<t tx="karstenw.20170704105455.4">class KantGenerator:
    """generates mock philosophy based on a context-free grammar"""
    
    @others
</t>
<t tx="karstenw.20170704105455.5">def __init__(self, grammar, source=None):
    self.loadGrammar(grammar)
    self.loadSource(source and source or self.getDefaultSource())
    self.refresh()

</t>
<t tx="karstenw.20170704105455.6">def _load(self, source):
    """load XML input source, return parsed XML document

    - a URL of a remote XML file ("http://diveintopython.org/kant.xml")
    - a filename of a local XML file ("~/diveintopython/common/py/kant.xml")
    - standard input ("-")
    - the actual XML document, as a string
    """
    sock = openAnything(source)
    xmldoc = minidom.parse(sock).documentElement
    sock.close()
    return xmldoc

</t>
<t tx="karstenw.20170704105455.7">def loadGrammar(self, grammar):
    """load context-free grammar"""
    self.grammar = self._load(grammar)
    self.refs = {}
    for ref in self.grammar.getElementsByTagName("ref"):
        self.refs[ref.attributes["id"].value] = ref
    
</t>
<t tx="karstenw.20170704105455.8">def loadSource(self, source):
    """load source"""
    self.source = self._load(source)

</t>
<t tx="karstenw.20170704105455.9">def getDefaultSource(self):
    """guess default source of the current grammar
    
    The default source will be one of the &lt;ref&gt;s that is not
    cross-referenced.  This sounds complicated but it's not.
    Example: The default source for kant.xml is
    "&lt;xref id='section'/&gt;", because 'section' is the one &lt;ref&gt;
    that is not &lt;xref&gt;'d anywhere in the grammar.
    In most grammars, the default source will produce the
    longest (and most interesting) output.
    """
    xrefs = {}
    for xref in self.grammar.getElementsByTagName("xref"):
        xrefs[xref.attributes["id"].value] = 1
    xrefs = xrefs.keys()
    standaloneXrefs = [e for e in self.refs.keys() if e not in xrefs]
    if not standaloneXrefs:
        raise NoSourceError("can't guess source, and no source specified")
    return '&lt;xref id="%s"/&gt;' % random.choice(standaloneXrefs)
    
</t>
<t tx="karstenw.20170704105528.1">from AppKit import NSFontManager

from nodebox.util import random, choice

COMP_WIDTH = 500
COMP_HEIGHT = 500

XCOORD = 1
YCOORD = 2
XSIZE = 3
YSIZE = 4
ROTATION = 5
SCALE = 6
CONTROLPOINT = 7
COLOR = 8
STROKEWIDTH = 9
LOOP = 10
GRIDDELTA = 12
GRIDCOUNT = 13
GRIDWIDTH = 14
GRIDHEIGHT = 15
SKEW = 16
STARPOINTS = 17

</t>
<t tx="karstenw.20170704105528.10">def genDraw(ctx):
    fn = choice((genRect,genOval,genArrow,genStar,genPath))
    return fn(ctx)

</t>
<t tx="karstenw.20170704105528.11">def genRect(ctx):
    return ctx.spaces() + """rect(%s,%s,%s,%s)\n"""  % (
        nr(ctx,XCOORD),nr(ctx,YCOORD),nr(ctx,XSIZE),nr(ctx,YSIZE))

</t>
<t tx="karstenw.20170704105528.12">def genOval(ctx):
    return ctx.spaces() + """oval(%s,%s,%s,%s)\n"""  % (
        nr(ctx,XCOORD),nr(ctx,YCOORD),nr(ctx,XSIZE),nr(ctx,YSIZE))

</t>
<t tx="karstenw.20170704105528.13">def genArrow(ctx):
    return ctx.spaces() + """arrow(%s,%s,%s)\n""" % (
        nr(ctx,XCOORD),nr(ctx,YCOORD),nr(ctx,XSIZE))
        
</t>
<t tx="karstenw.20170704105528.14">def genStar(ctx):
    return ctx.spaces() + """star(%s,%s,%s,%s,%s)\n""" % (
        nr(ctx,XCOORD),nr(ctx,YCOORD),nr(ctx,STARPOINTS),nr(ctx,XSIZE),nr(ctx,XSIZE))

</t>
<t tx="karstenw.20170704105528.15">def genPath(ctx):
    s = ctx.spaces() + """beginpath(%s,%s)\n""" % (
        nr(ctx,XCOORD),nr(ctx,YCOORD))
    for i in range(random(1,10)):
        s += genPathDraw(ctx)
    s += ctx.spaces() + """endpath()\n"""
    return s
        
</t>
<t tx="karstenw.20170704105528.16">def genPathDraw(ctx):
    fn = choice((genLineto, genCurveto))
    return fn(ctx)

</t>
<t tx="karstenw.20170704105528.17">def genLineto(ctx):
    return ctx.spaces() + """lineto(%s,%s)\n""" % (nr(ctx,XCOORD),nr(ctx,YCOORD))
    
</t>
<t tx="karstenw.20170704105528.18">def genCurveto(ctx):
    return ctx.spaces() + """curveto(%s,%s,%s,%s,%s,%s)\n""" % (
        nr(ctx,XCOORD),nr(ctx,YCOORD),nr(ctx,CONTROLPOINT),nr(ctx,CONTROLPOINT),nr(ctx,CONTROLPOINT),nr(ctx,CONTROLPOINT))

### TRANSFORM ###

</t>
<t tx="karstenw.20170704105528.19">def genTransform(ctx):
    fn = choice((genRotate, genTranslate, genScale, genSkew, genReset))
    return fn(ctx)
    
</t>
<t tx="karstenw.20170704105528.2">class Context:
    @others
</t>
<t tx="karstenw.20170704105528.20">def genRotate(ctx):
    return ctx.spaces() + """rotate(%s)\n""" % nr(ctx,ROTATION)
    
</t>
<t tx="karstenw.20170704105528.21">def genTranslate(ctx):
    return ctx.spaces() + """translate(%s,%s)\n""" % (nr(ctx,XCOORD), nr(ctx,YCOORD))
    
</t>
<t tx="karstenw.20170704105528.22">def genScale(ctx):
    return ctx.spaces() + """scale(%s)\n""" % (nr(ctx,SCALE))

</t>
<t tx="karstenw.20170704105528.23">def genSkew(ctx):
    return ctx.spaces() + """skew(%s)\n""" % (nr(ctx,SKEW))
    
</t>
<t tx="karstenw.20170704105528.24">def genReset(ctx):
    return ctx.spaces() + """reset()\n"""
    
### COLOR ###

</t>
<t tx="karstenw.20170704105528.25">def genColor(ctx):
    fn = choice((genFill,genFill,genFill,genFill,genFill,genFill,genStroke,genStroke,genStroke,genNofill,genNostroke,genStrokewidth))
    return fn(ctx)
    
</t>
<t tx="karstenw.20170704105528.26">def genFill(ctx):
    return ctx.spaces() + """fill(%s,%s,%s,%s)\n""" % (nr(ctx,COLOR),nr(ctx,COLOR), nr(ctx,COLOR), nr(ctx,COLOR))

</t>
<t tx="karstenw.20170704105528.27">def genStroke(ctx):
    return ctx.spaces() + """stroke(%s,%s,%s,%s)\n""" % (nr(ctx,COLOR), nr(ctx,COLOR), nr(ctx,COLOR), nr(ctx,COLOR))
    
</t>
<t tx="karstenw.20170704105528.28">def genNofill(ctx):
    return ctx.spaces() + """nofill()\n"""

</t>
<t tx="karstenw.20170704105528.29">def genNostroke(ctx):
    return ctx.spaces() + """nostroke()\n"""
    
</t>
<t tx="karstenw.20170704105528.3">def __init__(self):
    self._indent = 0
    self._grid = False
    
</t>
<t tx="karstenw.20170704105528.30">def genStrokewidth(ctx):
    return ctx.spaces() + """strokewidth(%s)\n""" % nr(ctx,STROKEWIDTH)
    
### LOOP ###
</t>
<t tx="karstenw.20170704105528.31">def genLoop(ctx):
    fn = choice((genFor, genGrid))
    return fn(ctx)
    
</t>
<t tx="karstenw.20170704105528.32">def genFor(ctx):
    if ctx._indent &gt;= 2: return ""
    s = ctx.spaces() + """for i in range(%s):\n""" % nr(ctx,LOOP)
    ctx.indent()    
    for i in range(random(5)):
        s += genStatement(ctx)
    s += genVisual(ctx)
    ctx.dedent()
    return s
    
</t>
<t tx="karstenw.20170704105528.33">def genGrid(ctx):
    if ctx.inGrid(): return ""
    s = ctx.spaces() + """for x, y in grid(%s,%s,%s,%s):\n""" % (nr(ctx,GRIDCOUNT), nr(ctx,GRIDCOUNT), nr(ctx,GRIDWIDTH), nr(ctx,GRIDHEIGHT))
    ctx.indent()
    ctx._grid = True
    for i in range(random(5)):
        s += genStatement(ctx)
    s += genVisual(ctx)
    ctx.dedent()
    ctx._grid = False
    return s    

### MAIN ###

</t>
<t tx="karstenw.20170704105528.34">def genVisual(ctx):
    fn = choice((genDraw,))
    return fn(ctx)
    
</t>
<t tx="karstenw.20170704105528.35">def genStatement(ctx):
    fn = choice((genVisual,genLoop,genColor,genTransform))
    return fn(ctx)

</t>
<t tx="karstenw.20170704105528.36">def genProgram():
    s = """# This code is generated with OTTOBOT,
# the automatic NodeBox code generator.
size(%s, %s)
translate(%s, %s)
colormode(HSB)
""" % (COMP_WIDTH, COMP_HEIGHT, COMP_WIDTH/2, COMP_HEIGHT/2)
    ctx = Context()
    for i in range(random(10,20)):
        s += genStatement(ctx)
    return s

</t>
<t tx="karstenw.20170704105528.4">def indent(self):
    self._indent += 1

</t>
<t tx="karstenw.20170704105528.5">def dedent(self):
    self._indent -= 1
    
</t>
<t tx="karstenw.20170704105528.6">def spaces(self):
    return "    " * self._indent
    
</t>
<t tx="karstenw.20170704105528.7">def inGrid(self):
    return self._grid

</t>
<t tx="karstenw.20170704105528.8">def nrReally(ctx, numberclass):
    if numberclass == XCOORD:
        if ctx.inGrid():
            #return "x"
            return "x + %s" % nr(ctx,GRIDDELTA)
        else:
            return random(-COMP_WIDTH/2,COMP_WIDTH/2)
    elif numberclass == YCOORD:
        if ctx.inGrid():
            #return "y"
            return "y + %s" % nr(ctx,GRIDDELTA)
        else:
            return random(-COMP_HEIGHT/2,COMP_HEIGHT/2)
    elif numberclass == XSIZE:
        return random(0,COMP_WIDTH)
    elif numberclass == YSIZE:
        return random(0,COMP_HEIGHT)
    elif numberclass == ROTATION:
        return random(0,360)
    elif numberclass == SCALE:
        return random(0.5,1.5)
    elif numberclass == CONTROLPOINT:
        return random(-100,100)
    elif numberclass == COLOR:
        return random()
    elif numberclass == STROKEWIDTH:
        return random(1,20)
    elif numberclass == LOOP:
        return random(2, 20)
    elif numberclass == GRIDDELTA:
        return random(-100,100)
    elif numberclass == GRIDCOUNT:
        return random(2, 10)
    elif numberclass == GRIDWIDTH:
        return 20
        return random(1,100)
    elif numberclass == GRIDHEIGHT:
        return 20
        return random(1, 100)
    elif numberclass == SKEW:
        return random(1,80)
    elif numberclass == STARPOINTS:
        return random(2,100)
        
</t>
<t tx="karstenw.20170704105528.9">def nr(ctx, numberclass):
    if not ctx.inGrid() and random() &gt; 0.5:
        return "random(%s)" % nrReally(ctx, numberclass)
    else:
        return "%s" % nrReally(ctx, numberclass)

### DRAWING COMMANDS ###

</t>
<t tx="karstenw.20170704105534.1"></t>
<t tx="karstenw.20170704105551.1">@language python
@tabwidth -4
@others
if __name__=='__main__':
    test()
</t>
<t tx="karstenw.20170704105603.1">import os
import tempfile
import Foundation
NSNumber = Foundation.NSNumber

import AppKit
NSImage = AppKit.NSImage
NSApplication = AppKit.NSApplication
NSColor = AppKit.NSColor
NSData = AppKit.NSData
NSBitmapImageRep = AppKit.NSBitmapImageRep
NSJPEGFileType = AppKit.NSJPEGFileType

import QTKit
QTMovie = QTKit.QTMovie
# QTDataReference = QTKit.QTDataReference
# QTMovieFileNameAttribute = QTKit.QTMovieFileNameAttribute
QTMakeTimeRange = QTKit.QTMakeTimeRange
QTMakeTime = QTKit.QTMakeTime
QTMovieEditableAttribute = QTKit.QTMovieEditableAttribute
QTAddImageCodecType = QTKit.QTAddImageCodecType
QTMovieFlatten = QTKit.QTMovieFlatten

</t>
<t tx="karstenw.20170704105603.2">class Movie(object):

    @others
</t>
<t tx="karstenw.20170704105603.3">def __init__(self, fname, fps=30):
    if os.path.exists(fname):
        os.remove(fname)
    self.frame = 1
    self.fname = fname
    self.tmpfname = None
    self.firstFrame = True
    self.movie = None
    self.fps = fps
    self._time = QTMakeTime(int(600/self.fps), 600)
    
</t>
<t tx="karstenw.20170704105603.4">def add(self, canvas_or_context):
    if self.movie is None:
        # The first frame will be written to a temporary png file,
        # then opened as a movie file, then saved again as a movie.
        handle, self.tmpfname = tempfile.mkstemp('.tiff')
        canvas_or_context.save(self.tmpfname)
        try:
            movie, err = QTMovie.movieWithFile_error_(self.tmpfname, None)
            movie.setAttribute_forKey_(NSNumber.numberWithBool_(True), QTMovieEditableAttribute)
            range = QTMakeTimeRange(QTMakeTime(0,600), movie.duration())
            movie.scaleSegment_newDuration_(range, self._time)
            if err is not None:
                raise str(err)
            movie.writeToFile_withAttributes_(self.fname, {QTMovieFlatten:True})
            self.movie, err = QTMovie.movieWithFile_error_(self.fname, None)
            self.movie.setAttribute_forKey_(NSNumber.numberWithBool_(True), QTMovieEditableAttribute)
            if err is not None:
                raise str(err)
            self.imageTrack = self.movie.tracks()[0]
        finally:
            os.remove(self.tmpfname)
    else:
        try:
            canvas_or_context.save(self.tmpfname)
            img = NSImage.alloc().initByReferencingFile_(self.tmpfname)
            self.imageTrack.addImage_forDuration_withAttributes_(img, self._time, {QTAddImageCodecType:'tiff'})
        finally:
            try:
                os.remove(self.tmpfname)
            except OSError as err:
                print(err)
                # pass
    self.frame += 1
            
</t>
<t tx="karstenw.20170704105603.5">def save(self):
    self.movie.updateMovieFile()



</t>
<t tx="karstenw.20170704105603.6">def test():
    import sys
    sys.path.insert(0, '../..')
    sys.path.insert(0, '../../..')
    from nodebox.graphics import Canvas, Context
    from math import sin

    NSApplication.sharedApplication().activateIgnoringOtherApps_(0)
    w, h = 500, 300
    m = Movie("xx3.mov")
    for i in range(200):
        print("Frame %i" % i)
        ctx = Context()
        ctx.size(w, h)
        ctx.rect(100.0+sin(i/10.0)*100.0,i/2.0,100,100)
        ctx.text(str(i), i*2, 200)
        m.add(ctx)
    m.save()
    
</t>
<t tx="karstenw.20170704105619.1">@language python
@tabwidth -4
@others
if __name__=='__main__':
    import sys
    if len(sys.argv) &lt; 3:
        usage()
    else:
        fname1 = sys.argv[1]
        fname2 = sys.argv[2]
        try:
            threshold = int(sys.argv[3])
        except:
            threshold = 0
        statistics(fname1, fname2, threshold)
</t>
<t tx="karstenw.20170704105642.1">import os
import PIL.Image as Image

HTML_HEADER = r'''
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;Vdiff Test Results&lt;/title&gt;
&lt;style type="text/css" media="all"&gt;
body { margin: 20px 0 20px 150px; }
body, td, th { font: 11px/1.5em "Lucida Grande", sans-serif; }
h1 { font-size: 160%; padding: 0; margin: 0em 0 -2em 0; }
h2 { font-size: 130%; padding: 0; margin: 4em 0 0.2em 0; clear:both; }
img { float: left; border: 1px solid #000; margin: 2px; }
.different table { background: red; }
table.statistics { margin:2px; width:16em; border:1px solid #666; }
table.statistics td { font-weight: bold; text-align: right; padding: 2px 5px; }
table.statistics td + td { font-weight: normal; text-align: left; }
tr.even { background: #eee; }
tr.odd { background: #ddd; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;vdiff tests&lt;/h1&gt;
'''

HTML_FOOTER = r'''
&lt;/body&gt;
&lt;/html&gt;
'''

</t>
<t tx="karstenw.20170704105642.10">def calculate(self):
    diff = self.differences

    total_delta = 0
    max_delta = 0
    for pos, d1, d2, delta in diff:
        total_delta += delta
        max_delta = max(max_delta, delta)
    self.total_delta = total_delta
    self.max_delta = max_delta
    self.mean = mean = total_delta / float(self.width * self.height)

    stdev = 0
    for pos, d1, d2, delta in diff:
        stdev += pow(delta-mean, 2)
    stdev /= float(self.width * self.height)
    self.stdev = stdev

</t>
<t tx="karstenw.20170704105642.11">def _get_size(self):
    return self.width, self.height
size = property(_get_size)

</t>
<t tx="karstenw.20170704105642.12">def _get_number_of_differences(self):
    return len(self.differences)
number_of_differences = property(_get_number_of_differences)

</t>
<t tx="karstenw.20170704105642.13">def _get_comparison_image(self):
    if self._comparison_image is None:
        self._comparison_image = make_comparison_image(self.size, self.differences)
    return self._comparison_image
comparison_image = property(_get_comparison_image)

</t>
<t tx="karstenw.20170704105642.14">def save_comparison_image(self, fname):
    self.comparison_image.save(fname)
    self.comparison_image_fname = fname

</t>
<t tx="karstenw.20170704105642.15">def __str__(self):
    return "&lt;Statistics diff:%s total_delta:%s max_delta:%s mean:%.4f stdev:%.4f&gt;" % (
        len(self.differences), self.total_delta, self.max_delta, self.mean, self.stdev)

</t>
<t tx="karstenw.20170704105642.16">def statistics(fname1, fname2, threshold=0):    
    diff = visual_diff(fname1, fname2)    
    stats = Statistics(fname1, fname2, diff)

    print( "Differences:", len(stats.differences) )
    print( "Total delta:", stats.total_delta )
    print( "Max delta:", stats.max_delta )
    print( "Mean:", stats.mean )
    print( "Stdev:", stats.stdev )

    stats.comparison_image.save('cmp.png')
    
</t>
<t tx="karstenw.20170704105642.17">def test_vdiff(self):
    #fname1 = 'vdiff-tests/001-added-square/original.png'
    #fname2 = 'vdiff-tests/001-added-square/bluesquare.png'

    #fname1 = 'vdiff-tests/002-antialiased-text/preview.png'
    #fname2 = 'vdiff-tests/002-antialiased-text/photoshop.png'

    #fname1 = 'vdiff-tests/003-movement/original.png'
    #fname2 = 'vdiff-tests/003-movement/moved.png'

    #fname1 = 'vdiff-tests/004-color/original.png'
    #fname2 = 'vdiff-tests/004-color/darker.png'

    #fname1 = 'vdiff-tests/005-antialiased-text/none.png'
    #fname2 = 'vdiff-tests/005-antialiased-text/smooth.png'

    #fname1 = 'vdiff-tests/006-totally-different/ant.png'
    #fname2 = 'vdiff-tests/006-totally-different/people.png'

    fname1 = 'vdiff-tests/007-black-white/black.png'
    fname2 = 'vdiff-tests/007-black-white/white.png'
    
    statistics(fname1, fname2)
    
</t>
<t tx="karstenw.20170704105642.18">def usage():
    print( """vdiff -- visually compare images
Usage: vdiff &lt;image1&gt; &lt;image2&gt; [threshold]""" )

</t>
<t tx="karstenw.20170704105642.2">def format_stats(stats):
    if stats.number_of_differences &gt; 0:
        clz = " different"
    else:
        clz = ""

    html  = """&lt;h2&gt;%s&lt;/h2&gt;\n""" % stats.name
    html += """&lt;div class="stats%s"&gt;""" % clz
    html += """&lt;a href="%s" target="_blank"&gt;&lt;img src="%s" width="150" height="150"&gt;&lt;/a&gt;\n""" % (stats.fname1, stats.fname1)
    html += """&lt;a href="%s" target="_blank"&gt;&lt;img src="%s" width="150" height="150"&gt;&lt;/a&gt;\n""" % (stats.fname2, stats.fname2)
    if stats.comparison_image_fname is not None:
        html += """&lt;a href="%s" target="_blank"&gt;&lt;img class="compare" src="%s" width="150" height="150"&gt;&lt;/a&gt;\n""" % (stats.comparison_image_fname, stats.comparison_image_fname)
    html += """&lt;table class="statistics" height="152"&gt;\n"""
    html += """&lt;tr class="odd"&gt;&lt;td&gt;Differences:&lt;/td&gt;&lt;td&gt;%i&lt;/td&gt;&lt;/tr&gt;\n""" % len(stats.differences)
    html += """&lt;tr class="even"&gt;&lt;td&gt;Total delta:&lt;/td&gt;&lt;td&gt;%i&lt;/td&gt;&lt;/tr&gt;\n""" % stats.total_delta
    html += """&lt;tr class="odd"&gt;&lt;td&gt;Max delta:&lt;/td&gt;&lt;td&gt;%i&lt;/td&gt;&lt;/tr&gt;\n""" % stats.max_delta
    html += """&lt;tr class="even"&gt;&lt;td&gt;Mean:&lt;/td&gt;&lt;td&gt;%.4f&lt;/td&gt;&lt;/tr&gt;\n""" % stats.mean
    html += """&lt;tr class="odd"&gt;&lt;td&gt;Stdev:&lt;/td&gt;&lt;td&gt;%.4f&lt;/td&gt;&lt;/tr&gt;\n""" % stats.stdev
    html += """&lt;/table&gt;\n"""
    html += """&lt;/div&gt;"""
    return html
    
</t>
<t tx="karstenw.20170704105642.3">def format_stats_list(stats_list):
    html = HTML_HEADER
    for stats in stats_list:
        html += format_stats(stats)
    html += HTML_FOOTER
    return html

</t>
<t tx="karstenw.20170704105642.4">def compare_pixel(px1, px2):
    if px1 == px2:
        return 0
    r1, g1, b1, a1 = px1
    r2, g2, b2, a2 = px2
    return abs(r1-r2) + abs(g1-g2) + abs(b1-b2) + abs(a1-a2)

</t>
<t tx="karstenw.20170704105642.5">def visual_diff(img1, img2, threshold=0, stop_on_diff=False):
    if isinstance(img1, str) or isinstance(img1, unicode):
        img1 = Image.open(img1)
        img1 = img1.convert("RGBA")
    if isinstance(img2, str) or isinstance(img2, unicode):
        img2 = Image.open(img2)
        img2 = img2.convert("RGBA")
    assert img1.size == img2.size
    w, h = img1.size
    data1 = img1.getdata()
    data2 = img2.getdata()
    size = len(data1)
    differences = []
    for i in range(size):
        delta = compare_pixel(data1[i], data2[i])
        if delta &gt; threshold:
            x = i % w
            y = i / w
            differences.append( ( (x, y), data1[i], data2[i], delta ) )
            if stop_on_diff:
                # print data1[i], data2[i]
                break
    return differences
    
</t>
<t tx="karstenw.20170704105642.6">def make_comparison_image(size, differences):
    img = Image.new("L", size, color=255)
    for pos, d1, d2, delta in differences:
        img.putpixel(pos, 255-delta)
    return img

</t>
<t tx="karstenw.20170704105642.7">def isEqual(fname1, fname2, threshold=0):
    diff = visual_diff(fname1, fname2, threshold, stop_on_diff=True)
    if len(diff) == 0:
        return True
    return False
    
</t>
<t tx="karstenw.20170704105642.8">class Statistics(object):
    @others
</t>
<t tx="karstenw.20170704105642.9">def __init__(self, fname1, fname2, differences=None, name=""):
    self.fname1 = fname1
    self.fname2 = fname2
    if differences is None:
        differences = visual_diff(fname1, fname2)
    self.differences = differences
    self.name = name

    img1 = Image.open(fname1)
    self.width, self.height = img1.size
    
    self._comparison_image = None
    self.comparison_image_fname = None
    self.calculate()
    
</t>
<t tx="karstenw.20170704105701.1"></t>
<t tx="karstenw.20170709143221.1">### Variables ###

</t>
<t tx="karstenw.20170709143242.1"></t>
<t tx="karstenw.20170709143301.1"></t>
<t tx="karstenw.20170709143318.1"></t>
<t tx="karstenw.20170709143341.1"></t>
<t tx="karstenw.20170709143354.1"></t>
<t tx="karstenw.20170709143414.1"></t>
<t tx="karstenw.20170709143458.1"></t>
<t tx="karstenw.20170709143553.1"></t>
<t tx="karstenw.20170709143618.1"></t>
<t tx="karstenw.20170709143636.1"></t>
<t tx="karstenw.20170709143705.1"></t>
<t tx="karstenw.20170709143724.1"></t>
<t tx="karstenw.20170709145427.1">def menuSelected_(self, sender):
    var = self.document.vars[sender.tag()]
    sel = sender.titleOfSelectedItem()
    var.value = sel
    fn = var.handler
    if var.handler:
        args = [sel,var.name]
        argcount = getFunctionArgCount( var.handler )
        if argcount &lt; 2:
            args = [sel]
        self.document.fastRun_newSeed_args_(fn, False, args)
    #self.document.runFunction_(var.name)

</t>
<t tx="karstenw.20170709145531.1">def addMenu_idx_frame_(self, v, cnt, frame):
    (x,y),(w,h) = frame
    
    control = NSPopUpButton.alloc().init()
    control.setFrame_( frame ) #((108, y-2),(172,16)) )
    control.setPullsDown_( False )
    control.removeAllItems()
    if v.menuitems is not None:
        for title in v.menuitems:
            control.addItemWithTitle_( title )
    control.setTitle_(v.value)
    control.synchronizeTitleAndSelectedItem()
    control.setBezelStyle_(1)
    control.setFont_(SMALL_FONT)
    control.cell().setControlSize_(NSMiniControlSize)
    control.cell().setControlTint_(NSGraphiteControlTint)
    control.setTarget_(self)
    control.setTag_(cnt)
    control.setAction_(objc.selector(self.menuSelected_, signature=b"v@:@@"))
    control.setAutoresizingMask_( AppKit.NSViewWidthSizable ) # + AppKit.NSViewMinYMargin )
    self.panel.contentView().addSubview_(control)
    return control

</t>
<t tx="karstenw.20170709154311.1">def fastRun_newSeed_args_(self, fn, newSeed = False, args=[]):
    # pdb.set_trace()
    # Check if there is code to run
    if self._code is None:
        return False

    # Clear the canvas
    self.canvas.clear()

    # Generate a new seed, if needed
    if newSeed:
        self._seed = time.time()
    random.seed(self._seed)

    # Set the mouse position
    
    # kw fix
    if not self.currentView:
        self.currentView = self.graphicsView

    window = self.currentView.window()
    pt = window.mouseLocationOutsideOfEventStream()
    mx, my = window.contentView().convertPoint_toView_(pt, self.currentView)

    # Hack: mouse coordinates are flipped vertically in FullscreenView.
    # This flips them back.
    if isinstance(self.currentView, FullscreenView):
        my = self.currentView.bounds()[1][1] - my
    if self.fullScreen is None:
        mx /= self.currentView.zoom
        my /= self.currentView.zoom
    self.namespace["MOUSEX"] = mx
    self.namespace["MOUSEY"] = my
    self.namespace["mousedown"] = self.currentView.mousedown
    self.namespace["keydown"] = self.currentView.keydown
    self.namespace["key"] = self.currentView.key
    self.namespace["keycode"] = self.currentView.keycode
    self.namespace["scrollwheel"] = self.currentView.scrollwheel
    self.namespace["wheeldelta"] = self.currentView.wheeldelta

    # Reset the context
    self.context._resetContext()

    # Initalize the magicvar
    self.namespace[MAGICVAR] = self.magicvar

    # Set the pagenum
    self.namespace['PAGENUM'] = self._pageNumber
    
    # Set the frame
    self.namespace['FRAME'] = self._frame

    if 0:
        pp(self.namespace)

    # Run the script
    success, output = self.boxedRun_args_(fn, args)
    self.flushOutput_(output)
    if not success:
        return False

    # Display the output of the script
    self.currentView.setCanvas_(self.canvas)

    return True
    

</t>
<t tx="karstenw.20170726133907.1">try:
    import bwdithering
    dither = bwdithering.dither

except ImportError as err:
    print()
    print( '-' * 40 )
    print()
    print( err )
    print()
    print( '-' * 40 )
    print()
    def dither(*args):
        print( "You lost." )

try:
    import fractal
    fractalimage = fractal.fractalimage
except ImportError as err:
    print()
    print( '-' * 40 )
    print()
    print( err )
    print()
    print( '-' * 40 )
    print()
    def fractalimage(*args):
        print( "You lost." )


</t>
<t tx="karstenw.20170726154241.1">
</t>
<t tx="karstenw.20170726154315.1">try:
    # Faster C versions.
    import cGeo
    isqrt = inverse_sqrt = cGeo.fast_inverse_sqrt
    angle = cGeo.angle
    distance = cGeo.distance
    coordinates = cGeo.coordinates

except ImportError:
    def inverse_sqrt(x):
        return 1.0 / math.sqrt(x)

    isqrt = inverse_sqrt

    def angle(x0, y0, x1, y1):
        return math.degrees( math.atan2(y1-y0, x1-x0) )

    def distance(x0, y0, x1, y1):
        return math.sqrt(math.pow(x1-x0, 2) + math.pow(y1-y0, 2))
    
    def coordinates(x0, y0, distance, angle):
        x1 = x0 + math.cos(math.radians(angle)) * distance
        y1 = y0 + math.sin(math.radians(angle)) * distance
        return x1, y1


</t>
<t tx="karstenw.20170727100220.1"># Zoom commands, forwarding to the graphics view.
</t>
<t tx="karstenw.20170801052347.1">def voices():
    """Return a list of voice names."""
    vcs = AppKit.NSSpeechSynthesizer.availableVoices()
    vcs = [makeunicode(t) for t in vcs]
    vcs = [x.replace(u"com.apple.speech.synthesis.voice.", u"") for x in vcs]
    return vcs


</t>
<t tx="karstenw.20170801052423.1">def say(txt, voice=None, outfile=None, wait=True):
    """Say txt with a voice. Write AIFF file to outfile if parent(outfile) exists.
    defer return if wait is True.
    """
    global g_voicetrash
    if voice and voice in voices():
        voice = u"com.apple.speech.synthesis.voice.%s" % (voice,)
    else:
        voice = AppKit.NSSpeechSynthesizer.defaultVoice()
    
    # outfile is a path to an AIFF file to be exported to
    # if the containing folder does not exist, abort
    path = url = None
    if outfile:
        path = os.path.abspath( makeunicode(outfile) )
        folder, filename = os.path.split( path )
        if not os.path.exists( folder ):
            path = None

    if path:
        url = Foundation.NSURL.fileURLWithPath_isDirectory_( path, False )
    speaker = AppKit.NSSpeechSynthesizer.alloc().initWithVoice_(voice)

    if speaker and url:
        g_voicetrash.append( speaker )
        speaker.startSpeakingString_toURL_(txt, url)
        return speaker

    if speaker:
        if wait:
            while anySpeakers():
                time.sleep(0.1)
        # it is importatnt that speaker gets added AFTER anySpeakers()
        # it does garbage collection
        g_voicetrash.append( speaker )
        speaker.startSpeakingString_(txt)
        return speaker


</t>
<t tx="karstenw.20170804122600.1">def voiceattributes(voice):
    """Return a dict with attributes for voice.
    
    voice is passed without the 'com.apple.speech.synthesis.voice.' prefix, e.g.
    'Albert' or 'petra.premium'.
    """
    result = {}
    if voice and voice in voices():
        voice = u"com.apple.speech.synthesis.voice.%s" % (voice,)
        attrs = AppKit.NSSpeechSynthesizer.attributesForVoice_( voice )
        result = PyObjCTools.Conversion.pythonCollectionFromPropertyList(attrs)
        keys = result.keys()
        # this crashes
        #for key  in keys:
        #    result[key] = makeunicode(result[key])
    return result


</t>
<t tx="karstenw.20170804122614.1">g_voicetrash = []

_dithertypes = {
    'atkinson': 1,
    'floyd-steinberg': 2,
    'jarvis-judice-ninke': 3,
    'stucki': 4,
    'burkes': 5,
    'sierra-1': 6,
    'sierra-2': 7,
    'sierra-3': 8,
}

_ditherIDs = _dithertypes.values()



</t>
<t tx="karstenw.20170804123557.1">def anySpeakers():
    """Return if ANY application is currently speaking."""
    global g_voicetrash

    b = bool(AppKit.NSSpeechSynthesizer.isAnyApplicationSpeaking())
    if b is False:
        # empty accumulated voices
        while len(g_voicetrash) &gt; 0:
            f = g_voicetrash.pop()
            del f
    return b


</t>
<t tx="karstenw.20170804151930.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170804152129.1">"""
Script for building NodeBox

Usage:
    python setup.py py2app
"""
from distutils.core import setup
from setuptools.extension import Extension

import py2app

import nodebox

NAME = 'NodeBox extended'
VERSION = nodebox.__version__


AUTHOR = "Frederik De Bleser",
AUTHOR_EMAIL = "frederik@pandora.be",
URL = "http://nodebox.net/",
CLASSIFIERS = (
    "Development Status :: 5 - Production/Stable",
    "Environment :: MacOS X :: Cocoa",
    "Intended Audience :: Developers",
    "Intended Audience :: Education",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: MacOS :: MacOS X",
    "Programming Language :: Python",
    "Topic :: Artistic Software",
    "Topic :: Multimedia :: Graphics",
    "Topic :: Multimedia :: Graphics :: Editors :: Vector-Based",
    "Topic :: Multimedia :: Video",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
    "Topic :: Software Development :: User Interfaces",
    "Topic :: Text Editors :: Integrated Development Environments (IDE)",
)

DESCRIPTION = (u"Simple application for creating 2-dimensional graphics "
               u"and animation using Python code")
LONG_DESCRIPTION = u"""NodeBox is a Mac OS X application that allows you to create visual output
with programming code. The application targets an audience of designers, with an easy set of state 
commands that is both intuitive and creative. It is essentially a learning environment and an automation tool.

The current version features:

* State-based graphics context
* Extensive reference documentation and tutorials
* PDF export for graphics
* QuickTime export for animations
* Manipulate every numeric variable in a script by command-dragging it, even during animation
* Creating simple user interfaces using text fields, sliders, and buttons
* Stop a running script by typing command-period
* Universal Binary
* Integrated bezier mathematics and boolean operations
* Command-line interface
* Zooming
"""



creator = 'NdBx'
bundleID = "net.nodebox.NodeBox"

setup(
    
    name = NAME,
    version = VERSION,
    description = DESCRIPTION,
    long_description = LONG_DESCRIPTION,
    author = AUTHOR,
    author_email = AUTHOR_EMAIL,
    url = URL,
    classifiers = CLASSIFIERS,

    app=[{
        'script': "macboot.py",

        "plist": {
            "NSPrincipalClass": 'NSApplication',
            "CFBundleIdentifier": bundleID,
            "CFBundleName": NAME,
            "CFBundleSignature": creator,
            "CFBundleShortVersionString": VERSION,
            "CFBundleGetInfoString": DESCRIPTION,
            "NSHumanReadableCopyright": "Copyright (c) 2015 Frederik De Bleser",

            'CFBundleDocumentTypes': [
                {
                    'CFBundleTypeExtensions': [ 'py', 'bot' ],
                    'CFBundleTypeIconFile': 'NodeBoxFile.icns',
                    'CFBundleTypeName': "Python File",
                    'CFBundleTypeOSTypes': [ '????', '****', 'utxt'],
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'NodeBoxDocument',
                }
            ]
        }
    }],

    data_files=[
        "Resources/English.lproj/AskString.xib",
        "Resources/English.lproj/Credits.rtf",
        "Resources/English.lproj/ExportImageAccessory.xib",
        "Resources/English.lproj/ExportMovieAccessory.xib",
        "Resources/English.lproj/MainMenu.xib",
        "Resources/English.lproj/NodeBoxDocument.xib",
        "Resources/English.lproj/NodeBoxPreferences.xib",
        "Resources/English.lproj/ProgressBarSheet.xib",
        "Resources/NodeBox.icns",
        "Resources/NodeBoxFile.icns",
        "Resources/zoombig.png",
        "Resources/zoomsmall.png"
        ],

    ext_modules=[
        Extension('bwdithering', ['libs/bwdithering/bwdithering.c']),
        Extension('fractal', ['libs/fractal/fractal.c']),
        Extension('cGeo', ['libs/cGeo/cGeo.c']),
        Extension('cPathmatics', ['libs/pathmatics/pathmatics.c']),
        Extension('cPolymagic', ['libs/polymagic/gpc.c', 'libs/polymagic/polymagic.m'],
                extra_link_args=['-framework', 'AppKit', '-framework', 'Foundation'])
    ],

    options={
        "py2app": {
            "iconfile": "Resources/NodeBoxExtended.icns",
            "packages": [ "numpy", "scipy", "matplotlib",
                          "mpl_toolkits", "sklearn", "sympy", "pandas",
                          "cv2", "dlib", "skimage"],
            "excludes": ["TkInter",],
        }
    } )
</t>
<t tx="karstenw.20170811141051.1"></t>
<t tx="karstenw.20170811141102.1"></t>
<t tx="karstenw.20170811141113.1"></t>
<t tx="karstenw.20171218183025.1"></t>
<t tx="karstenw.20171218183032.1">def palette(pilimage, mask):
    """
    Return palette in descending order of frequency
    """
    result = []
    arr = np.asarray(pilimage)
    if mask != None:
        if 0 &lt;= mask &lt;= 255:
            arr = arr &amp; int(mask)
    palette, index = np.unique(asvoid(arr).ravel(), return_inverse=True)
    palette = palette.view(arr.dtype).reshape(-1, arr.shape[-1])
    count = np.bincount(index)
    order = np.argsort(count)
    
    p = palette[order[::-1]]

    for col in p:
        r,g,b = col
        
        result.append( (r / 255.0, g / 255.0, b / 255.0) )
    return result


</t>
<t tx="karstenw.20171218183048.1">def asvoid(arr):
    """View the array as dtype np.void (bytes)
    This collapses ND-arrays to 1D-arrays, so you can perform 1D operations on them.
    http://stackoverflow.com/a/16216866/190597 (Jaime)
    http://stackoverflow.com/a/16840350/190597 (Jaime)
    Warning:
    &gt;&gt;&gt; asvoid([-0.]) == asvoid([0.])
    array([False], dtype=bool)
    """
    arr = np.ascontiguousarray(arr)
    result = arr.view(np.dtype((np.void, arr.dtype.itemsize * arr.shape[-1])))
    return result


</t>
<t tx="karstenw.20180202040514.1"></t>
<t tx="karstenw.20180202040520.1"></t>
<t tx="karstenw.20180202040559.1">@language c
@tabwidth -4


@others
</t>
<t tx="karstenw.20180202040628.1">static int arrayindex(int x, int y, int w){
    return (y * w + x);
}


</t>
<t tx="karstenw.20180202040628.2">static void distributeError( int x, int y,
                             int w, int h,
                             int type,
                             ERRBUFTYPE errval,
                             unsigned char destImage[], ERRBUFTYPE errorBuffer[] ) {
    /*
     * Distribute the error to neighbouring pixels.
     *
     * The distributions have been taken from
     * 
     * http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/
     *
     *
     * The errors are mine. kw 2018-01
     */

    ERRBUFTYPE errdiv1, errdiv2, errdiv3, errdiv4;
    int idx;

    if (type &lt; 0) {
        type = 0;
    }
    if  (type &gt;= zzsentinel) {
        type = zzsentinel-1;
    }

    switch (type){
        case atkinsondither:
            // distribute the error
            // atkinson dithering divides by eight but distributes only 6/8
            errdiv1 = errval / (UNIT * 8);
            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                errorBuffer[idx] += errdiv1;
                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    errorBuffer[idx] += errdiv1;
                }
            }

            if ( y+1 &lt; h ) {
                // x ,y+1
                idx = arrayindex(x, y+1, w);
                errorBuffer[idx] += errdiv1;
                if (x-1 &gt;= 0) {
                    // x-1, y+1
                    idx = arrayindex(x-1, y+1, w);
                    errorBuffer[idx] += errdiv1;
                }
                if ( y+2 &lt; h ) {
                    // x, y+2
                    idx = arrayindex(x, y+2, w);
                    errorBuffer[idx] += errdiv1;
                }
                if (x+1 &lt; w) {
                    // x+1, y+1
                    idx = arrayindex(x+1, y+1, w);
                    errorBuffer[idx] += errdiv1;
                }
            }
            break;

        case floydsteinbergdither:
            errdiv1 = errval / (UNIT * 16) * 7;
            errdiv2 = errval / (UNIT * 16) * 3;
            errdiv3 = errval / (UNIT * 16) * 5;
            errdiv4 = errval / (UNIT * 16) * 1;

            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 7/16
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1 ,y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 1/16
                    errorBuffer[idx] += errdiv4;
                }
            }
            if ( y+1 &lt; h ) {
                // x ,y+1
                idx = arrayindex(x, y+1, w);
                // 5/16
                errorBuffer[idx] += errdiv3;
                
                if (x &gt; 0) {
                    // x-1 ,y+1
                    idx = arrayindex(x-1, y+1, w);
                    // 3/16
                    errorBuffer[idx] += errdiv2;
                }
            }

            break;

        case jarvisjudiceninkedithering:
            errdiv1 = errval / (UNIT * 48) * 7;
            errdiv2 = errval / (UNIT * 48) * 5;
            errdiv3 = errval / (UNIT * 48) * 3;
            errdiv4 = errval / (UNIT * 48) * 1;

            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 7/48
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1 ,y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 5/48
                    errorBuffer[idx] += errdiv2;
                }
                if ( y+2 &lt; h ) {
                    // x+1 ,y+2
                    idx = arrayindex(x+1, y+2, w);
                    // 3/48
                    errorBuffer[idx] += errdiv3;
                }

                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    // 5/48
                    errorBuffer[idx] += errdiv2;
                    if ( y+1 &lt; h ) {
                        // x+2 ,y+1
                        idx = arrayindex(x+2, y+1, w);
                        // 3/48
                        errorBuffer[idx] += errdiv3;
                    }
                    if ( y+2 &lt; h ) {
                        // x+2 ,y+2
                        idx = arrayindex(x+2, y+2, w);
                        // 1/48
                        errorBuffer[idx] += errdiv4;
                    }
                }
            }

            if (y+1 &lt; h) {
                // x, y+1
                idx = arrayindex(x, y+1, w);
                // 7/48
                errorBuffer[idx] += errdiv1;
            }
            if (y+2 &lt; h) {
                // x, y+2
                idx = arrayindex(x, y+2, w);
                // 5/48
                errorBuffer[idx] += errdiv2;
            }

            if ( x-1 &gt; 0 ) {
                if (y+1 &lt; h) {
                    // x-1, y+1
                    idx = arrayindex(x-1, y+1, w);
                    // 5/48
                    errorBuffer[idx] += errdiv2;
                }
                if (y+2 &lt; h) {
                    // x-1, y+2
                    idx = arrayindex(x-1, y+2, w);
                    // 3/48
                    errorBuffer[idx] += errdiv3;
                }
            }
            if ( x-2 &gt; 0 ) {
                if (y+1 &lt; h) {
                    // x-2, y+1
                    idx = arrayindex(x-2, y+1, w);
                    // 3/48
                    errorBuffer[idx] += errdiv3;
                }
                if (y+2 &lt; h) {
                    // x-2, y+2
                    idx = arrayindex(x-2, y+2, w);
                    // 1/48
                    errorBuffer[idx] += errdiv4;
                }
            }
            break;

        case stuckidithering:
            errdiv1 = errval / (UNIT * 42) * 8;
            errdiv2 = errval / (UNIT * 42) * 4;
            errdiv3 = errval / (UNIT * 42) * 2;
            errdiv4 = errval / (UNIT * 42) * 1;
            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 8/42
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1, y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 4/42
                    errorBuffer[idx] += errdiv2;
                }
                if ( y+2 &lt; h ) {
                    // x+1, y+2
                    idx = arrayindex(x+1, y+2, w);
                    // 2/42
                    errorBuffer[idx] += errdiv3;
                }
                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    // 4/42
                    errorBuffer[idx] += errdiv2;
                    if ( y+1 &lt; h ) {
                        // x+2, y+1
                        idx = arrayindex(x+2, y+1, w);
                        // 2/42
                        errorBuffer[idx] += errdiv3;
                    }
                    if ( y+2 &lt; h ) {
                        // x+2, y+2
                        idx = arrayindex(x+2, y+2, w);
                        // 1/42
                        errorBuffer[idx] += errdiv4;
                    }
                }
            }
            if (y+1 &lt; h) {
                if (x-2 &gt; 0) {
                    idx = arrayindex(x-2, y+1, w);
                    // 2/42
                    errorBuffer[idx] += errdiv3;
                }
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+1, w);
                    // 4/42
                    errorBuffer[idx] += errdiv2;
                }
                idx = arrayindex(x, y+1, w);
                // 8/42
                errorBuffer[idx] += errdiv1;
            }
            if (y+2 &lt; h) {
                if (x-2 &gt; 0) {
                    idx = arrayindex(x-2, y+2, w);
                    // 1/42
                    errorBuffer[idx] += errdiv4;
                }
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+2, w);
                    // 2/42
                    errorBuffer[idx] += errdiv2;
                }
                idx = arrayindex(x, y+2, w);
                // 4/42
                errorBuffer[idx] += errdiv2;
            }
            break;

        case burkesdithering:
            errdiv1 = errval / (UNIT * 32) * 8;
            errdiv2 = errval / (UNIT * 32) * 4;
            errdiv3 = errval / (UNIT * 32) * 2;

            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 8/32
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1, y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 4/32
                    errorBuffer[idx] += errdiv2;
                }
                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    // 4/32
                    errorBuffer[idx] += errdiv2;
                    if ( y+1 &lt; h ) {
                        // x+2, y+1
                        idx = arrayindex(x+2, y+1, w);
                        // 2/32
                        errorBuffer[idx] += errdiv3;
                    }
                }
            }
            if (y+1 &lt; h) {
                if (x-2 &gt; 0) {
                    idx = arrayindex(x-2, y+1, w);
                    // 2/32
                    errorBuffer[idx] += errdiv3;
                }
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+1, w);
                    // 4/32
                    errorBuffer[idx] += errdiv2;
                }
                idx = arrayindex(x, y+1, w);
                // 8/32
                errorBuffer[idx] += errdiv1;
            }
            break;

        case sierra1dithering:
            errdiv1 = errval / (UNIT * 32) * 5;
            errdiv2 = errval / (UNIT * 32) * 4;
            errdiv3 = errval / (UNIT * 32) * 3;
            errdiv4 = errval / (UNIT * 32) * 2;
            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 5/32
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1, y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 4/32
                    errorBuffer[idx] += errdiv2;
                }
                if ( y+2 &lt; h ) {
                    // x+1, y+2
                    idx = arrayindex(x+1, y+2, w);
                    // 2/32
                    errorBuffer[idx] += errdiv4;
                }
                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    // 3/16
                    errorBuffer[idx] += errdiv3;
                    if ( y+1 &lt; h ) {
                        // x+2, y+1
                        idx = arrayindex(x+2, y+1, w);
                        // 2/16
                        errorBuffer[idx] += errdiv4;
                    }
                }
            }
            if (y+1 &lt; h) {
                if (x-2 &gt; 0) {
                    idx = arrayindex(x-2, y+1, w);
                    // 2/32
                    errorBuffer[idx] += errdiv4;
                }
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+1, w);
                    // 4/32
                    errorBuffer[idx] += errdiv2;
                }
                idx = arrayindex(x, y+1, w);
                // 5/32
                errorBuffer[idx] += errdiv1;
            }

            if (y+2 &lt; h) {
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+2, w);
                    // 2/32
                    errorBuffer[idx] += errdiv4;
                }
                if (x+1 &lt; w) {
                    idx = arrayindex(x+1, y+2, w);
                    // 2/32
                    errorBuffer[idx] += errdiv4;
                }
                idx = arrayindex(x, y+2, w);
                // 3/32
                errorBuffer[idx] += errdiv3;
            }


            break;

        case sierra2dithering:
            errdiv1 = errval / (UNIT * 16) * 4;
            errdiv2 = errval / (UNIT * 16) * 3;
            errdiv3 = errval / (UNIT * 16) * 2;
            errdiv4 = errval / (UNIT * 16) * 1;
            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 4/16
                errorBuffer[idx] += errdiv1;
                if ( y+1 &lt; h ) {
                    // x+1, y+1
                    idx = arrayindex(x+1, y+1, w);
                    // 2/16
                    errorBuffer[idx] += errdiv2;
                }
                if ( x+2 &lt; w ) {
                    // x+2 ,y
                    idx = arrayindex(x+2, y, w);
                    // 3/16
                    errorBuffer[idx] += errdiv2;
                    if ( y+1 &lt; h ) {
                        // x+2, y+1
                        idx = arrayindex(x+2, y+1, w);
                        // 1/16
                        errorBuffer[idx] += errdiv4;
                    }
                }
            }
            if (y+1 &lt; h) {
                if (x-2 &gt; 0) {
                    idx = arrayindex(x-2, y+1, w);
                    // 1/16
                    errorBuffer[idx] += errdiv4;
                }
                if (x-1 &gt; 0) {
                    idx = arrayindex(x-1, y+1, w);
                    // 2/16
                    errorBuffer[idx] += errdiv3;
                }
                idx = arrayindex(x, y+1, w);
                // 3/16
                errorBuffer[idx] += errdiv2;
            }
            break;

        case sierra3dithering:
            errdiv1 = errval / (UNIT * 4) * 2;
            errdiv2 = errval / (UNIT * 4) * 1;

            if ( x+1 &lt; w ) {
                // x+1 ,y
                idx = arrayindex(x+1, y, w);
                // 2/4
                errorBuffer[idx] += errdiv1;
            }
            if ( y+1 &lt; h ) {
                // x, y+1
                idx = arrayindex(x, y+1, w);
                // 1/4
                errorBuffer[idx] += errdiv2;
                if ( x-1 &gt; 0 ) {
                    // x-1, y+1
                    idx = arrayindex(x-1, y+1, w);
                    // 1/4
                    errorBuffer[idx] += errdiv2;
                }
            }
            break;
    }
}


</t>
<t tx="karstenw.20180202040628.3">static PyObject *
dither(PyObject *self, PyObject *args) {
    /*
     * 
     */
    // params
    int w, h, type, treshhold;

    // iterators
    int x, y;

    // calculated array index
    int idx;
    int count;

    ERRBUFTYPE *errorBuffer, errdiv, newval, errval;
    const unsigned char *sourceImage;
    unsigned char *resultImage;
    // unsigned char *sourceImage, *resultImage;
    PyObject *result;

    if (!PyArg_ParseTuple(args, IN_FORMAT, &amp;sourceImage, &amp;count, &amp;w, &amp;h, &amp;type, &amp;treshhold)) {
        return (NULL);
    }
    
    if (!count) {
        printf("count %d\n" , count);
        printf("w %d\n" , w);
        printf("h %d\n" , h);
        printf("type %d\n" , type);
        printf("treshhold %d\n" , treshhold);
    }

    // create the buffers
    resultImage = (unsigned char *)malloc( count );
    errorBuffer = (ERRBUFTYPE *)malloc( count*sizeof(ERRBUFTYPE));

    // init &amp; check the buffers
    memcpy( (void *)resultImage, (const void *)sourceImage, count);
    memset( errorBuffer, 0, count*sizeof(ERRBUFTYPE));

    if (!resultImage) {
        PyErr_NoMemory();
        return NULL;
    }

    if (!errorBuffer) {
        PyErr_NoMemory();
        return NULL;
    }

    // iterate over all pixels (x,y)
    for (y = 0; y &lt; h; y++) {
        for (x = 0; x &lt; w; x++) {
            // calc array index for image and error buffers
            idx = arrayindex(x, y, w);
            newval = errorBuffer[idx] + resultImage[idx];
            
            // set pixel value
            if (newval &gt;= treshhold) {
                errval = newval - 255;
                errdiv = errval / 8;
                resultImage[idx] = 255;
            } else {
                errval = newval;
                errdiv = errval / 8;
                resultImage[idx] = 0;
            }

            // cut short if nothing to add			
            if (errdiv == 0)
                continue;
            distributeError( x, y, w, h, type, errval, resultImage, errorBuffer);
        }
    }

    // build the return value
    result = Py_BuildValue(OUT_FORMAT, resultImage, count);
    free(errorBuffer);
    free(resultImage);
    return result;
}


</t>
<t tx="karstenw.20180202040628.4">static PyMethodDef bwdither_methods[]={ 
    { "dither", dither, METH_VARARGS },
    { NULL, NULL }
};


</t>
<t tx="karstenw.20180202040628.5">int main(int argc, char *argv[])
{
    Py_SetProgramName(argv[0]);
    Py_Initialize();
#if PY_MAJOR_VERSION &gt;= 3
    PyInit_bwdithering();
#else
    initbwdithering();
#endif
    return 0;
}


</t>
<t tx="karstenw.20180202040658.1">#include &lt;stdlib.h&gt;

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

// Karsten Wolf 2018-01-17

// black &amp; white dither

// type for the errorBuffer. Possible: int, short, float
#define ERRBUFTYPE float
#define UNIT 1.0

enum {
    atkinsondither=1,
    floydsteinbergdither,
    jarvisjudiceninkedithering,
    stuckidithering,
    burkesdithering,
    sierra1dithering,
    sierra2dithering,
    sierra3dithering,
    zzsentinel
} dithertypes;

</t>
<t tx="karstenw.20180202040859.1">MOD_INIT(bwdithering) { 
    PyObject *m;
    // m = Py_InitModule("bwdithering", bwdither_methods);
    MOD_DEF(m, "bwdithering", "A bw dithering extension.", bwdither_methods)
#if PY_MAJOR_VERSION &gt;= 3
    return(MOD_SUCCESS_VAL(m));
#else
	MOD_SUCCESS_VAL(m)
#endif
}

</t>
<t tx="karstenw.20180202041015.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180202041040.1">from distutils.core import setup, Extension

bwdither = Extension("bwdither", sources = ["bwdithering.c"])

setup (name = "bwdither",
       version = "0.1",
       author = "Karsten Wolf",
       description = "Atkinson, Floyd-Steinberg and other ditherings of grayscale images.",
       ext_modules = [bwdither])

</t>
<t tx="karstenw.20180202044244.1"></t>
<t tx="karstenw.20180202044248.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20180202044313.1">float _fast_inverse_sqrt(float x) { 
    float xhalf = 0.5f*x; 
    int i = *(int*)&amp;x;
    i = 0x5f3759df - (i&gt;&gt;1);
    x = *(float*)&amp;i;
    x = x*(1.5f-xhalf*x*x);
    return x; 
}
</t>
<t tx="karstenw.20180202044313.10">int main(int argc, char *argv[])
{
    Py_SetProgramName(argv[0]);
    Py_Initialize();
#if PY_MAJOR_VERSION &gt;= 3
    PyInit_cGeo();
#else
    initcGeo();
#endif
    return 0;
}
</t>
<t tx="karstenw.20180202044313.2">static PyObject *
fast_inverse_sqrt(PyObject *self, PyObject *args) {
    double x;   
    if (!PyArg_ParseTuple(args, "d", &amp;x))
        return NULL;
    x = _fast_inverse_sqrt(x);
    return Py_BuildValue("d", x);
}

// ANGLE
</t>
<t tx="karstenw.20180202044313.3">void _angle(double x0, double y0, double x1, double y1, double *a) {
    *a = atan2(y1-y0, x1-x0) / M_PI * 180;
}
</t>
<t tx="karstenw.20180202044313.4">static PyObject *
angle(PyObject *self, PyObject *args) {
    double x0, y0, x1, y1, a;    
    if (!PyArg_ParseTuple(args, "dddd", &amp;x0, &amp;y0, &amp;x1, &amp;y1))
        return NULL;
    _angle(x0, y0, x1, y1, &amp;a);
    return Py_BuildValue("d", a);
}

// DISTANCE
</t>
<t tx="karstenw.20180202044313.5">void _distance(double x0, double y0, double x1, double y1, double *d) {
    // this is not much faster but inaccurate
    // *d = 1.0 / _fast_inverse_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
    // *d = sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
    double dx = x1-x0, dy = y1-y0;
    *d = sqrt(dx*dx + dy*dy);
}
</t>
<t tx="karstenw.20180202044313.6">static PyObject *
distance(PyObject *self, PyObject *args) {
    double x0, y0, x1, y1, d;   
    if (!PyArg_ParseTuple(args, "dddd", &amp;x0, &amp;y0, &amp;x1, &amp;y1))
        return NULL;
    _distance(x0, y0, x1, y1, &amp;d);
    return Py_BuildValue("d", d);
}

// COORDINATES
</t>
<t tx="karstenw.20180202044313.7">void _coordinates(double x0, double y0, double d, double a, double *x1, double *y1) {
    *x1 = x0 + cos(a/180*M_PI) * d;
    *y1 = y0 + sin(a/180*M_PI) * d;
}
</t>
<t tx="karstenw.20180202044313.8">static PyObject *
coordinates(PyObject *self, PyObject *args) {
    double x0, y0, d, a, x1, y1;   
    if (!PyArg_ParseTuple(args, "dddd", &amp;x0, &amp;y0, &amp;d, &amp;a))
        return NULL;
    _coordinates(x0, y0, d, a, &amp;x1, &amp;y1);
    return Py_BuildValue("dd", x1, y1);
}

</t>
<t tx="karstenw.20180202044313.9">static PyMethodDef geometry_methods[]={ 
    { "fast_inverse_sqrt", fast_inverse_sqrt, METH_VARARGS },
    { "angle", angle, METH_VARARGS }, 
    { "distance", distance, METH_VARARGS }, 
    { "coordinates", coordinates, METH_VARARGS },  
    { NULL, NULL }
};


</t>
<t tx="karstenw.20180202044341.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;math.h&gt;

// FAST INVERSE SQRT
// Chris Lomont, http://www.math.purdue.edu/~clomont/Math/Papers/2003/InvSqrt.pdf

</t>
<t tx="karstenw.20180202044624.1">MOD_INIT(cGeo) { 
    PyObject *m;
    // m = Py_InitModule("cGeo", geometry_methods);
    MOD_DEF(m, "cGeo", "angle, distance and coordinates.", geometry_methods)
#if PY_MAJOR_VERSION &gt;= 3
    return( m );
#endif
}

</t>
<t tx="karstenw.20180202044708.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180202044720.1">from distutils.core import setup, Extension

cGeo = Extension("cGeo", sources = ["cGeo.c"])

setup (name = "cGeo",
       version = "0.1",
       author = "Tom De Smedt",
       description = "Fast geometric functionality.",
       ext_modules = [cGeo])
</t>
<t tx="karstenw.20180202044822.1">def imagepalette( pathOrPILimgage, mask=None ):
    t = type(pathOrPILimgage)
    result = []
    if t in (pstr, punicode):
        f = PIL.Image.open( pathOrPILimgage )
        f = f.convert("RGB")
        result = palette( f, mask )
    else:
        try:
            result = palette( pathOrPILimgage, mask )
        except Exception as err:
            pass
    return result


</t>
<t tx="karstenw.20180202044929.1">def dither(self, imagebytes, w, h, typ, threshhold):
    return nodebox.geo.dither(imagebytes, w, h, typ, threshhold)

## 

</t>
<t tx="karstenw.20180202045145.1"></t>
<t tx="karstenw.20180202050130.1">def aspectRatio(size, maxsize=None, maxw=None, maxh=None):
    """scale a size tuple (w,h) to 
        - maxsize (max w or h)
        - or max width maxw
        - or max height maxh."""
    w, h = size
    denom = maxcurrent = 1

    if maxsize:
        maxcurrent = max(size)
        denom = maxsize
    elif maxw:
        maxcurrent = w
        denom = maxw
    elif maxh:
        maxcurrent = h
        denom = maxh

    if maxcurrent == denom:
        return size
    elif maxsize == 0:
        return size

    ratio = maxcurrent / float(denom)

    neww = int(round(w / ratio))
    newh = int(round(h / ratio))
    return neww, newh


</t>
<t tx="karstenw.20180202061109.1">def ditherimage(pathOrPILimgage, dithertype, threshhold):
    # argh, a circular import. Dang!
    from nodebox.geo import dither

    t = type(pathOrPILimgage)

    if dithertype in list(_dithertypes):
        dithername = dithertype
        ditherid = _dithertypes.get( dithertype )
    elif dithertype in _ditherIDs:
        ditherid = dithertype
        dithername = _dithertypes.get( dithertype )
        # pass
    else:
        ditherid = 0
        dithername = "unknown"

    if t in (pstr, punicode):
        img = PIL.Image.open( pathOrPILimgage ).convert('L')
    else:
        img = pathOrPILimgage
    
    w, h = img.size
    bin = img.tobytes(encoder_name='raw')
    resultimg = bytearray( len(bin) )
    resultbytes = dither(bin, w, h, ditherid, threshhold)
    # result = dither(bin, resultimg, w, h, ditherid, threshhold)

    out = PIL.Image.frombytes( 'L', (w,h), resultbytes, decoder_name='raw')

    name = "dither_%s_%s.png" % (datestring(nocolons=True), dithername)
    out.convert('1').save(name, format="PNG")
    del out, bin, resultbytes
    if img != pathOrPILimgage:
        del img
    return os.path.abspath(name)


</t>
<t tx="karstenw.20180207131456.1">def tempimagepath(mode='w+b', suffix='.png'):
    """Create a temporary file with mode and suffix.
    Returns pathstring."""
    fob = tempfile.NamedTemporaryFile(mode=mode, suffix=suffix, delete=False)
    fname = fob.name
    fob.close()
    return fname


</t>
<t tx="karstenw.20180207131514.1">def dithertypes():
    """Return names of all supported dither types."""
    return list(_dithertypes.keys())


</t>
<t tx="karstenw.20210320110747.1">#if PY_MAJOR_VERSION &gt;= 3
  #define MOD_ERROR_VAL NULL
  #define MOD_SUCCESS_VAL(val) val
  #define MOD_INIT(name) PyMODINIT_FUNC PyInit_##name(void)
  #define MOD_DEF(ob, name, doc, methods) \
          static struct PyModuleDef moduledef = { \
            PyModuleDef_HEAD_INIT, name, doc, -1, methods, }; \
          ob = PyModule_Create(&amp;moduledef);
#else
  #define MOD_ERROR_VAL
  #define MOD_SUCCESS_VAL(val)
  #define MOD_INIT(name) void init##name(void)
  #define MOD_DEF(ob, name, doc, methods) \
    ob = Py_InitModule3(name, methods, doc);
#endif
</t>
<t tx="karstenw.20210320115101.1"></t>
<t tx="karstenw.20210320115106.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20210320115144.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20210320115153.1">from distutils.core import setup, Extension

fractal = Extension("fractal", sources = ["fractal.c"])

setup (name = "fractal",
       version = "0.1",
       author = "Karsten Wolf",
       description = "Fractals in C.",
       ext_modules = [fractal])

</t>
<t tx="karstenw.20210320115155.1">static PyObject *
fractalimage(PyObject *self, PyObject *args) {
    /*
     * The errors are mine. kw 2020-06
     */

    int x, y;

    // params
    int clutsize, w, h, iterations;
    double x1, y1, dx, dy, nreal, nimag, limit;
    // double creal, cimag, 
    unsigned char *pixels;
    const unsigned char *clut;


    int count = 0;
    
    // int dbg = 0;

    PyObject *result;

    // s# -&gt; 2vars; d double; 
    if (!PyArg_ParseTuple(args, IN_FORMAT,
                          &amp;clut, &amp;clutsize,
                          &amp;w, &amp;h, &amp;iterations, 
                          &amp;x1, &amp;y1, &amp;dx, &amp;dy, &amp;nreal, &amp;nimag, &amp;limit )) {
        return (NULL);
    }

    count = w * h * 4;

    // if (dbg)
    //     printf("count: %d\n", count);

    // create the buffers
    pixels = (unsigned char *)malloc( count );
    memset( pixels, 0, count);

    if (!pixels) {
        PyErr_NoMemory();
        return NULL;
    }

    double scalex = 1.0 / (double)w * dx;
    double scaley = 1.0 / (double)h * dy;

    // iterate over all pixels (x,y)
    for (y=0; y &lt; h; y++) {
        for (x=0; x &lt; w; x++) {
            int v = 0, iter;

            double xc = x1 + (double)x * scalex;
            double yc = y1 + (double)y * scaley;
            
            double complex z = xc + yc * I;
            double complex c = nreal + nimag * I;


            // calc pixel value v
            for (iter=0; iter &lt; iterations; iter++) {
                if (cabs(c) &lt;= limit) {
                    c = c*c + z;
                } else {
                    v = iter;
                    break;
                }
            }
            // copy clut values
            int idx = v * 4;
            int o = (y * w + x) * 4;
            for (iter=0; iter &lt; 4; iter++) {
                if ((o+iter &lt; count) &amp;&amp; (idx+iter &lt; clutsize))
                    pixels[o+iter] = clut[idx+iter];
                /*
                else if (dbg) {
                    printf("BOUNDS crossed\n");
                    if (o+iter &lt; count)
                        printf("o+iter %d  count %d\n", o+iter, count);
                    if (idx+iter &lt; clutsize)
                        printf("idx+iter %d clutsize %d\n", o+iter, clutsize);
                
                }
                */
            }
        }
    }

    // build the return value
    result = Py_BuildValue(OUT_FORMAT, pixels, count);
    free(pixels);
    return result;
}


</t>
<t tx="karstenw.20210320115155.2">static PyMethodDef fractal_methods[]={ 
    { "fractalimage", fractalimage, METH_VARARGS },
    { NULL, NULL }
};


MOD_INIT(fractal) { 
    PyObject *m;
    //m = Py_InitModule("fractal", fractal_methods);
    MOD_DEF(m, "fractal", "A mandelbrot renderer.", fractal_methods)
#if PY_MAJOR_VERSION &gt;= 3
    return( m );
#endif
}

</t>
<t tx="karstenw.20210320115155.3">int main(int argc, char *argv[])
{
    Py_SetProgramName(argv[0]);
    Py_Initialize();
#if PY_MAJOR_VERSION &gt;= 3
    PyInit_fractal();
#else
    initfractal();
#endif
    return 0;
}

</t>
<t tx="karstenw.20210320115212.1">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;complex.h&gt;

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

// Karsten Wolf 2020-06-21

// mandelbrot calculations

</t>
<t tx="karstenw.20210320120737.1"></t>
<t tx="karstenw.20210320120741.1"></t>
<t tx="karstenw.20210320120859.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20210320120918.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20210320120924.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20210320120934.1">from distutils.core import setup, Extension

cPathmatics = Extension("cPathmatics", sources = ["pathmatics.c"])

setup (name = "pathmatics",
       version = "1.0",
       author = "Tom De Smedt and Frederik De Bleser",
       description = "Inner looping functions for calculating bezier operations.",
       ext_modules = [cPathmatics])

</t>
<t tx="karstenw.20210320120938.1">from math import sqrt, pow

</t>
<t tx="karstenw.20210320120938.2">def linepoint(t, x0, y0, x1, y1):

    """Returns coordinates for point at t on the line.

    Calculates the coordinates of x and y for a point
    at t on a straight line.

    The t parameter is a number between 0.0 and 1.0,
    x0 and y0 define the starting point of the line,
    x1 and y1 the ending point of the line,    

    """

    out_x = x0 + t * (x1-x0)
    out_y = y0 + t * (y1-y0)
    return (out_x, out_y)

</t>
<t tx="karstenw.20210320120938.3">def linelength(x0, y0, x1, y1):

    """Returns the length of the line."""

    a = pow(abs(x0 - x1), 2)
    b = pow(abs(y0 - y1), 2)
    return sqrt(a+b)

</t>
<t tx="karstenw.20210320120938.4">def curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3, handles=False):

    """Returns coordinates for point at t on the spline.

    Calculates the coordinates of x and y for a point
    at t on the cubic bezier spline, and its control points,
    based on the de Casteljau interpolation algorithm.

    The t parameter is a number between 0.0 and 1.0,
    x0 and y0 define the starting point of the spline,
    x1 and y1 its control point,
    x3 and y3 the ending point of the spline,
    x2 and y2 its control point.
    
    If the handles parameter is set,
    returns not only the point at t,
    but the modified control points of p0 and p3
    should this point split the path as well.
    """
    
    mint = 1 - t

    x01   = x0 * mint + x1 * t
    y01   = y0 * mint + y1 * t
    x12   = x1 * mint + x2 * t
    y12   = y1 * mint + y2 * t
    x23   = x2 * mint + x3 * t
    y23   = y2 * mint + y3 * t
   
    out_c1x = x01 * mint + x12 * t
    out_c1y = y01 * mint + y12 * t
    out_c2x = x12 * mint + x23 * t
    out_c2y = y12 * mint + y23 * t
    out_x = out_c1x * mint + out_c2x * t
    out_y = out_c1y * mint + out_c2y * t
    
    if not handles:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y)
    else:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y, x01, y01, x23, y23)

</t>
<t tx="karstenw.20210320120938.5">def curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n=20):

    """Returns the length of the spline.

    Integrates the estimated length of the cubic bezier spline
    defined by x0, y0, ... x3, y3, by adding the lengths of
    lineair lines between points at t.

    The number of points is defined by n 
    (n=10 would add the lengths of lines between 0.0 and 0.1, 
    between 0.1 and 0.2, and so on).

    The default n=20 is fine for most cases, usually
    resulting in a deviation of less than 0.01.
    """

    length = 0
    xi = x0
    yi = y0

    for i in range(n):
        t = 1.0 * (i+1) / n
        pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y = \
            curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3)
        c = sqrt(pow(abs(xi-pt_x),2) + pow(abs(yi-pt_y),2))
        length += c
        xi = pt_x
        yi = pt_y
        
    return length
</t>
<t tx="karstenw.20210320120941.1">void _linepoint(double t, double x0, double y0, double x1, double y1,
                double *out_x, double *out_y
                )
{
    *out_x = x0 + t * (x1-x0);
    *out_y = y0 + t * (y1-y0);
}


</t>
<t tx="karstenw.20210320120941.10">static PyMethodDef PathmaticsMethods[] = {
    {"linepoint",  cPathmatics_linepoint, METH_VARARGS, "Calculate linepoint."},
    {"linelength",  cPathmatics_linelength, METH_VARARGS, "Calculate linelength."},
    {"curvepoint",  cPathmatics_curvepoint, METH_VARARGS, "Calculate curvepoint."},
    {"curvelength",  cPathmatics_curvelength, METH_VARARGS, "Calculate curvelength."},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};


MOD_INIT(cPathmatics) {
    PyObject *m;
    
    // m = Py_InitModule("cPathmatics", PathmaticsMethods);
    MOD_DEF(m, "cPathmatics", "Some path stuff.", PathmaticsMethods)
    
    PathmaticsError = PyErr_NewException("cPathmatics.error", NULL, NULL);
    Py_INCREF(PathmaticsError);
    PyModule_AddObject(m, "error", PathmaticsError);
#if PY_MAJOR_VERSION &gt;= 3
    return( m );
#endif
}


</t>
<t tx="karstenw.20210320120941.11">int
main(int argc, char *argv[])
{
    /* Pass argv[0] to the Python interpreter */
    Py_SetProgramName(argv[0]);

    /* Initialize the Python interpreter.  Required. */
    Py_Initialize();

    /* Add a static module */
#if PY_MAJOR_VERSION &gt;= 3
    PyInit_cPathmatics();
#else
    initcPathmatics();
#endif

    return 0;
}

</t>
<t tx="karstenw.20210320120941.2">void _linelength(double x0, double y0, double x1, double y1,
                double *out_length
                )
{
    double a, b;
    a = pow(fabs(x0 - x1), 2);
    b = pow(fabs(y0 - y1), 2);
    *out_length = sqrt(a + b);
}

</t>
<t tx="karstenw.20210320120941.3">void _curvepoint(double t, double x0, double y0, double x1, double y1, 
                 double x2, double y2, double x3, double y3,
                 double *out_x, double *out_y, 
                 double *out_c1x, double *out_c1y, double *out_c2x, double *out_c2y
                 )
{
    double mint, x01, y01, x12, y12, x23, y23;

    mint  = 1 - t;
    x01 = x0 * mint + x1 * t;
    y01 = y0 * mint + y1 * t;
    x12 = x1 * mint + x2 * t;
    y12 = y1 * mint + y2 * t;
    x23 = x2 * mint + x3 * t;
    y23 = y2 * mint + y3 * t;
    
    *out_c1x = x01 * mint + x12 * t;
    *out_c1y = y01 * mint + y12 * t;
    *out_c2x = x12 * mint + x23 * t;
    *out_c2y = y12 * mint + y23 * t;
    *out_x = *out_c1x * mint + *out_c2x * t;
    *out_y = *out_c1y * mint + *out_c2y * t;
}

</t>
<t tx="karstenw.20210320120941.4">void _curvepoint_handles(double t, double x0, double y0, double x1, double y1, 
                 double x2, double y2, double x3, double y3,
                 double *out_x, double *out_y, 
                 double *out_c1x, double *out_c1y, double *out_c2x, double *out_c2y,
                 double *out_h1x, double *out_h1y, double *out_h2x, double *out_h2y
                 )
{
    double mint, x01, y01, x12, y12, x23, y23;

    mint  = 1 - t;
    x01 = x0 * mint + x1 * t;
    y01 = y0 * mint + y1 * t;
    x12 = x1 * mint + x2 * t;
    y12 = y1 * mint + y2 * t;
    x23 = x2 * mint + x3 * t;
    y23 = y2 * mint + y3 * t;
    
    *out_c1x = x01 * mint + x12 * t;
    *out_c1y = y01 * mint + y12 * t;
    *out_c2x = x12 * mint + x23 * t;
    *out_c2y = y12 * mint + y23 * t;
    *out_x = *out_c1x * mint + *out_c2x * t;
    *out_y = *out_c1y * mint + *out_c2y * t;
    *out_h1x = x01;
    *out_h1y = y01;
    *out_h2x = x23;
    *out_h2y = y23;
}

</t>
<t tx="karstenw.20210320120941.5">void _curvelength(double x0, double y0, double x1, double y1, 
                  double x2, double y2, double x3, double y3, int n, 
                  double *out_length
                  )
{
    double xi, yi, t, c;
    double pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y;
    int i;
    double length = 0;
    
    xi = x0;
    yi = y0;
    
    for (i=0; i&lt;n; i++) {
        t = 1.0 * (i+1.0) / (float) n;
        
        _curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3,
                    &amp;pt_x, &amp;pt_y, &amp;pt_c1x, &amp;pt_c1y, &amp;pt_c2x, &amp;pt_c2y);
        c = sqrt(pow(fabs(xi-pt_x), 2.0) + pow(fabs(yi-pt_y), 2.0));
        length += c;
        xi = pt_x;
        yi = pt_y;
    }
    *out_length = length;
}

</t>
<t tx="karstenw.20210320120941.6">static PyObject *
cPathmatics_linepoint(PyObject *self, PyObject *args)
{
    double t, x0, y0, x1, y1;
    double out_x, out_y;
    
    if (!PyArg_ParseTuple(args, "ddddd", &amp;t, &amp;x0, &amp;y0, &amp;x1, &amp;y1))
        return NULL;
        
    _linepoint(t, x0, y0, x1, y1,
               &amp;out_x, &amp;out_y);

    return Py_BuildValue("dd", out_x, out_y);
}

</t>
<t tx="karstenw.20210320120941.7">static PyObject *
cPathmatics_linelength(PyObject *self, PyObject *args)
{
    double x0, y0, x1, y1;
    double out_length;
    
    if (!PyArg_ParseTuple(args, "dddd", &amp;x0, &amp;y0, &amp;x1, &amp;y1))
        return NULL;
        
    _linelength(x0, y0, x1, y1,
                &amp;out_length);

    return Py_BuildValue("d", out_length);
}


</t>
<t tx="karstenw.20210320120941.8">static PyObject *
cPathmatics_curvepoint(PyObject *self, PyObject *args)
{
    double t, x0, y0, x1, y1, x2, y2, x3, y3, handles = 0;
    double out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y, out_h1x, out_h1y, out_h2x, out_h2y;
    
    if (!PyArg_ParseTuple(args, "ddddddddd|i", &amp;t, &amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;handles))
        return NULL;
        
    if (!handles) {
        _curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3,
            &amp;out_x, &amp;out_y, &amp;out_c1x, &amp;out_c1y, &amp;out_c2x, &amp;out_c2y);

        return Py_BuildValue("dddddd", out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y);

    } else {
        _curvepoint_handles(t, x0, y0, x1, y1, x2, y2, x3, y3,
            &amp;out_x, &amp;out_y, &amp;out_c1x, &amp;out_c1y, &amp;out_c2x, &amp;out_c2y,
            &amp;out_h1x, &amp;out_h1y, &amp;out_h2x, &amp;out_h2y);

        return Py_BuildValue("dddddddddd", out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y,
            out_h1x, out_h1y, out_h2x, out_h2y);
    }
}

</t>
<t tx="karstenw.20210320120941.9">static PyObject *
cPathmatics_curvelength(PyObject *self, PyObject *args)
{
    double x0, y0, x1, y1, x2, y2, x3, y3;
    int n = 20;
    double out_length;
    
    if (!PyArg_ParseTuple(args, "dddddddd|i", &amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;n))
        return NULL;

    _curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n,
                 &amp;out_length);

    return Py_BuildValue("d", out_length);
}

static PyObject *PathmaticsError;

</t>
<t tx="karstenw.20210320121857.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;math.h&gt;

</t>
<t tx="karstenw.20210320123535.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20210320123635.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20210320123639.1">@language c
@tabwidth -4
@others
</t>
<t tx="karstenw.20210320123652.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20210320123811.1">typedef enum                        /* Set operation type                */
{
  GPC_DIFF,                         /* Difference                        */
  GPC_INT,                          /* Intersection                      */
  GPC_XOR,                          /* Exclusive or                      */
  GPC_UNION                         /* Union                             */
} gpc_op;

</t>
<t tx="karstenw.20210320123811.2">typedef struct                      /* Polygon vertex structure          */
{
  double              x;            /* Vertex x component                */
  double              y;            /* vertex y component                */
} gpc_vertex;

</t>
<t tx="karstenw.20210320123811.3">typedef struct                      /* Vertex list structure             */
{
  int                 num_vertices; /* Number of vertices in list        */
  gpc_vertex         *vertex;       /* Vertex array pointer              */
} gpc_vertex_list;

</t>
<t tx="karstenw.20210320123811.4">typedef struct                      /* Polygon set structure             */
{
  int                 num_contours; /* Number of contours in polygon     */
  int                *hole;         /* Hole / external contour flags     */
  gpc_vertex_list    *contour;      /* Contour array pointer             */
} gpc_polygon;

</t>
<t tx="karstenw.20210320123811.5">typedef struct                      /* Tristrip set structure            */
{
  int                 num_strips;   /* Number of tristrips               */
  gpc_vertex_list    *strip;        /* Tristrip array pointer            */
} gpc_tristrip;


/*
===========================================================================
                       Public Function Prototypes
===========================================================================
*/

void gpc_read_polygon        (FILE            *infile_ptr, 
                              int              read_hole_flags,
                              gpc_polygon     *polygon);

void gpc_write_polygon       (FILE            *outfile_ptr,
                              int              write_hole_flags,
                              gpc_polygon     *polygon);

void gpc_add_contour         (gpc_polygon     *polygon,
                              gpc_vertex_list *contour,
                              int              hole);

void gpc_polygon_clip        (gpc_op           set_operation,
                              gpc_polygon     *subject_polygon,
                              gpc_polygon     *clip_polygon,
                              gpc_polygon     *result_polygon);

void gpc_tristrip_clip       (gpc_op           set_operation,
                              gpc_polygon     *subject_polygon,
                              gpc_polygon     *clip_polygon,
                              gpc_tristrip    *result_tristrip);

void gpc_polygon_to_tristrip (gpc_polygon     *polygon,
                              gpc_tristrip    *tristrip);

void gpc_free_polygon        (gpc_polygon     *polygon);

void gpc_free_tristrip       (gpc_tristrip    *tristrip);

#endif

/*
===========================================================================
                           End of file: gpc.h
===========================================================================
*/
</t>
<t tx="karstenw.20210320123814.1">typedef enum                        /* Edge intersection classes         */
{
  NUL,                              /* Empty non-intersection            */
  EMX,                              /* External maximum                  */
  ELI,                              /* External left intermediate        */
  TED,                              /* Top edge                          */
  ERI,                              /* External right intermediate       */
  RED,                              /* Right edge                        */
  IMM,                              /* Internal maximum and minimum      */
  IMN,                              /* Internal minimum                  */
  EMN,                              /* External minimum                  */
  EMM,                              /* External maximum and minimum      */
  LED,                              /* Left edge                         */
  ILI,                              /* Internal left intermediate        */
  BED,                              /* Bottom edge                       */
  IRI,                              /* Internal right intermediate       */
  IMX,                              /* Internal maximum                  */
  FUL                               /* Full non-intersection             */
} vertex_type;

</t>
<t tx="karstenw.20210320123814.10">typedef struct st_shape             /* Sorted edge table                 */
{
  edge_node          *edge;         /* Pointer to AET edge               */
  double              xb;           /* Scanbeam bottom x coordinate      */
  double              xt;           /* Scanbeam top x coordinate         */
  double              dx;           /* Change in x for a unit y increase */
  struct st_shape    *prev;         /* Previous edge in sorted list      */
} st_node;

</t>
<t tx="karstenw.20210320123814.11">typedef struct bbox_shape           /* Contour axis-aligned bounding box */
{
  double             xmin;          /* Minimum x coordinate              */
  double             ymin;          /* Minimum y coordinate              */
  double             xmax;          /* Maximum x coordinate              */
  double             ymax;          /* Maximum y coordinate              */
} bbox;


/*
===========================================================================
                               Global Data
===========================================================================
*/

/* Horizontal edge state transitions within scanbeam boundary */
</t>
<t tx="karstenw.20210320123814.12">const h_state next_h_state[3][6]=
{
  /*        ABOVE     BELOW     CROSS */
  /*        L   R     L   R     L   R */  
  /* NH */ {BH, TH,   TH, BH,   NH, NH},
  /* BH */ {NH, NH,   NH, NH,   TH, TH},
  /* TH */ {NH, NH,   NH, NH,   BH, BH}
};


/*
===========================================================================
                             Private Functions
===========================================================================
*/

</t>
<t tx="karstenw.20210320123814.13">static void reset_it(it_node **it)
{
  it_node *itn;

  while (*it)
  {
    itn= (*it)-&gt;next;
    FREE(*it);
    *it= itn;
  }
}


</t>
<t tx="karstenw.20210320123814.14">static void reset_lmt(lmt_node **lmt)
{
  lmt_node *lmtn;

  while (*lmt)
  {
    lmtn= (*lmt)-&gt;next;
    FREE(*lmt);
    *lmt= lmtn;
  }
}


</t>
<t tx="karstenw.20210320123814.15">static void insert_bound(edge_node **b, edge_node *e)
{
  edge_node *existing_bound;

  if (!*b)
  {
    /* Link node e to the tail of the list */
    *b= e;
  }
  else
  {
    /* Do primary sort on the x field */
    if (e[0].bot.x &lt; (*b)[0].bot.x)
    {
      /* Insert a new node mid-list */
      existing_bound= *b;
      *b= e;
      (*b)-&gt;next_bound= existing_bound;
    }
    else
    {
      if (e[0].bot.x == (*b)[0].bot.x)
      {
        /* Do secondary sort on the dx field */
        if (e[0].dx &lt; (*b)[0].dx)
        {
          /* Insert a new node mid-list */
          existing_bound= *b;
          *b= e;
          (*b)-&gt;next_bound= existing_bound;
        }
        else
        {
          /* Head further down the list */
          insert_bound(&amp;((*b)-&gt;next_bound), e);
        }
      }
      else
      {
        /* Head further down the list */
        insert_bound(&amp;((*b)-&gt;next_bound), e);
      }
    }
  }
}


</t>
<t tx="karstenw.20210320123814.16">static edge_node **bound_list(lmt_node **lmt, double y)
{
  lmt_node *existing_node;

  if (!*lmt)
  {
    /* Add node onto the tail end of the LMT */
    MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);
    (*lmt)-&gt;y= y;
    (*lmt)-&gt;first_bound= NULL;
    (*lmt)-&gt;next= NULL;
    return &amp;((*lmt)-&gt;first_bound);
  }
  else
    if (y &lt; (*lmt)-&gt;y)
    {
      /* Insert a new LMT node before the current node */
      existing_node= *lmt;
      MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);
      (*lmt)-&gt;y= y;
      (*lmt)-&gt;first_bound= NULL;
      (*lmt)-&gt;next= existing_node;
      return &amp;((*lmt)-&gt;first_bound);
    }
    else
      if (y &gt; (*lmt)-&gt;y)
        /* Head further up the LMT */
        return bound_list(&amp;((*lmt)-&gt;next), y);
      else
        /* Use this existing LMT node */
        return &amp;((*lmt)-&gt;first_bound);
}


</t>
<t tx="karstenw.20210320123814.17">static void add_to_sbtree(int *entries, sb_tree **sbtree, double y)
{
  if (!*sbtree)
  {
    /* Add a new tree node here */
    MALLOC(*sbtree, sizeof(sb_tree), "scanbeam tree insertion", sb_tree);
    (*sbtree)-&gt;y= y;
    (*sbtree)-&gt;less= NULL;
    (*sbtree)-&gt;more= NULL;
    (*entries)++;
  }
  else
  {
    if ((*sbtree)-&gt;y &gt; y)
    {
    /* Head into the 'less' sub-tree */
      add_to_sbtree(entries, &amp;((*sbtree)-&gt;less), y);
    }
    else
    {
      if ((*sbtree)-&gt;y &lt; y)
      {
        /* Head into the 'more' sub-tree */
        add_to_sbtree(entries, &amp;((*sbtree)-&gt;more), y);
      }
    }
  }
}


</t>
<t tx="karstenw.20210320123814.18">static void build_sbt(int *entries, double *sbt, sb_tree *sbtree)
{
  if (sbtree-&gt;less)
    build_sbt(entries, sbt, sbtree-&gt;less);
  sbt[*entries]= sbtree-&gt;y;
  (*entries)++;
  if (sbtree-&gt;more)
    build_sbt(entries, sbt, sbtree-&gt;more);
}


</t>
<t tx="karstenw.20210320123814.19">static void free_sbtree(sb_tree **sbtree)
{
  if (*sbtree)
  {
    free_sbtree(&amp;((*sbtree)-&gt;less));
    free_sbtree(&amp;((*sbtree)-&gt;more));
    FREE(*sbtree);
  }
}


</t>
<t tx="karstenw.20210320123814.2">typedef enum                        /* Horizontal edge states            */
{
  NH,                               /* No horizontal edge                */
  BH,                               /* Bottom horizontal edge            */
  TH                                /* Top horizontal edge               */
} h_state;

</t>
<t tx="karstenw.20210320123814.20">static int count_optimal_vertices(gpc_vertex_list c)
{
  int result= 0, i;

  /* Ignore non-contributing contours */
  if (c.num_vertices &gt; 0)
  {
    for (i= 0; i &lt; c.num_vertices; i++)
      /* Ignore superfluous vertices embedded in horizontal edges */
      if (OPTIMAL(c.vertex, i, c.num_vertices))
        result++;
  }
  return result;
}


</t>
<t tx="karstenw.20210320123814.21">static edge_node *build_lmt(lmt_node **lmt, sb_tree **sbtree,
                            int *sbt_entries, gpc_polygon *p, int type,
                            gpc_op op)
{
  int          c, i, min, max, num_edges, v, num_vertices;
  int          total_vertices= 0, e_index=0;
  edge_node   *e, *edge_table;

  for (c= 0; c &lt; p-&gt;num_contours; c++)
    total_vertices+= count_optimal_vertices(p-&gt;contour[c]);

  /* Create the entire input polygon edge table in one go */
  MALLOC(edge_table, total_vertices * sizeof(edge_node),
       "edge table creation", edge_node);

  for (c= 0; c &lt; p-&gt;num_contours; c++)
  {
    if (p-&gt;contour[c].num_vertices &lt; 0)
    {
      /* Ignore the non-contributing contour and repair the vertex count */
      p-&gt;contour[c].num_vertices= -p-&gt;contour[c].num_vertices;
    }
    else
    {
      /* Perform contour optimisation */
      num_vertices= 0;
      for (i= 0; i &lt; p-&gt;contour[c].num_vertices; i++)
        if (OPTIMAL(p-&gt;contour[c].vertex, i, p-&gt;contour[c].num_vertices))
        {
          edge_table[num_vertices].vertex.x= p-&gt;contour[c].vertex[i].x;
          edge_table[num_vertices].vertex.y= p-&gt;contour[c].vertex[i].y;

          /* Record vertex in the scanbeam table */
          add_to_sbtree(sbt_entries, sbtree,
                        edge_table[num_vertices].vertex.y);

          num_vertices++;
        }

      /* Do the contour forward pass */
      for (min= 0; min &lt; num_vertices; min++)
      {
        /* If a forward local minimum... */
        if (FWD_MIN(edge_table, min, num_vertices))
        {
          /* Search for the next local maximum... */
          num_edges= 1;
          max= NEXT_INDEX(min, num_vertices);
          while (NOT_FMAX(edge_table, max, num_vertices))
          {
            num_edges++;
            max= NEXT_INDEX(max, num_vertices);
          }

          /* Build the next edge list */
          e= &amp;edge_table[e_index];
          e_index+= num_edges;
          v= min;
          e[0].bstate[BELOW]= UNBUNDLED;
          e[0].bundle[BELOW][CLIP]= FALSE;
          e[0].bundle[BELOW][SUBJ]= FALSE;
          for (i= 0; i &lt; num_edges; i++)
          {
            e[i].xb= edge_table[v].vertex.x;
            e[i].bot.x= edge_table[v].vertex.x;
            e[i].bot.y= edge_table[v].vertex.y;

            v= NEXT_INDEX(v, num_vertices);

            e[i].top.x= edge_table[v].vertex.x;
            e[i].top.y= edge_table[v].vertex.y;
            e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
                       (e[i].top.y - e[i].bot.y);
            e[i].type= type;
            e[i].outp[ABOVE]= NULL;
            e[i].outp[BELOW]= NULL;
            e[i].next= NULL;
            e[i].prev= NULL;
            e[i].succ= ((num_edges &gt; 1) &amp;&amp; (i &lt; (num_edges - 1))) ?
                       &amp;(e[i + 1]) : NULL;
            e[i].pred= ((num_edges &gt; 1) &amp;&amp; (i &gt; 0)) ? &amp;(e[i - 1]) : NULL;
            e[i].next_bound= NULL;
            e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
            e[i].bside[SUBJ]= LEFT;
          }
          insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
        }
      }

      /* Do the contour reverse pass */
      for (min= 0; min &lt; num_vertices; min++)
      {
      /* If a reverse local minimum... */
        if (REV_MIN(edge_table, min, num_vertices))
        {
          /* Search for the previous local maximum... */
          num_edges= 1;
          max= PREV_INDEX(min, num_vertices);
          while (NOT_RMAX(edge_table, max, num_vertices))
          {
            num_edges++;
            max= PREV_INDEX(max, num_vertices);
          }

          /* Build the previous edge list */
          e= &amp;edge_table[e_index];
          e_index+= num_edges;
          v= min;
          e[0].bstate[BELOW]= UNBUNDLED;
          e[0].bundle[BELOW][CLIP]= FALSE;
          e[0].bundle[BELOW][SUBJ]= FALSE;
          for (i= 0; i &lt; num_edges; i++)
          {
            e[i].xb= edge_table[v].vertex.x;
            e[i].bot.x= edge_table[v].vertex.x;
            e[i].bot.y= edge_table[v].vertex.y;

            v= PREV_INDEX(v, num_vertices);

            e[i].top.x= edge_table[v].vertex.x;
            e[i].top.y= edge_table[v].vertex.y;
            e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
                       (e[i].top.y - e[i].bot.y);
            e[i].type= type;
            e[i].outp[ABOVE]= NULL;
            e[i].outp[BELOW]= NULL;
            e[i].next= NULL;
            e[i].prev= NULL;
            e[i].succ= ((num_edges &gt; 1) &amp;&amp; (i &lt; (num_edges - 1))) ?
                       &amp;(e[i + 1]) : NULL;
            e[i].pred= ((num_edges &gt; 1) &amp;&amp; (i &gt; 0)) ? &amp;(e[i - 1]) : NULL;
            e[i].next_bound= NULL;
            e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
            e[i].bside[SUBJ]= LEFT;
          }
          insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
        }
      }
    }
  }
  return edge_table;
}


</t>
<t tx="karstenw.20210320123814.22">static void add_edge_to_aet(edge_node **aet, edge_node *edge, edge_node *prev)
{
  if (!*aet)
  {
    /* Append edge onto the tail end of the AET */
    *aet= edge;
    edge-&gt;prev= prev;
    edge-&gt;next= NULL;
  }
  else
  {
    /* Do primary sort on the xb field */
    if (edge-&gt;xb &lt; (*aet)-&gt;xb)
    {
      /* Insert edge here (before the AET edge) */
      edge-&gt;prev= prev;
      edge-&gt;next= *aet;
      (*aet)-&gt;prev= edge;
      *aet= edge;
    }
    else
    {
      if (edge-&gt;xb == (*aet)-&gt;xb)
      {
        /* Do secondary sort on the dx field */
        if (edge-&gt;dx &lt; (*aet)-&gt;dx)
        {
          /* Insert edge here (before the AET edge) */
          edge-&gt;prev= prev;
          edge-&gt;next= *aet;
          (*aet)-&gt;prev= edge;
          *aet= edge;
        }
        else
        {
          /* Head further into the AET */
          add_edge_to_aet(&amp;((*aet)-&gt;next), edge, *aet);
        }
      }
      else
      {
        /* Head further into the AET */
        add_edge_to_aet(&amp;((*aet)-&gt;next), edge, *aet);
      }
    }
  }
}


</t>
<t tx="karstenw.20210320123814.23">static void add_intersection(it_node **it, edge_node *edge0, edge_node *edge1,
                             double x, double y)
{
  it_node *existing_node;

  if (!*it)
  {
    /* Append a new node to the tail of the list */
    MALLOC(*it, sizeof(it_node), "IT insertion", it_node);
    (*it)-&gt;ie[0]= edge0;
    (*it)-&gt;ie[1]= edge1;
    (*it)-&gt;point.x= x;
    (*it)-&gt;point.y= y;
    (*it)-&gt;next= NULL;
  }
  else
  {
    if ((*it)-&gt;point.y &gt; y)
    {
      /* Insert a new node mid-list */
      existing_node= *it;
      MALLOC(*it, sizeof(it_node), "IT insertion", it_node);
      (*it)-&gt;ie[0]= edge0;
      (*it)-&gt;ie[1]= edge1;
      (*it)-&gt;point.x= x;
      (*it)-&gt;point.y= y;
      (*it)-&gt;next= existing_node;
    }
    else
      /* Head further down the list */
      add_intersection(&amp;((*it)-&gt;next), edge0, edge1, x, y);
  }
}


</t>
<t tx="karstenw.20210320123814.24">static void add_st_edge(st_node **st, it_node **it, edge_node *edge,
                        double dy)
{
  st_node *existing_node;
  double   den, r, x, y;

  if (!*st)
  {
    /* Append edge onto the tail end of the ST */
    MALLOC(*st, sizeof(st_node), "ST insertion", st_node);
    (*st)-&gt;edge= edge;
    (*st)-&gt;xb= edge-&gt;xb;
    (*st)-&gt;xt= edge-&gt;xt;
    (*st)-&gt;dx= edge-&gt;dx;
    (*st)-&gt;prev= NULL;
  }
  else
  {
    den= ((*st)-&gt;xt - (*st)-&gt;xb) - (edge-&gt;xt - edge-&gt;xb);

    /* If new edge and ST edge don't cross */
    if ((edge-&gt;xt &gt;= (*st)-&gt;xt) || (edge-&gt;dx == (*st)-&gt;dx) || 
        (fabs(den) &lt;= DBL_EPSILON))
    {
      /* No intersection - insert edge here (before the ST edge) */
      existing_node= *st;
      MALLOC(*st, sizeof(st_node), "ST insertion", st_node);
      (*st)-&gt;edge= edge;
      (*st)-&gt;xb= edge-&gt;xb;
      (*st)-&gt;xt= edge-&gt;xt;
      (*st)-&gt;dx= edge-&gt;dx;
      (*st)-&gt;prev= existing_node;
    }
    else
    {
      /* Compute intersection between new edge and ST edge */
      r= (edge-&gt;xb - (*st)-&gt;xb) / den;
      x= (*st)-&gt;xb + r * ((*st)-&gt;xt - (*st)-&gt;xb);
      y= r * dy;

      /* Insert the edge pointers and the intersection point in the IT */
      add_intersection(it, (*st)-&gt;edge, edge, x, y);

      /* Head further into the ST */
      add_st_edge(&amp;((*st)-&gt;prev), it, edge, dy);
    }
  }
}


</t>
<t tx="karstenw.20210320123814.25">static void build_intersection_table(it_node **it, edge_node *aet, double dy)
{
  st_node   *st, *stp;
  edge_node *edge;

  /* Build intersection table for the current scanbeam */
  reset_it(it);
  st= NULL;

  /* Process each AET edge */
  for (edge= aet; edge; edge= edge-&gt;next)
  {
    if ((edge-&gt;bstate[ABOVE] == BUNDLE_HEAD) ||
         edge-&gt;bundle[ABOVE][CLIP] || edge-&gt;bundle[ABOVE][SUBJ])
      add_st_edge(&amp;st, it, edge, dy);
  }

  /* Free the sorted edge table */
  while (st)
  {
    stp= st-&gt;prev;
    FREE(st);
    st= stp;
  }
}

</t>
<t tx="karstenw.20210320123814.26">static int count_contours(polygon_node *polygon)
{
  int          nc, nv;
  vertex_node *v, *nextv;

  for (nc= 0; polygon; polygon= polygon-&gt;next)
    if (polygon-&gt;active)
    {
      /* Count the vertices in the current contour */
      nv= 0;
      for (v= polygon-&gt;proxy-&gt;v[LEFT]; v; v= v-&gt;next)
        nv++;

      /* Record valid vertex counts in the active field */
      if (nv &gt; 2)
      {
        polygon-&gt;active= nv;
        nc++;
      }
      else
      {
        /* Invalid contour: just free the heap */
        for (v= polygon-&gt;proxy-&gt;v[LEFT]; v; v= nextv)
        {
          nextv= v-&gt;next;
          FREE(v);
        }
        polygon-&gt;active= 0;
      }
    }
  return nc;
}


</t>
<t tx="karstenw.20210320123814.27">static void add_left(polygon_node *p, double x, double y)
{
  vertex_node *nv;

  /* Create a new vertex node and set its fields */
  MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
  nv-&gt;x= x;
  nv-&gt;y= y;

  /* Add vertex nv to the left end of the polygon's vertex list */
  nv-&gt;next= p-&gt;proxy-&gt;v[LEFT];

  /* Update proxy-&gt;[LEFT] to point to nv */
  p-&gt;proxy-&gt;v[LEFT]= nv;
}


</t>
<t tx="karstenw.20210320123814.28">static void merge_left(polygon_node *p, polygon_node *q, polygon_node *list)
{
  polygon_node *target;

  /* Label contour as a hole */
  q-&gt;proxy-&gt;hole= TRUE;

  if (p-&gt;proxy != q-&gt;proxy)
  {
    /* Assign p's vertex list to the left end of q's list */
    p-&gt;proxy-&gt;v[RIGHT]-&gt;next= q-&gt;proxy-&gt;v[LEFT];
    q-&gt;proxy-&gt;v[LEFT]= p-&gt;proxy-&gt;v[LEFT];

    /* Redirect any p-&gt;proxy references to q-&gt;proxy */
    
    for (target= p-&gt;proxy; list; list= list-&gt;next)
    {
      if (list-&gt;proxy == target)
      {
        list-&gt;active= FALSE;
        list-&gt;proxy= q-&gt;proxy;
      }
    }
  }
}


</t>
<t tx="karstenw.20210320123814.29">static void add_right(polygon_node *p, double x, double y)
{
  vertex_node *nv;

  /* Create a new vertex node and set its fields */
  MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
  nv-&gt;x= x;
  nv-&gt;y= y;
  nv-&gt;next= NULL;

  /* Add vertex nv to the right end of the polygon's vertex list */
  p-&gt;proxy-&gt;v[RIGHT]-&gt;next= nv;

  /* Update proxy-&gt;v[RIGHT] to point to nv */
  p-&gt;proxy-&gt;v[RIGHT]= nv;
}


</t>
<t tx="karstenw.20210320123814.3">typedef enum                        /* Edge bundle state                 */
{
  UNBUNDLED,                        /* Isolated edge not within a bundle */
  BUNDLE_HEAD,                      /* Bundle head node                  */
  BUNDLE_TAIL                       /* Passive bundle tail node          */
} bundle_state;

</t>
<t tx="karstenw.20210320123814.30">static void merge_right(polygon_node *p, polygon_node *q, polygon_node *list)
{
  polygon_node *target;

  /* Label contour as external */
  q-&gt;proxy-&gt;hole= FALSE;

  if (p-&gt;proxy != q-&gt;proxy)
  {
    /* Assign p's vertex list to the right end of q's list */
    q-&gt;proxy-&gt;v[RIGHT]-&gt;next= p-&gt;proxy-&gt;v[LEFT];
    q-&gt;proxy-&gt;v[RIGHT]= p-&gt;proxy-&gt;v[RIGHT];

    /* Redirect any p-&gt;proxy references to q-&gt;proxy */
    for (target= p-&gt;proxy; list; list= list-&gt;next)
    {
      if (list-&gt;proxy == target)
      {
        list-&gt;active= FALSE;
        list-&gt;proxy= q-&gt;proxy;
      }
    }
  }
}


</t>
<t tx="karstenw.20210320123814.31">static void add_local_min(polygon_node **p, edge_node *edge,
                          double x, double y)
{
  polygon_node *existing_min;
  vertex_node  *nv;

  existing_min= *p;

  MALLOC(*p, sizeof(polygon_node), "polygon node creation", polygon_node);

  /* Create a new vertex node and set its fields */
  MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);
  nv-&gt;x= x;
  nv-&gt;y= y;
  nv-&gt;next= NULL;

  /* Initialise proxy to point to p itself */
  (*p)-&gt;proxy= (*p);
  (*p)-&gt;active= TRUE;
  (*p)-&gt;next= existing_min;

  /* Make v[LEFT] and v[RIGHT] point to new vertex nv */
  (*p)-&gt;v[LEFT]= nv;
  (*p)-&gt;v[RIGHT]= nv;

  /* Assign polygon p to the edge */
  edge-&gt;outp[ABOVE]= *p;
}


</t>
<t tx="karstenw.20210320123814.32">static int count_tristrips(polygon_node *tn)
{
  int total;

  for (total= 0; tn; tn= tn-&gt;next)
    if (tn-&gt;active &gt; 2)
      total++;
  return total;
}


</t>
<t tx="karstenw.20210320123814.33">static void add_vertex(vertex_node **t, double x, double y)
{
  if (!(*t))
  {
    MALLOC(*t, sizeof(vertex_node), "tristrip vertex creation", vertex_node);
    (*t)-&gt;x= x;
    (*t)-&gt;y= y;
    (*t)-&gt;next= NULL;
  }
  else
    /* Head further down the list */
    add_vertex(&amp;((*t)-&gt;next), x, y);
}


</t>
<t tx="karstenw.20210320123814.34">static void new_tristrip(polygon_node **tn, edge_node *edge,
                         double x, double y)
{
  if (!(*tn))
  {
    MALLOC(*tn, sizeof(polygon_node), "tristrip node creation", polygon_node);
    (*tn)-&gt;next= NULL;
    (*tn)-&gt;v[LEFT]= NULL;
    (*tn)-&gt;v[RIGHT]= NULL;
    (*tn)-&gt;active= 1;
    add_vertex(&amp;((*tn)-&gt;v[LEFT]), x, y); 
    edge-&gt;outp[ABOVE]= *tn;
  }
  else
    /* Head further down the list */
    new_tristrip(&amp;((*tn)-&gt;next), edge, x, y);
}


</t>
<t tx="karstenw.20210320123814.35">static bbox *create_contour_bboxes(gpc_polygon *p)
{
  bbox *box;
  int   c, v;

  MALLOC(box, p-&gt;num_contours * sizeof(bbox), "Bounding box creation", bbox);

  /* Construct contour bounding boxes */
  for (c= 0; c &lt; p-&gt;num_contours; c++)
  {
    /* Initialise bounding box extent */
    box[c].xmin= DBL_MAX;
    box[c].ymin= DBL_MAX;
    box[c].xmax= -DBL_MAX;
    box[c].ymax= -DBL_MAX;

    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
    {
      /* Adjust bounding box */
      if (p-&gt;contour[c].vertex[v].x &lt; box[c].xmin)
        box[c].xmin= p-&gt;contour[c].vertex[v].x;
      if (p-&gt;contour[c].vertex[v].y &lt; box[c].ymin)
        box[c].ymin= p-&gt;contour[c].vertex[v].y;
      if (p-&gt;contour[c].vertex[v].x &gt; box[c].xmax)
        box[c].xmax= p-&gt;contour[c].vertex[v].x;
      if (p-&gt;contour[c].vertex[v].y &gt; box[c].ymax)
          box[c].ymax= p-&gt;contour[c].vertex[v].y;
    }
  }
  return box;  
}


</t>
<t tx="karstenw.20210320123814.36">static void minimax_test(gpc_polygon *subj, gpc_polygon *clip, gpc_op op)
{
  bbox *s_bbox, *c_bbox;
  int   s, c, *o_table, overlap;

  s_bbox= create_contour_bboxes(subj);
  c_bbox= create_contour_bboxes(clip);

  MALLOC(o_table, subj-&gt;num_contours * clip-&gt;num_contours * sizeof(int),
         "overlap table creation", int);

  /* Check all subject contour bounding boxes against clip boxes */
  for (s= 0; s &lt; subj-&gt;num_contours; s++)
    for (c= 0; c &lt; clip-&gt;num_contours; c++)
      o_table[c * subj-&gt;num_contours + s]=
             (!((s_bbox[s].xmax &lt; c_bbox[c].xmin) ||
                (s_bbox[s].xmin &gt; c_bbox[c].xmax))) &amp;&amp;
             (!((s_bbox[s].ymax &lt; c_bbox[c].ymin) ||
                (s_bbox[s].ymin &gt; c_bbox[c].ymax)));

  /* For each clip contour, search for any subject contour overlaps */
  for (c= 0; c &lt; clip-&gt;num_contours; c++)
  {
    overlap= 0;
    for (s= 0; (!overlap) &amp;&amp; (s &lt; subj-&gt;num_contours); s++)
      overlap= o_table[c * subj-&gt;num_contours + s];

    if (!overlap)
      /* Flag non contributing status by negating vertex count */
      clip-&gt;contour[c].num_vertices = -clip-&gt;contour[c].num_vertices;
  }  

  if (op == GPC_INT)
  {  
    /* For each subject contour, search for any clip contour overlaps */
    for (s= 0; s &lt; subj-&gt;num_contours; s++)
    {
      overlap= 0;
      for (c= 0; (!overlap) &amp;&amp; (c &lt; clip-&gt;num_contours); c++)
        overlap= o_table[c * subj-&gt;num_contours + s];

      if (!overlap)
        /* Flag non contributing status by negating vertex count */
        subj-&gt;contour[s].num_vertices = -subj-&gt;contour[s].num_vertices;
    }  
  }

  FREE(s_bbox);
  FREE(c_bbox);
  FREE(o_table);
}


/*
===========================================================================
                             Public Functions
===========================================================================
*/

</t>
<t tx="karstenw.20210320123814.37">void gpc_free_polygon(gpc_polygon *p)
{
  int c;

  for (c= 0; c &lt; p-&gt;num_contours; c++)
    FREE(p-&gt;contour[c].vertex);
  // FDB: pointer being freed was not allocated
  // This causes a memory leak, but better than crashing.
  // FREE(p-&gt;hole);
  FREE(p-&gt;contour);
  p-&gt;num_contours= 0;
}


</t>
<t tx="karstenw.20210320123814.38">void gpc_read_polygon(FILE *fp, int read_hole_flags, gpc_polygon *p)
{
  int c, v;

  fscanf(fp, "%d", &amp;(p-&gt;num_contours));
  MALLOC(p-&gt;hole, p-&gt;num_contours * sizeof(int),
         "hole flag array creation", int);
  MALLOC(p-&gt;contour, p-&gt;num_contours
         * sizeof(gpc_vertex_list), "contour creation", gpc_vertex_list);
  for (c= 0; c &lt; p-&gt;num_contours; c++)
  {
    fscanf(fp, "%d", &amp;(p-&gt;contour[c].num_vertices));

    if (read_hole_flags)
      fscanf(fp, "%d", &amp;(p-&gt;hole[c]));
    else
      p-&gt;hole[c]= FALSE; /* Assume all contours to be external */

    MALLOC(p-&gt;contour[c].vertex, p-&gt;contour[c].num_vertices
           * sizeof(gpc_vertex), "vertex creation", gpc_vertex);
    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
      fscanf(fp, "%lf %lf", &amp;(p-&gt;contour[c].vertex[v].x),
                            &amp;(p-&gt;contour[c].vertex[v].y));
  }
}


</t>
<t tx="karstenw.20210320123814.39">void gpc_write_polygon(FILE *fp, int write_hole_flags, gpc_polygon *p)
{
  int c, v;

  fprintf(fp, "%d\n", p-&gt;num_contours);
  for (c= 0; c &lt; p-&gt;num_contours; c++)
  {
    fprintf(fp, "%d\n", p-&gt;contour[c].num_vertices);

    if (write_hole_flags)
      fprintf(fp, "%d\n", p-&gt;hole[c]);
    
    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
      fprintf(fp, "% .*lf % .*lf\n",
              DBL_DIG, p-&gt;contour[c].vertex[v].x,
              DBL_DIG, p-&gt;contour[c].vertex[v].y);
  }
}


</t>
<t tx="karstenw.20210320123814.4">typedef struct v_shape              /* Internal vertex list datatype     */
{
  double              x;            /* X coordinate component            */
  double              y;            /* Y coordinate component            */
  struct v_shape     *next;         /* Pointer to next vertex in list    */
} vertex_node;

</t>
<t tx="karstenw.20210320123814.40">void gpc_add_contour(gpc_polygon *p, gpc_vertex_list *new_contour, int hole)
{
  int             *extended_hole, c, v;
  gpc_vertex_list *extended_contour;

  /* Create an extended hole array */
  MALLOC(extended_hole, (p-&gt;num_contours + 1)
         * sizeof(int), "contour hole addition", int);

  /* Create an extended contour array */
  MALLOC(extended_contour, (p-&gt;num_contours + 1)
         * sizeof(gpc_vertex_list), "contour addition", gpc_vertex_list);

  /* Copy the old contour and hole data into the extended arrays */
  for (c= 0; c &lt; p-&gt;num_contours; c++)
  {
    extended_hole[c]= p-&gt;hole[c];
    extended_contour[c]= p-&gt;contour[c];
  }

  /* Copy the new contour and hole onto the end of the extended arrays */
  c= p-&gt;num_contours;
  extended_hole[c]= hole;
  extended_contour[c].num_vertices= new_contour-&gt;num_vertices;
  MALLOC(extended_contour[c].vertex, new_contour-&gt;num_vertices
         * sizeof(gpc_vertex), "contour addition", gpc_vertex);
  for (v= 0; v &lt; new_contour-&gt;num_vertices; v++)
    extended_contour[c].vertex[v]= new_contour-&gt;vertex[v];

  /* Dispose of the old contour */
  FREE(p-&gt;contour);
  FREE(p-&gt;hole);

  /* Update the polygon information */
  p-&gt;num_contours++;
  p-&gt;hole= extended_hole;
  p-&gt;contour= extended_contour;
}


</t>
<t tx="karstenw.20210320123814.41">void gpc_polygon_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
                      gpc_polygon *result)
{
  sb_tree       *sbtree= NULL;
  it_node       *it= NULL, *intersect;
  edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
  edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL;
  lmt_node      *lmt= NULL, *local_min;
  polygon_node  *out_poly= NULL, *p, *q, *poly, *npoly, *cf= NULL;
  vertex_node   *vtx, *nv;
  h_state        horiz[2];
  int            in[2], exists[2], parity[2]= {LEFT, LEFT};
  int            c, v, contributing, search, scanbeam= 0, sbt_entries= 0;
  int            vclass, bl, br, tl, tr;
  double        *sbt= NULL, xb, px, yb, yt, dy, ix, iy;

  /* Test for trivial NULL result cases */
  if (((subj-&gt;num_contours == 0) &amp;&amp; (clip-&gt;num_contours == 0))
   || ((subj-&gt;num_contours == 0) &amp;&amp; ((op == GPC_INT) || (op == GPC_DIFF)))
   || ((clip-&gt;num_contours == 0) &amp;&amp;  (op == GPC_INT)))
  {
    result-&gt;num_contours= 0;
    result-&gt;hole= NULL;
    result-&gt;contour= NULL;
    return;
  }

  /* Identify potentialy contributing contours */
  if (((op == GPC_INT) || (op == GPC_DIFF))
   &amp;&amp; (subj-&gt;num_contours &gt; 0) &amp;&amp; (clip-&gt;num_contours &gt; 0))
    minimax_test(subj, clip, op);

  /* Build LMT */
  if (subj-&gt;num_contours &gt; 0)
    s_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, subj, SUBJ, op);
  if (clip-&gt;num_contours &gt; 0)
    c_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, clip, CLIP, op);

  /* Return a NULL result if no contours contribute */
  if (lmt == NULL)
  {
    result-&gt;num_contours= 0;
    result-&gt;hole= NULL;
    result-&gt;contour= NULL;
    reset_lmt(&amp;lmt);
    FREE(s_heap);
    FREE(c_heap);
    return;
  }

  /* Build scanbeam table from scanbeam tree */
  MALLOC(sbt, sbt_entries * sizeof(double), "sbt creation", double);
  build_sbt(&amp;scanbeam, sbt, sbtree);
  scanbeam= 0;
  free_sbtree(&amp;sbtree);

  /* Allow pointer re-use without causing memory leak */
  if (subj == result)
    gpc_free_polygon(subj);
  if (clip == result)
    gpc_free_polygon(clip);

  /* Invert clip polygon for difference operation */
  if (op == GPC_DIFF)
    parity[CLIP]= RIGHT;

  local_min= lmt;

  /* Process each scanbeam */
  while (scanbeam &lt; sbt_entries)
  {
    /* Set yb and yt to the bottom and top of the scanbeam */
    yb= sbt[scanbeam++];
    if (scanbeam &lt; sbt_entries)
    {
      yt= sbt[scanbeam];
      dy= yt - yb;
    }

    /* === SCANBEAM BOUNDARY PROCESSING ================================ */

    /* If LMT node corresponding to yb exists */
    if (local_min)
    {
      if (local_min-&gt;y == yb)
      {
        /* Add edges starting at this local minimum to the AET */
        for (edge= local_min-&gt;first_bound; edge; edge= edge-&gt;next_bound)
          add_edge_to_aet(&amp;aet, edge, NULL);

        local_min= local_min-&gt;next;
      }
    }

    /* Set dummy previous x value */
    px= -DBL_MAX;

    /* Create bundles within AET */
    e0= aet;
    e1= aet;

    /* Set up bundle fields of first edge */
    aet-&gt;bundle[ABOVE][ aet-&gt;type]= (aet-&gt;top.y != yb);
    aet-&gt;bundle[ABOVE][!aet-&gt;type]= FALSE;
    aet-&gt;bstate[ABOVE]= UNBUNDLED;

    for (next_edge= aet-&gt;next; next_edge; next_edge= next_edge-&gt;next)
    {
      /* Set up bundle fields of next edge */
      next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]= (next_edge-&gt;top.y != yb);
      next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= FALSE;
      next_edge-&gt;bstate[ABOVE]= UNBUNDLED;

      /* Bundle edges above the scanbeam boundary if they coincide */
      if (next_edge-&gt;bundle[ABOVE][next_edge-&gt;type])
      {
        if (EQ(e0-&gt;xb, next_edge-&gt;xb) &amp;&amp; EQ(e0-&gt;dx, next_edge-&gt;dx)
     &amp;&amp; (e0-&gt;top.y != yb))
        {
          next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]^= 
            e0-&gt;bundle[ABOVE][ next_edge-&gt;type];
          next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= 
            e0-&gt;bundle[ABOVE][!next_edge-&gt;type];
          next_edge-&gt;bstate[ABOVE]= BUNDLE_HEAD;
          e0-&gt;bundle[ABOVE][CLIP]= FALSE;
          e0-&gt;bundle[ABOVE][SUBJ]= FALSE;
          e0-&gt;bstate[ABOVE]= BUNDLE_TAIL;
        }
        e0= next_edge;
      }
    }
    
    horiz[CLIP]= NH;
    horiz[SUBJ]= NH;

    /* Process each edge at this scanbeam boundary */
    for (edge= aet; edge; edge= edge-&gt;next)
    {
      exists[CLIP]= edge-&gt;bundle[ABOVE][CLIP] + 
                   (edge-&gt;bundle[BELOW][CLIP] &lt;&lt; 1);
      exists[SUBJ]= edge-&gt;bundle[ABOVE][SUBJ] + 
                   (edge-&gt;bundle[BELOW][SUBJ] &lt;&lt; 1);

      if (exists[CLIP] || exists[SUBJ])
      {
        /* Set bundle side */
        edge-&gt;bside[CLIP]= parity[CLIP];
        edge-&gt;bside[SUBJ]= parity[SUBJ];

        /* Determine contributing status and quadrant occupancies */
        switch (op)
        {
        case GPC_DIFF:
        case GPC_INT:
          contributing= (exists[CLIP] &amp;&amp; (parity[SUBJ] || horiz[SUBJ]))
                     || (exists[SUBJ] &amp;&amp; (parity[CLIP] || horiz[CLIP]))
                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
          br= (parity[CLIP])
           &amp;&amp; (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
           &amp;&amp; (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP]) 
           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        case GPC_XOR:
          contributing= exists[CLIP] || exists[SUBJ];
          br= (parity[CLIP])
            ^ (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
            ^ (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP]) 
            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        case GPC_UNION:
          contributing= (exists[CLIP] &amp;&amp; (!parity[SUBJ] || horiz[SUBJ]))
                     || (exists[SUBJ] &amp;&amp; (!parity[CLIP] || horiz[CLIP]))
                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
          br= (parity[CLIP])
           || (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
           || (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP]) 
           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        }

        /* Update parity */
        parity[CLIP]^= edge-&gt;bundle[ABOVE][CLIP];
        parity[SUBJ]^= edge-&gt;bundle[ABOVE][SUBJ];

        /* Update horizontal state */
        if (exists[CLIP])         
          horiz[CLIP]=
            next_h_state[horiz[CLIP]]
                        [((exists[CLIP] - 1) &lt;&lt; 1) + parity[CLIP]];
        if (exists[SUBJ])         
          horiz[SUBJ]=
            next_h_state[horiz[SUBJ]]
                        [((exists[SUBJ] - 1) &lt;&lt; 1) + parity[SUBJ]];

        vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);

        if (contributing)
        {
          xb= edge-&gt;xb;

          switch (vclass)
          {
          case EMN:
          case IMN:
            add_local_min(&amp;out_poly, edge, xb, yb);
            px= xb;
            cf= edge-&gt;outp[ABOVE];
            break;
          case ERI:
            if (xb != px)
            {
              add_right(cf, xb, yb);
              px= xb;
            }
            edge-&gt;outp[ABOVE]= cf;
            cf= NULL;
            break;
          case ELI:
            add_left(edge-&gt;outp[BELOW], xb, yb);
            px= xb;
            cf= edge-&gt;outp[BELOW];
            break;
          case EMX:
            if (xb != px)
            {
              add_left(cf, xb, yb);
              px= xb;
            }
            merge_right(cf, edge-&gt;outp[BELOW], out_poly);
            cf= NULL;
            break;
          case ILI:
            if (xb != px)
            {
              add_left(cf, xb, yb);
              px= xb;
            }
            edge-&gt;outp[ABOVE]= cf;
            cf= NULL;
            break;
          case IRI:
            add_right(edge-&gt;outp[BELOW], xb, yb);
            px= xb;
            cf= edge-&gt;outp[BELOW];
            edge-&gt;outp[BELOW]= NULL;
            break;
          case IMX:
            if (xb != px)
            {
              add_right(cf, xb, yb);
              px= xb;
            }
            merge_left(cf, edge-&gt;outp[BELOW], out_poly);
            cf= NULL;
            edge-&gt;outp[BELOW]= NULL;
            break;
          case IMM:
            if (xb != px)
        {
              add_right(cf, xb, yb);
              px= xb;
        }
            merge_left(cf, edge-&gt;outp[BELOW], out_poly);
            edge-&gt;outp[BELOW]= NULL;
            add_local_min(&amp;out_poly, edge, xb, yb);
            cf= edge-&gt;outp[ABOVE];
            break;
          case EMM:
            if (xb != px)
        {
              add_left(cf, xb, yb);
              px= xb;
        }
            merge_right(cf, edge-&gt;outp[BELOW], out_poly);
            edge-&gt;outp[BELOW]= NULL;
            add_local_min(&amp;out_poly, edge, xb, yb);
            cf= edge-&gt;outp[ABOVE];
            break;
          case LED:
            if (edge-&gt;bot.y == yb)
              add_left(edge-&gt;outp[BELOW], xb, yb);
            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
            px= xb;
            break;
          case RED:
            if (edge-&gt;bot.y == yb)
              add_right(edge-&gt;outp[BELOW], xb, yb);
            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
            px= xb;
            break;
          default:
            break;
          } /* End of switch */
        } /* End of contributing conditional */
      } /* End of edge exists conditional */
    } /* End of AET loop */

    /* Delete terminating edges from the AET, otherwise compute xt */
    for (edge= aet; edge; edge= edge-&gt;next)
    {
      if (edge-&gt;top.y == yb)
      {
        prev_edge= edge-&gt;prev;
        next_edge= edge-&gt;next;
        if (prev_edge)
          prev_edge-&gt;next= next_edge;
        else
          aet= next_edge;
        if (next_edge)
          next_edge-&gt;prev= prev_edge;

        /* Copy bundle head state to the adjacent tail edge if required */
        if ((edge-&gt;bstate[BELOW] == BUNDLE_HEAD) &amp;&amp; prev_edge)
    {
          if (prev_edge-&gt;bstate[BELOW] == BUNDLE_TAIL)
          {
            prev_edge-&gt;outp[BELOW]= edge-&gt;outp[BELOW];
            prev_edge-&gt;bstate[BELOW]= UNBUNDLED;
            if (prev_edge-&gt;prev)
              if (prev_edge-&gt;prev-&gt;bstate[BELOW] == BUNDLE_TAIL)
                prev_edge-&gt;bstate[BELOW]= BUNDLE_HEAD;
      }
    }
      }
      else
      {
        if (edge-&gt;top.y == yt)
          edge-&gt;xt= edge-&gt;top.x;
        else
          edge-&gt;xt= edge-&gt;bot.x + edge-&gt;dx * (yt - edge-&gt;bot.y);
      }
    }

    if (scanbeam &lt; sbt_entries)
    {
      /* === SCANBEAM INTERIOR PROCESSING ============================== */

      build_intersection_table(&amp;it, aet, dy);

      /* Process each node in the intersection table */
      for (intersect= it; intersect; intersect= intersect-&gt;next)
      {
        e0= intersect-&gt;ie[0];
        e1= intersect-&gt;ie[1];

        /* Only generate output for contributing intersections */
        if ((e0-&gt;bundle[ABOVE][CLIP] || e0-&gt;bundle[ABOVE][SUBJ])
         &amp;&amp; (e1-&gt;bundle[ABOVE][CLIP] || e1-&gt;bundle[ABOVE][SUBJ]))
    {
          p= e0-&gt;outp[ABOVE];
          q= e1-&gt;outp[ABOVE];
          ix= intersect-&gt;point.x;
          iy= intersect-&gt;point.y + yb;
 
          in[CLIP]= ( e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e0-&gt;bside[CLIP])
                 || ( e1-&gt;bundle[ABOVE][CLIP] &amp;&amp;  e1-&gt;bside[CLIP])
                 || (!e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e1-&gt;bundle[ABOVE][CLIP]
                     &amp;&amp; e0-&gt;bside[CLIP] &amp;&amp; e1-&gt;bside[CLIP]);
          in[SUBJ]= ( e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e0-&gt;bside[SUBJ])
                 || ( e1-&gt;bundle[ABOVE][SUBJ] &amp;&amp;  e1-&gt;bside[SUBJ])
                 || (!e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e1-&gt;bundle[ABOVE][SUBJ]
                     &amp;&amp; e0-&gt;bside[SUBJ] &amp;&amp; e1-&gt;bside[SUBJ]);
       
          /* Determine quadrant occupancies */
          switch (op)
          {
          case GPC_DIFF:
          case GPC_INT:
            tr= (in[CLIP])
             &amp;&amp; (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          case GPC_XOR:
            tr= (in[CLIP])
              ^ (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          case GPC_UNION:
            tr= (in[CLIP])
             || (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          }
      
          vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);

          switch (vclass)
          {
          case EMN:
            add_local_min(&amp;out_poly, e0, ix, iy);
            e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
            break;
          case ERI:
            if (p)
            {
              add_right(p, ix, iy);
              e1-&gt;outp[ABOVE]= p;
              e0-&gt;outp[ABOVE]= NULL;
            }
            break;
          case ELI:
            if (q)
            {
              add_left(q, ix, iy);
              e0-&gt;outp[ABOVE]= q;
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case EMX:
            if (p &amp;&amp; q)
            {
              add_left(p, ix, iy);
              merge_right(p, q, out_poly);
              e0-&gt;outp[ABOVE]= NULL;
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IMN:
            add_local_min(&amp;out_poly, e0, ix, iy);
            e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
            break;
          case ILI:
            if (p)
            {
              add_left(p, ix, iy);
              e1-&gt;outp[ABOVE]= p;
              e0-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IRI:
            if (q)
            {
              add_right(q, ix, iy);
              e0-&gt;outp[ABOVE]= q;
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IMX:
            if (p &amp;&amp; q)
            {
              add_right(p, ix, iy);
              merge_left(p, q, out_poly);
              e0-&gt;outp[ABOVE]= NULL;
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IMM:
            if (p &amp;&amp; q)
            {
              add_right(p, ix, iy);
              merge_left(p, q, out_poly);
              add_local_min(&amp;out_poly, e0, ix, iy);
              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
            }
            break;
          case EMM:
            if (p &amp;&amp; q)
            {
              add_left(p, ix, iy);
              merge_right(p, q, out_poly);
              add_local_min(&amp;out_poly, e0, ix, iy);
              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
            }
            break;
          default:
            break;
          } /* End of switch */
    } /* End of contributing intersection conditional */

        /* Swap bundle sides in response to edge crossing */
        if (e0-&gt;bundle[ABOVE][CLIP])
      e1-&gt;bside[CLIP]= !e1-&gt;bside[CLIP];
        if (e1-&gt;bundle[ABOVE][CLIP])
      e0-&gt;bside[CLIP]= !e0-&gt;bside[CLIP];
        if (e0-&gt;bundle[ABOVE][SUBJ])
      e1-&gt;bside[SUBJ]= !e1-&gt;bside[SUBJ];
        if (e1-&gt;bundle[ABOVE][SUBJ])
      e0-&gt;bside[SUBJ]= !e0-&gt;bside[SUBJ];

        /* Swap e0 and e1 bundles in the AET */
        prev_edge= e0-&gt;prev;
        next_edge= e1-&gt;next;
        if (next_edge)
          next_edge-&gt;prev= e0;

        if (e0-&gt;bstate[ABOVE] == BUNDLE_HEAD)
        {
          search= TRUE;
          while (search)
          {
            prev_edge= prev_edge-&gt;prev;
            if (prev_edge)
            {
              if (prev_edge-&gt;bstate[ABOVE] != BUNDLE_TAIL)
                search= FALSE;
            }
            else
              search= FALSE;
          }
        }
        if (!prev_edge)
        {
          aet-&gt;prev= e1;
          e1-&gt;next= aet;
          aet= e0-&gt;next;
        }
        else
        {
          prev_edge-&gt;next-&gt;prev= e1;
          e1-&gt;next= prev_edge-&gt;next;
          prev_edge-&gt;next= e0-&gt;next;
        }
        e0-&gt;next-&gt;prev= prev_edge;
        e1-&gt;next-&gt;prev= e1;
        e0-&gt;next= next_edge;
      } /* End of IT loop*/

      /* Prepare for next scanbeam */
      for (edge= aet; edge; edge= next_edge)
      {
        next_edge= edge-&gt;next;
        succ_edge= edge-&gt;succ;

        if ((edge-&gt;top.y == yt) &amp;&amp; succ_edge)
        {
          /* Replace AET edge by its successor */
          succ_edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
          succ_edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
          succ_edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
          succ_edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
          prev_edge= edge-&gt;prev;
          if (prev_edge)
            prev_edge-&gt;next= succ_edge;
          else
            aet= succ_edge;
          if (next_edge)
            next_edge-&gt;prev= succ_edge;
          succ_edge-&gt;prev= prev_edge;
          succ_edge-&gt;next= next_edge;
        }
        else
        {
          /* Update this edge */
          edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
          edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
          edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
          edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
          edge-&gt;xb= edge-&gt;xt;
          }
        edge-&gt;outp[ABOVE]= NULL;
      }
    }
  } /* === END OF SCANBEAM PROCESSING ================================== */

  /* Generate result polygon from out_poly */
  result-&gt;contour= NULL;
  result-&gt;hole= NULL;
  result-&gt;num_contours= count_contours(out_poly);
  if (result-&gt;num_contours &gt; 0)
  {
    MALLOC(result-&gt;hole, result-&gt;num_contours
           * sizeof(int), "hole flag table creation", int);
    MALLOC(result-&gt;contour, result-&gt;num_contours
           * sizeof(gpc_vertex_list), "contour creation", gpc_vertex_list);

    c= 0;
    for (poly= out_poly; poly; poly= npoly)
    {
      npoly= poly-&gt;next;
      if (poly-&gt;active)
      {
        result-&gt;hole[c]= poly-&gt;proxy-&gt;hole;
        result-&gt;contour[c].num_vertices= poly-&gt;active;
        MALLOC(result-&gt;contour[c].vertex,
          result-&gt;contour[c].num_vertices * sizeof(gpc_vertex),
          "vertex creation", gpc_vertex);
      
        v= result-&gt;contour[c].num_vertices - 1;
        for (vtx= poly-&gt;proxy-&gt;v[LEFT]; vtx; vtx= nv)
        {
          nv= vtx-&gt;next;
          result-&gt;contour[c].vertex[v].x= vtx-&gt;x;
          result-&gt;contour[c].vertex[v].y= vtx-&gt;y;
          FREE(vtx);
          v--;
        }
        c++;
      }
      FREE(poly);
    }
  }
  else
  {
    for (poly= out_poly; poly; poly= npoly)
    {
      npoly= poly-&gt;next;
      FREE(poly);
    }
  }

  /* Tidy up */
  reset_it(&amp;it);
  reset_lmt(&amp;lmt);
  FREE(c_heap);
  FREE(s_heap);
  FREE(sbt);
}


</t>
<t tx="karstenw.20210320123814.42">void gpc_free_tristrip(gpc_tristrip *t)
{
  int s;

  for (s= 0; s &lt; t-&gt;num_strips; s++)
    FREE(t-&gt;strip[s].vertex);
  FREE(t-&gt;strip);
  t-&gt;num_strips= 0;
}


</t>
<t tx="karstenw.20210320123814.43">void gpc_polygon_to_tristrip(gpc_polygon *s, gpc_tristrip *t)
{
  gpc_polygon c;

  c.num_contours= 0;
  c.hole= NULL;
  c.contour= NULL;
  gpc_tristrip_clip(GPC_DIFF, s, &amp;c, t);
}


</t>
<t tx="karstenw.20210320123814.44">void gpc_tristrip_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
                       gpc_tristrip *result)
{
  sb_tree       *sbtree= NULL;
  it_node       *it= NULL, *intersect;
  edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
  edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL, *cf;
  lmt_node      *lmt= NULL, *local_min;
  polygon_node  *tlist= NULL, *tn, *tnn, *p, *q;
  vertex_node   *lt, *ltn, *rt, *rtn;
  h_state        horiz[2];
  vertex_type    cft;
  int            in[2], exists[2], parity[2]= {LEFT, LEFT};
  int            s, v, contributing, search, scanbeam= 0, sbt_entries= 0;
  int            vclass, bl, br, tl, tr;
  double        *sbt= NULL, xb, px, nx, yb, yt, dy, ix, iy;

  /* Test for trivial NULL result cases */
  if (((subj-&gt;num_contours == 0) &amp;&amp; (clip-&gt;num_contours == 0))
   || ((subj-&gt;num_contours == 0) &amp;&amp; ((op == GPC_INT) || (op == GPC_DIFF)))
   || ((clip-&gt;num_contours == 0) &amp;&amp;  (op == GPC_INT)))
  {
    result-&gt;num_strips= 0;
    result-&gt;strip= NULL;
    return;
  }

  /* Identify potentialy contributing contours */
  if (((op == GPC_INT) || (op == GPC_DIFF))
   &amp;&amp; (subj-&gt;num_contours &gt; 0) &amp;&amp; (clip-&gt;num_contours &gt; 0))
    minimax_test(subj, clip, op);

  /* Build LMT */
  if (subj-&gt;num_contours &gt; 0)
    s_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, subj, SUBJ, op);
  if (clip-&gt;num_contours &gt; 0)
    c_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, clip, CLIP, op);

  /* Return a NULL result if no contours contribute */
  if (lmt == NULL)
  {
    result-&gt;num_strips= 0;
    result-&gt;strip= NULL;
    reset_lmt(&amp;lmt);
    FREE(s_heap);
    FREE(c_heap);
    return;
  }

  /* Build scanbeam table from scanbeam tree */
  MALLOC(sbt, sbt_entries * sizeof(double), "sbt creation", double);
  build_sbt(&amp;scanbeam, sbt, sbtree);
  scanbeam= 0;
  free_sbtree(&amp;sbtree);

  /* Invert clip polygon for difference operation */
  if (op == GPC_DIFF)
    parity[CLIP]= RIGHT;

  local_min= lmt;

  /* Process each scanbeam */
  while (scanbeam &lt; sbt_entries)
  {
    /* Set yb and yt to the bottom and top of the scanbeam */
    yb= sbt[scanbeam++];
    if (scanbeam &lt; sbt_entries)
    {
      yt= sbt[scanbeam];
      dy= yt - yb;
    }

    /* === SCANBEAM BOUNDARY PROCESSING ================================ */

    /* If LMT node corresponding to yb exists */
    if (local_min)
    {
      if (local_min-&gt;y == yb)
      {
        /* Add edges starting at this local minimum to the AET */
        for (edge= local_min-&gt;first_bound; edge; edge= edge-&gt;next_bound)
          add_edge_to_aet(&amp;aet, edge, NULL);

        local_min= local_min-&gt;next;
      }
    }

    /* Set dummy previous x value */
    px= -DBL_MAX;

    /* Create bundles within AET */
    e0= aet;
    e1= aet;

    /* Set up bundle fields of first edge */
    aet-&gt;bundle[ABOVE][ aet-&gt;type]= (aet-&gt;top.y != yb);
    aet-&gt;bundle[ABOVE][!aet-&gt;type]= FALSE;
    aet-&gt;bstate[ABOVE]= UNBUNDLED;

    for (next_edge= aet-&gt;next; next_edge; next_edge= next_edge-&gt;next)
    {
      /* Set up bundle fields of next edge */
      next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]= (next_edge-&gt;top.y != yb);
      next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= FALSE;
      next_edge-&gt;bstate[ABOVE]= UNBUNDLED;

      /* Bundle edges above the scanbeam boundary if they coincide */
      if (next_edge-&gt;bundle[ABOVE][next_edge-&gt;type])
      {
        if (EQ(e0-&gt;xb, next_edge-&gt;xb) &amp;&amp; EQ(e0-&gt;dx, next_edge-&gt;dx)
     &amp;&amp; (e0-&gt;top.y != yb))
        {
          next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]^= 
            e0-&gt;bundle[ABOVE][ next_edge-&gt;type];
          next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= 
            e0-&gt;bundle[ABOVE][!next_edge-&gt;type]; 
          next_edge-&gt;bstate[ABOVE]= BUNDLE_HEAD;
          e0-&gt;bundle[ABOVE][CLIP]= FALSE;
          e0-&gt;bundle[ABOVE][SUBJ]= FALSE;
          e0-&gt;bstate[ABOVE]= BUNDLE_TAIL;
        }
        e0= next_edge;
      }
    }

    horiz[CLIP]= NH;
    horiz[SUBJ]= NH;

    /* Process each edge at this scanbeam boundary */
    for (edge= aet; edge; edge= edge-&gt;next)
    {
      exists[CLIP]= edge-&gt;bundle[ABOVE][CLIP] + 
                   (edge-&gt;bundle[BELOW][CLIP] &lt;&lt; 1);
      exists[SUBJ]= edge-&gt;bundle[ABOVE][SUBJ] + 
                   (edge-&gt;bundle[BELOW][SUBJ] &lt;&lt; 1);

      if (exists[CLIP] || exists[SUBJ])
      {
        /* Set bundle side */
        edge-&gt;bside[CLIP]= parity[CLIP];
        edge-&gt;bside[SUBJ]= parity[SUBJ];

        /* Determine contributing status and quadrant occupancies */
        switch (op)
        {
        case GPC_DIFF:
        case GPC_INT:
          contributing= (exists[CLIP] &amp;&amp; (parity[SUBJ] || horiz[SUBJ]))
                     || (exists[SUBJ] &amp;&amp; (parity[CLIP] || horiz[CLIP]))
                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
          br= (parity[CLIP])
           &amp;&amp; (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
           &amp;&amp; (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP]) 
           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        case GPC_XOR:
          contributing= exists[CLIP] || exists[SUBJ];
          br= (parity[CLIP])
            ^ (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
            ^ (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        case GPC_UNION:
          contributing= (exists[CLIP] &amp;&amp; (!parity[SUBJ] || horiz[SUBJ]))
                     || (exists[SUBJ] &amp;&amp; (!parity[CLIP] || horiz[CLIP]))
                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
          br= (parity[CLIP])
           || (parity[SUBJ]);
          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
           || (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
          break;
        }

        /* Update parity */
        parity[CLIP]^= edge-&gt;bundle[ABOVE][CLIP];
        parity[SUBJ]^= edge-&gt;bundle[ABOVE][SUBJ];

        /* Update horizontal state */
        if (exists[CLIP])         
          horiz[CLIP]=
            next_h_state[horiz[CLIP]]
                        [((exists[CLIP] - 1) &lt;&lt; 1) + parity[CLIP]];
        if (exists[SUBJ])         
          horiz[SUBJ]=
            next_h_state[horiz[SUBJ]]
                        [((exists[SUBJ] - 1) &lt;&lt; 1) + parity[SUBJ]];
        
        vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);

        if (contributing)
        {
          xb= edge-&gt;xb;

          switch (vclass)
          {
          case EMN:
            new_tristrip(&amp;tlist, edge, xb, yb);
            cf= edge;
            break;
          case ERI:
            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
            if (xb != cf-&gt;xb)
              VERTEX(edge, ABOVE, RIGHT, xb, yb);
            cf= NULL;
            break;
          case ELI:
            VERTEX(edge, BELOW, LEFT, xb, yb);
            edge-&gt;outp[ABOVE]= NULL;
            cf= edge;
            break;
          case EMX:
            if (xb != cf-&gt;xb)
              VERTEX(edge, BELOW, RIGHT, xb, yb);
            edge-&gt;outp[ABOVE]= NULL;
            cf= NULL;
            break;
          case IMN:
            if (cft == LED)
        {
              if (cf-&gt;bot.y != yb)
                VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
              new_tristrip(&amp;tlist, cf, cf-&gt;xb, yb);
        }
            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
            VERTEX(edge, ABOVE, RIGHT, xb, yb);
            break;
          case ILI:
            new_tristrip(&amp;tlist, edge, xb, yb);
            cf= edge;
            cft= ILI;
            break;
          case IRI:
            if (cft == LED)
        {
              if (cf-&gt;bot.y != yb)
                VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
              new_tristrip(&amp;tlist, cf, cf-&gt;xb, yb);
        }
            VERTEX(edge, BELOW, RIGHT, xb, yb);
            edge-&gt;outp[ABOVE]= NULL;
            break;
          case IMX:
            VERTEX(edge, BELOW, LEFT, xb, yb);
            edge-&gt;outp[ABOVE]= NULL;
            cft= IMX;
            break;
      case IMM:
            VERTEX(edge, BELOW, LEFT, xb, yb);
            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
            if (xb != cf-&gt;xb)
              VERTEX(cf, ABOVE, RIGHT, xb, yb);
            cf= edge;
            break;
          case EMM:
            VERTEX(edge, BELOW, RIGHT, xb, yb);
            edge-&gt;outp[ABOVE]= NULL;
            new_tristrip(&amp;tlist, edge, xb, yb);
            cf= edge;
            break;
          case LED:
            if (edge-&gt;bot.y == yb)
              VERTEX(edge, BELOW, LEFT, xb, yb);
            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
            cf= edge;
            cft= LED;
            break;
          case RED:
            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
            if (cft == LED)
        {
              if (cf-&gt;bot.y == yb)
          {
                VERTEX(edge, BELOW, RIGHT, xb, yb);
          }
              else
          {
                if (edge-&gt;bot.y == yb)
        {
                  VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
                  VERTEX(edge, BELOW, RIGHT, xb, yb);
        }
          }
        }
            else
        {
              VERTEX(edge, BELOW, RIGHT, xb, yb);
              VERTEX(edge, ABOVE, RIGHT, xb, yb);
        }
            cf= NULL;
            break;
          default:
            break;
          } /* End of switch */
        } /* End of contributing conditional */
      } /* End of edge exists conditional */
    } /* End of AET loop */

    /* Delete terminating edges from the AET, otherwise compute xt */
    for (edge= aet; edge; edge= edge-&gt;next)
    {
      if (edge-&gt;top.y == yb)
      {
        prev_edge= edge-&gt;prev;
        next_edge= edge-&gt;next;
        if (prev_edge)
          prev_edge-&gt;next= next_edge;
        else
          aet= next_edge;
        if (next_edge)
          next_edge-&gt;prev= prev_edge;

        /* Copy bundle head state to the adjacent tail edge if required */
        if ((edge-&gt;bstate[BELOW] == BUNDLE_HEAD) &amp;&amp; prev_edge)
    {
          if (prev_edge-&gt;bstate[BELOW] == BUNDLE_TAIL)
          {
            prev_edge-&gt;outp[BELOW]= edge-&gt;outp[BELOW];
            prev_edge-&gt;bstate[BELOW]= UNBUNDLED;
            if (prev_edge-&gt;prev)
              if (prev_edge-&gt;prev-&gt;bstate[BELOW] == BUNDLE_TAIL)
                prev_edge-&gt;bstate[BELOW]= BUNDLE_HEAD;
      }
    }
      }
      else
      {
        if (edge-&gt;top.y == yt)
          edge-&gt;xt= edge-&gt;top.x;
        else
          edge-&gt;xt= edge-&gt;bot.x + edge-&gt;dx * (yt - edge-&gt;bot.y);
      }
    }

    if (scanbeam &lt; sbt_entries)
    {
      /* === SCANBEAM INTERIOR PROCESSING ============================== */
  
      build_intersection_table(&amp;it, aet, dy);

      /* Process each node in the intersection table */
      for (intersect= it; intersect; intersect= intersect-&gt;next)
      {
        e0= intersect-&gt;ie[0];
        e1= intersect-&gt;ie[1];

        /* Only generate output for contributing intersections */
        if ((e0-&gt;bundle[ABOVE][CLIP] || e0-&gt;bundle[ABOVE][SUBJ])
         &amp;&amp; (e1-&gt;bundle[ABOVE][CLIP] || e1-&gt;bundle[ABOVE][SUBJ]))
    {
          p= e0-&gt;outp[ABOVE];
          q= e1-&gt;outp[ABOVE];
          ix= intersect-&gt;point.x;
          iy= intersect-&gt;point.y + yb;

          in[CLIP]= ( e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e0-&gt;bside[CLIP])
                 || ( e1-&gt;bundle[ABOVE][CLIP] &amp;&amp;  e1-&gt;bside[CLIP])
                 || (!e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e1-&gt;bundle[ABOVE][CLIP]
                     &amp;&amp; e0-&gt;bside[CLIP] &amp;&amp; e1-&gt;bside[CLIP]);
          in[SUBJ]= ( e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e0-&gt;bside[SUBJ])
                 || ( e1-&gt;bundle[ABOVE][SUBJ] &amp;&amp;  e1-&gt;bside[SUBJ])
                 || (!e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e1-&gt;bundle[ABOVE][SUBJ]
                     &amp;&amp; e0-&gt;bside[SUBJ] &amp;&amp; e1-&gt;bside[SUBJ]);

          /* Determine quadrant occupancies */
          switch (op)
          {
          case GPC_DIFF:
          case GPC_INT:
            tr= (in[CLIP])
             &amp;&amp; (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          case GPC_XOR:
            tr= (in[CLIP])
              ^ (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          case GPC_UNION:
            tr= (in[CLIP])
             || (in[SUBJ]);
            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
            break;
          }

          vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);

          switch (vclass)
          {
          case EMN:
            new_tristrip(&amp;tlist, e1, ix, iy);
            e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
            break;
          case ERI:
            if (p)
            {
              P_EDGE(prev_edge, e0, ABOVE, px, iy);
              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
              VERTEX(e0, ABOVE, RIGHT, ix, iy);
              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
              e0-&gt;outp[ABOVE]= NULL;
            }
            break;
          case ELI:
            if (q)
            {
              N_EDGE(next_edge, e1, ABOVE, nx, iy);
              VERTEX(e1, ABOVE, LEFT, ix, iy);
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case EMX:
            if (p &amp;&amp; q)
            {
              VERTEX(e0, ABOVE, LEFT, ix, iy);
              e0-&gt;outp[ABOVE]= NULL;
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IMN:
            P_EDGE(prev_edge, e0, ABOVE, px, iy);
            VERTEX(prev_edge, ABOVE, LEFT, px, iy);
            N_EDGE(next_edge, e1, ABOVE, nx, iy);
            VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
            new_tristrip(&amp;tlist, prev_edge, px, iy); 
            e1-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
            VERTEX(e1, ABOVE, RIGHT, ix, iy);
            new_tristrip(&amp;tlist, e0, ix, iy);
            next_edge-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
            VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
            break;
          case ILI:
            if (p)
            {
              VERTEX(e0, ABOVE, LEFT, ix, iy);
              N_EDGE(next_edge, e1, ABOVE, nx, iy);
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
              e0-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IRI:
            if (q)
            {
              VERTEX(e1, ABOVE, RIGHT, ix, iy);
              P_EDGE(prev_edge, e0, ABOVE, px, iy);
              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
              e1-&gt;outp[ABOVE]= NULL;
            }
            break;
          case IMX:
            if (p &amp;&amp; q)
            {
              VERTEX(e0, ABOVE, RIGHT, ix, iy);
              VERTEX(e1, ABOVE, LEFT, ix, iy);
              e0-&gt;outp[ABOVE]= NULL;
              e1-&gt;outp[ABOVE]= NULL;
              P_EDGE(prev_edge, e0, ABOVE, px, iy);
              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
              new_tristrip(&amp;tlist, prev_edge, px, iy);
              N_EDGE(next_edge, e1, ABOVE, nx, iy);
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
              next_edge-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
            }
            break;
          case IMM:
            if (p &amp;&amp; q)
            {
              VERTEX(e0, ABOVE, RIGHT, ix, iy);
              VERTEX(e1, ABOVE, LEFT, ix, iy);
              P_EDGE(prev_edge, e0, ABOVE, px, iy);
              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
              new_tristrip(&amp;tlist, prev_edge, px, iy);
              N_EDGE(next_edge, e1, ABOVE, nx, iy);
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
              e1-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
              VERTEX(e1, ABOVE, RIGHT, ix, iy);
              new_tristrip(&amp;tlist, e0, ix, iy);
              next_edge-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
            }
            break;
          case EMM:
            if (p &amp;&amp; q)
            {
              VERTEX(e0, ABOVE, LEFT, ix, iy);
              new_tristrip(&amp;tlist, e1, ix, iy);
              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
            }
            break;
          default:
            break;
          } /* End of switch */
    } /* End of contributing intersection conditional */

        /* Swap bundle sides in response to edge crossing */
        if (e0-&gt;bundle[ABOVE][CLIP])
      e1-&gt;bside[CLIP]= !e1-&gt;bside[CLIP];
        if (e1-&gt;bundle[ABOVE][CLIP])
      e0-&gt;bside[CLIP]= !e0-&gt;bside[CLIP];
        if (e0-&gt;bundle[ABOVE][SUBJ])
      e1-&gt;bside[SUBJ]= !e1-&gt;bside[SUBJ];
        if (e1-&gt;bundle[ABOVE][SUBJ])
      e0-&gt;bside[SUBJ]= !e0-&gt;bside[SUBJ];

        /* Swap e0 and e1 bundles in the AET */
        prev_edge= e0-&gt;prev;
        next_edge= e1-&gt;next;
        if (e1-&gt;next)
          e1-&gt;next-&gt;prev= e0;

        if (e0-&gt;bstate[ABOVE] == BUNDLE_HEAD)
        {
          search= TRUE;
          while (search)
          {
            prev_edge= prev_edge-&gt;prev;
            if (prev_edge)
            {
              if (prev_edge-&gt;bundle[ABOVE][CLIP]
               || prev_edge-&gt;bundle[ABOVE][SUBJ]
               || (prev_edge-&gt;bstate[ABOVE] == BUNDLE_HEAD))
                search= FALSE;
            }
            else
              search= FALSE;
          }
        }
        if (!prev_edge)
        {
           e1-&gt;next= aet;
           aet= e0-&gt;next;
        }
        else
        {
          e1-&gt;next= prev_edge-&gt;next;
          prev_edge-&gt;next= e0-&gt;next;
        }
        e0-&gt;next-&gt;prev= prev_edge;
        e1-&gt;next-&gt;prev= e1;
        e0-&gt;next= next_edge;
      } /* End of IT loop*/

      /* Prepare for next scanbeam */
      for (edge= aet; edge; edge= next_edge)
      {
        next_edge= edge-&gt;next;
        succ_edge= edge-&gt;succ;

        if ((edge-&gt;top.y == yt) &amp;&amp; succ_edge)
        {
          /* Replace AET edge by its successor */
          succ_edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
          succ_edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
          succ_edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
          succ_edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
          prev_edge= edge-&gt;prev;
          if (prev_edge)
            prev_edge-&gt;next= succ_edge;
          else
            aet= succ_edge;
          if (next_edge)
            next_edge-&gt;prev= succ_edge;
          succ_edge-&gt;prev= prev_edge;
          succ_edge-&gt;next= next_edge;
        }
        else
        {
          /* Update this edge */
          edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
          edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
          edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
          edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
          edge-&gt;xb= edge-&gt;xt;
        }
        edge-&gt;outp[ABOVE]= NULL;
      }
    }
  } /* === END OF SCANBEAM PROCESSING ================================== */

  /* Generate result tristrip from tlist */
  result-&gt;strip= NULL;
  result-&gt;num_strips= count_tristrips(tlist);
  if (result-&gt;num_strips &gt; 0)
  {
    MALLOC(result-&gt;strip, result-&gt;num_strips * sizeof(gpc_vertex_list),
           "tristrip list creation", gpc_vertex_list);

    s= 0;
    for (tn= tlist; tn; tn= tnn)
    {
      tnn= tn-&gt;next;

      if (tn-&gt;active &gt; 2)
      {
        /* Valid tristrip: copy the vertices and free the heap */
        result-&gt;strip[s].num_vertices= tn-&gt;active;
        MALLOC(result-&gt;strip[s].vertex, tn-&gt;active * sizeof(gpc_vertex),
               "tristrip creation", gpc_vertex);
        v= 0;
        if (INVERT_TRISTRIPS)
        {
          lt= tn-&gt;v[RIGHT];
          rt= tn-&gt;v[LEFT];
        }
        else
        {
          lt= tn-&gt;v[LEFT];
          rt= tn-&gt;v[RIGHT];
        }
        while (lt || rt)
        {
          if (lt)
          {
            ltn= lt-&gt;next;
            result-&gt;strip[s].vertex[v].x= lt-&gt;x;
            result-&gt;strip[s].vertex[v].y= lt-&gt;y;
            v++;
            FREE(lt);
            lt= ltn;
          }
          if (rt)
          {
            rtn= rt-&gt;next;
            result-&gt;strip[s].vertex[v].x= rt-&gt;x;
            result-&gt;strip[s].vertex[v].y= rt-&gt;y;
            v++;
            FREE(rt);
            rt= rtn;
          }
        }
        s++;
      }
      else
      {
        /* Invalid tristrip: just free the heap */
        for (lt= tn-&gt;v[LEFT]; lt; lt= ltn)
        {
          ltn= lt-&gt;next;
          FREE(lt);
        }
        for (rt= tn-&gt;v[RIGHT]; rt; rt=rtn)
        {
          rtn= rt-&gt;next;
          FREE(rt);
        }
      }
      FREE(tn);
    }
  }

  /* Tidy up */
  reset_it(&amp;it);
  reset_lmt(&amp;lmt);
  FREE(c_heap);
  FREE(s_heap);
  FREE(sbt);
}

/*
===========================================================================
                           End of file: gpc.c
===========================================================================
*/
</t>
<t tx="karstenw.20210320123814.5">typedef struct p_shape              /* Internal contour / tristrip type  */
{
  int                 active;       /* Active flag / vertex count        */
  int                 hole;         /* Hole / external contour flag      */
  vertex_node        *v[2];         /* Left and right vertex list ptrs   */
  struct p_shape     *next;         /* Pointer to next polygon contour   */
  struct p_shape     *proxy;        /* Pointer to actual structure used  */
} polygon_node;

</t>
<t tx="karstenw.20210320123814.6">typedef struct edge_shape
{
  gpc_vertex          vertex;       /* Piggy-backed contour vertex data  */
  gpc_vertex          bot;          /* Edge lower (x, y) coordinate      */
  gpc_vertex          top;          /* Edge upper (x, y) coordinate      */
  double              xb;           /* Scanbeam bottom x coordinate      */
  double              xt;           /* Scanbeam top x coordinate         */
  double              dx;           /* Change in x for a unit y increase */
  int                 type;         /* Clip / subject edge flag          */
  int                 bundle[2][2]; /* Bundle edge flags                 */
  int                 bside[2];     /* Bundle left / right indicators    */
  bundle_state        bstate[2];    /* Edge bundle state                 */
  polygon_node       *outp[2];      /* Output polygon / tristrip pointer */
  struct edge_shape  *prev;         /* Previous edge in the AET          */
  struct edge_shape  *next;         /* Next edge in the AET              */
  struct edge_shape  *pred;         /* Edge connected at the lower end   */
  struct edge_shape  *succ;         /* Edge connected at the upper end   */
  struct edge_shape  *next_bound;   /* Pointer to next bound in LMT      */
} edge_node;

</t>
<t tx="karstenw.20210320123814.7">typedef struct lmt_shape            /* Local minima table                */
{
  double              y;            /* Y coordinate at local minimum     */
  edge_node          *first_bound;  /* Pointer to bound list             */
  struct lmt_shape   *next;         /* Pointer to next local minimum     */
} lmt_node;

</t>
<t tx="karstenw.20210320123814.8">typedef struct sbt_t_shape          /* Scanbeam tree                     */
{
  double              y;            /* Scanbeam node y value             */
  struct sbt_t_shape *less;         /* Pointer to nodes with lower y     */
  struct sbt_t_shape *more;         /* Pointer to nodes with higher y    */
} sb_tree;

</t>
<t tx="karstenw.20210320123814.9">typedef struct it_shape             /* Intersection table                */
{
  edge_node          *ie[2];        /* Intersecting edge (bundle) pair   */
  gpc_vertex          point;        /* Point of intersection             */
  struct it_shape    *next;         /* The next intersection table node  */
} it_node;

</t>
<t tx="karstenw.20210320123819.1">from distutils.core import setup, Extension

CFLAGS=[]

cPolymagic = Extension("cPolymagic", sources = ["gpc.c", "polymagic.m"], extra_compile_args=CFLAGS)

setup (name = "polymagic",
       version = "0.1",
       author = "Frederik De Bleser",
       description = "Additional utility functions for NSBezierPath using GPC.",
       ext_modules = [cPolymagic])

</t>
<t tx="karstenw.20210320125516.1">/*
===========================================================================

Project:   Generic Polygon Clipper

           A new algorithm for calculating the difference, intersection,
           exclusive-or or union of arbitrary polygon sets.

File:      gpc.h
Author:    Alan Murta (email: gpc@cs.man.ac.uk)
Version:   2.32
Date:      17th December 2004

Copyright: (C) Advanced Interfaces Group,
           University of Manchester.

           This software is free for non-commercial use. It may be copied,
           modified, and redistributed provided that this copyright notice
           is preserved on all copies. The intellectual property rights of
           the algorithms used reside with the University of Manchester
           Advanced Interfaces Group.

           You may not use this software, in whole or in part, in support
           of any commercial product without the express consent of the
           author.

           There is no warranty or other guarantee of fitness of this
           software for any purpose. It is provided solely "as is".

===========================================================================
*/

#ifndef __gpc_h
#define __gpc_h

#include &lt;stdio.h&gt;


/*
===========================================================================
                               Constants
===========================================================================
*/

/* Increase GPC_EPSILON to encourage merging of near coincident edges    */

#define GPC_EPSILON (DBL_EPSILON)

#define GPC_VERSION "2.32"


/*
===========================================================================
                           Public Data Types
===========================================================================
*/

</t>
<t tx="karstenw.20210320125621.1">/*
===========================================================================

Project:   Generic Polygon Clipper

           A new algorithm for calculating the difference, intersection,
           exclusive-or or union of arbitrary polygon sets.

File:      gpc.c
Author:    Alan Murta (email: gpc@cs.man.ac.uk)
Version:   2.32
Date:      17th December 2004

Copyright: (C) Advanced Interfaces Group,
           University of Manchester.

           This software is free for non-commercial use. It may be copied,
           modified, and redistributed provided that this copyright notice
           is preserved on all copies. The intellectual property rights of
           the algorithms used reside with the University of Manchester
           Advanced Interfaces Group.

           You may not use this software, in whole or in part, in support
           of any commercial product without the express consent of the
           author.

           There is no warranty or other guarantee of fitness of this
           software for any purpose. It is provided solely "as is".

===========================================================================
*/


/*
===========================================================================
                                Includes
===========================================================================
*/

#include "gpc.h"
#include &lt;stdlib.h&gt;
#include &lt;float.h&gt;
#include &lt;math.h&gt;


/*
===========================================================================
                                Constants
===========================================================================
*/

#ifndef TRUE
#define FALSE              0
#define TRUE               1
#endif

#define LEFT               0
#define RIGHT              1

#define ABOVE              0
#define BELOW              1

#define CLIP               0
#define SUBJ               1

#define INVERT_TRISTRIPS   FALSE


/*
===========================================================================
                                 Macros 
===========================================================================
*/

#define EQ(a, b)           (fabs((a) - (b)) &lt;= GPC_EPSILON)

#define PREV_INDEX(i, n)   ((i - 1 + n) % n)
#define NEXT_INDEX(i, n)   ((i + 1    ) % n)

#define OPTIMAL(v, i, n)   ((v[PREV_INDEX(i, n)].y != v[i].y) || \
                            (v[NEXT_INDEX(i, n)].y != v[i].y))

#define FWD_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y &gt;= v[i].vertex.y) \
                         &amp;&amp; (v[NEXT_INDEX(i, n)].vertex.y &gt; v[i].vertex.y))

#define NOT_FMAX(v, i, n)   (v[NEXT_INDEX(i, n)].vertex.y &gt; v[i].vertex.y)

#define REV_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y &gt; v[i].vertex.y) \
                         &amp;&amp; (v[NEXT_INDEX(i, n)].vertex.y &gt;= v[i].vertex.y))

#define NOT_RMAX(v, i, n)   (v[PREV_INDEX(i, n)].vertex.y &gt; v[i].vertex.y)

#define VERTEX(e,p,s,x,y)  {add_vertex(&amp;((e)-&gt;outp[(p)]-&gt;v[(s)]), x, y); \
                            (e)-&gt;outp[(p)]-&gt;active++;}

#define P_EDGE(d,e,p,i,j)  {(d)= (e); \
                            do {(d)= (d)-&gt;prev;} while (!(d)-&gt;outp[(p)]); \
                            (i)= (d)-&gt;bot.x + (d)-&gt;dx * ((j)-(d)-&gt;bot.y);}

#define N_EDGE(d,e,p,i,j)  {(d)= (e); \
                            do {(d)= (d)-&gt;next;} while (!(d)-&gt;outp[(p)]); \
                            (i)= (d)-&gt;bot.x + (d)-&gt;dx * ((j)-(d)-&gt;bot.y);}

#define MALLOC(p, b, s, t) {if ((b) &gt; 0) { \
                            p= (t*)malloc(b); if (!(p)) { \
                            fprintf(stderr, "gpc malloc failure: %s\n", s); \
                            exit(0);}} else p= NULL;}

#define FREE(p)            {if (p) {free(p); (p)= NULL;}}


/*
===========================================================================
                            Private Data Types
===========================================================================
*/

</t>
<t tx="karstenw.20210320130456.1">// dumps poly structure to log for testing/debug

static void
logPoly( gpc_polygon* poly )
{

    printf("polygon &lt;contours: %i&gt;\n", poly-&gt;num_contours);
    
    int cont;
    
    for( cont = 0; cont &lt; poly-&gt;num_contours; ++cont )
    {
        printf("contour #%i: %i vertices: \n", cont, poly-&gt;contour[cont].num_vertices);
        printf("drawpath([");

        int vert;
        for( vert = 0; vert &lt; poly-&gt;contour[cont].num_vertices; ++vert ) {
            printf("(%.3f, %.3f),", poly-&gt;contour[cont].vertex[vert].x, poly-&gt;contour[cont].vertex[vert].y);
            
        }
        printf("])");
        printf("\n------ end of contour %i ------\n", cont);
    }
    printf("------ end of polygon ------\n");
}

static int
contours_in_path(NSBezierPath *path)
{
    NSBezierPathElement    et;
    int                    sp, i, ec = [path elementCount];
    
    sp = 0;
    
    for( i = 0; i &lt; ec; ++i )
    {
        et = [path elementAtIndex:i];
        
        if ( et == NSMoveToBezierPathElement )
            ++sp;
    }
    
    return sp;    
}

static int
contours_in_path_from_el(NSBezierPath *path, int se)
{
    NSBezierPathElement    et;
    int                    sp, i, ec = [path elementCount];
    
    sp = 1;
    
    for( i = se + 1; i &lt; ec; ++i )
    {
        et = [path elementAtIndex:i];
        
        if ( et == NSMoveToBezierPathElement )
            break;
            
        ++sp;
    }
    
    return sp;
}

static gpc_polygon*
path_to_polygon(NSBezierPath *path, float flatness)
{
    [NSBezierPath setDefaultFlatness: flatness];
    [path setFlatness: flatness];
    //printf("setFlatness %.2f\n", flatness);
    
    NSBezierPath*            flat = [path bezierPathByFlatteningPath];
    NSBezierPathElement      elem;
    NSPoint                  ap[3];
    int                      i, ec = [flat elementCount];
    gpc_polygon*             poly;
    
    [flat setWindingRule:[path windingRule]];
    
    // allocate memory for the poly.
    
    poly = malloc( sizeof( gpc_polygon ));
    
    // how many contours do we need?
    
    poly-&gt;num_contours = contours_in_path(flat);
    poly-&gt;contour = malloc( sizeof( gpc_vertex_list ) * poly-&gt;num_contours );
    
    // how many elements in each contour?
    
    int es = 0;
    
    for( i = 0; i &lt; poly-&gt;num_contours; ++i )
    {
        int spc = contours_in_path_from_el(flat, es);
        //printf("contours_in_path_from_el: %i\n", spc);
    
        // allocate enough memory to hold this many points
                
        poly-&gt;contour[i].num_vertices = spc;
        poly-&gt;contour[i].vertex = malloc( sizeof( gpc_vertex ) * spc );
        
        es += spc;
    }
    
    // es will now keep track of which contour we are adding to; k is the element index within it.
    
    int k = 0;
    es = -1;
    NSPoint     spStart;
    
    for( i = 0; i &lt; ec; ++i )
    {
        elem = [flat elementAtIndex:i associatedPoints:ap];
        
        switch( elem )
        {
            case NSMoveToBezierPathElement:
            // begins a new contour.
            
            if ( es != -1 )
            {
                // close the previous contour by adding a vertex with the subpath start
                
                poly-&gt;contour[es].vertex[k].x = spStart.x;
                poly-&gt;contour[es].vertex[k].y = spStart.y;
            }
            // next contour:
            ++es;
            k = 0;
            // keep a note of the start of the subpath so we can close it
            spStart = ap[0];
            
            // sanity check es - must not exceed contour count - 1
            
            if ( es &gt;= poly-&gt;num_contours )
            {
                printf("discrepancy in contour count versus number of subpaths encountered - bailing\n");
                
                gpc_free_polygon( poly );
                return NULL;
            }
            
            // fall through to record the vertex for the moveto
            
            case NSLineToBezierPathElement:
            // add a vertex to the list
            poly-&gt;contour[es].vertex[k].x = ap[0].x;
            poly-&gt;contour[es].vertex[k].y = ap[0].y;
            ++k;
            break;
            
            case NSCurveToBezierPathElement:
                // should never happen - we have already converted the path to a flat version. Bail.
                printf("Got a curveto unexpectedly - bailing.\n");
                gpc_free_polygon( poly );
                return NULL;
                
            case NSClosePathBezierPathElement:
                // ignore
            break;
        }
    }
    
    return poly;
}

static NSBezierPath *
polygon_to_path(gpc_polygon *poly)
{
    // returns a new NSBezierPath object equivalent to the polygon passed to it. The caller is responsible for freeing
    // the polygon. The returned path is autoreleased as per usual cocoa rules.
    
    NSBezierPath*    path = [NSBezierPath bezierPath];
    NSPoint            p;
    int                cont;
    
    for( cont = 0; cont &lt; poly-&gt;num_contours; ++cont )
    {
        p.x = poly-&gt;contour[cont].vertex[0].x;
        p.y = poly-&gt;contour[cont].vertex[0].y;
        [path moveToPoint:p];
        
        int vert;
        
        for( vert = 1; vert &lt; poly-&gt;contour[cont].num_vertices; ++vert )
        {
            p.x = poly-&gt;contour[cont].vertex[vert].x;
            p.y = poly-&gt;contour[cont].vertex[vert].y;
            [path lineToPoint:p];
        }
        
        [path closePath];
    }
    
    // set the default winding rule to be the one most useful for shapes
    // with holes.
    
    [path setWindingRule:NSEvenOddWindingRule];
    
    return path;
}

static NSBezierPath *
path_operation(NSBezierPath* p1, NSBezierPath* p2, gpc_op op, float flatness)
{
    NSBezierPath*    resultPath;
    gpc_polygon        *poly1, *poly2, *resultPoly;
    
    poly1 = path_to_polygon(p1, flatness);
    poly2 = path_to_polygon(p2, flatness);
    
    resultPoly = malloc( sizeof( gpc_polygon ));
    
    // this line does all the really hard work:
    gpc_polygon_clip( op, poly1, poly2, resultPoly );

    resultPath = polygon_to_path( resultPoly );
    
    gpc_free_polygon( poly1 );
    gpc_free_polygon( poly2 );
    gpc_free_polygon( resultPoly );
    
    return resultPath;
}

static bool
intersects_path(NSBezierPath* p1, NSBezierPath* p2)
{
    NSRect        bbox = [p2 bounds];
    if ( NSIntersectsRect( bbox, [p1 bounds]))
    {
        // bounds intersect, so it's a possibility - find the intersection and see if it's empty.
        NSBezierPath* ip = path_operation(p1, p2, GPC_INT, 0.1);
        return ![ip isEmpty];
    }
    else
        return false;
}

</t>
<t tx="karstenw.20210320131053.1">#import &lt;Cocoa/Cocoa.h&gt;

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include "gpc.h"


</t>
<t tx="karstenw.20210320131126.1">static PyObject *PolymagicError;

static PyMethodDef PolymagicMethods[] = {
    {"intersects",  cPolymagic_intersects, METH_VARARGS, "Check if two NSBezierPaths intersect."},
    {"union",  cPolymagic_union, METH_VARARGS, "Calculates the union of two NSBezierPaths."},
    {"intersect",  cPolymagic_intersect, METH_VARARGS, "Calculates the intersection of two NSBezierPaths."},
    {"difference",  cPolymagic_difference, METH_VARARGS, "Calculates the difference of two NSBezierPaths."},
    {"xor",  cPolymagic_xor, METH_VARARGS, "Calculates the exclusive or of two NSBezierPaths."},
    {NULL, NULL, 0, NULL}        //  Sentinel
};

MOD_INIT(cPolymagic) {
    PyObject *m;
    
    // m = Py_InitModule("cPolymagic", PolymagicMethods);
    MOD_DEF(m, "cPolymagic", "C-Polymagic.", PolymagicMethods)
    PolymagicError = PyErr_NewException("cPolymagic.error", NULL, NULL);
    Py_INCREF(PolymagicError);
    PyModule_AddObject(m, "error", PolymagicError);
#if PY_MAJOR_VERSION &gt;= 3
    return( m );
#endif
}

</t>
<t tx="karstenw.20210320131240.1">typedef struct {
    PyObject_HEAD
    id        objc_object;
    int       flags;
} PyObjCObject;

static bool
parse_double_path_args(PyObject *self, PyObject *args, NSBezierPath **path1, NSBezierPath **path2)
{
    PyObject *pyObject1, *pyObject2;
    if (!PyArg_ParseTuple(args, "OO", &amp;pyObject1, &amp;pyObject2))
        return false;

    // Check if the two objects are NSBezierPaths.
    if (strcmp("NSBezierPath", pyObject1-&gt;ob_type-&gt;tp_name) != 0) {
        PyErr_SetString(PyExc_TypeError, "first argument is not a NSBezierPath");
        return false;
    }

    if (strcmp("NSBezierPath", pyObject2-&gt;ob_type-&gt;tp_name) != 0) {
        PyErr_SetString(PyExc_TypeError, "second argument is not a NSBezierPath");
        return false;
    }
    
    *path1 = ((PyObjCObject *) pyObject1)-&gt;objc_object;
    *path2 = ((PyObjCObject *) pyObject2)-&gt;objc_object;

    return true;
}

static PyObject *
build_objc_instance(PyTypeObject *ob_type, id obj) {
    // Because we don't want to include PyObjC on compilation,
    // we hack around the object creation by making our own
    // PyObjCObject_New.
    PyObject *result;
    result = ob_type-&gt;tp_alloc(ob_type, 0);
    ((PyObjCObject*)result)-&gt;objc_object = obj;
    ((PyObjCObject*)result)-&gt;flags = 0;
    return result;
}

// Check if two NSBezierPaths intersect.
static PyObject *
cPolymagic_intersects(PyObject *self, PyObject *args)
{
    NSBezierPath *path1, *path2;
    PyObject *result;

    if (!parse_double_path_args(self, args, &amp;path1, &amp;path2))
        return NULL;
    
    if (intersects_path(path1, path2)) {
        Py_INCREF(Py_True);
        result = Py_True;
    } else {
        Py_INCREF(Py_False);
        result = Py_False;
    }

    return result;
}

static bool
check_path_types(PyObject *pyObject1, PyObject *pyObject2) {
    // Check if the two objects are NSBezierPaths.
    if (strcmp("NSBezierPath", pyObject1-&gt;ob_type-&gt;tp_name) != 0) {
        PyErr_SetString(PyExc_TypeError, "first argument is not a NSBezierPath");
        return false;
    }

    if (strcmp("NSBezierPath", pyObject2-&gt;ob_type-&gt;tp_name) != 0) {
        PyErr_SetString(PyExc_TypeError, "second argument is not a NSBezierPath");
        return false;
    }
    return true;
}


static PyObject*
cPolymagic_operation(PyObject *self, PyObject *args, int op)
{
    PyObject *pyObject1, *pyObject2;
    NSBezierPath *path1, *path2, *pathResult;
    PyObject *result;
    PyTypeObject *cls_type;
    float flatness = 0.6;
    
    if (!PyArg_ParseTuple(args, "OO|f", &amp;pyObject1, &amp;pyObject2, &amp;flatness))
        return NULL;
        
    if (flatness &lt; 0.1) {
        flatness = 0.1;
    } else if (flatness &gt; 5.0) {
        flatness = 5.0;
    }

    if (!check_path_types(pyObject1, pyObject2))
        return NULL;

    path1 = ((PyObjCObject *) pyObject1)-&gt;objc_object;
    path2 = ((PyObjCObject *) pyObject2)-&gt;objc_object;

    pathResult = path_operation(path1, path2, op, flatness);
    [pathResult retain];
    
    // To get access to a NSBezierPath ObjC instance, we use an
    // existing reference (that from pyObject1) to build our new
    // object out of. I'm not sure if we have to indicate that 
    // we borrow this reference. Currently, nothing of that sort
    // happens.
    return build_objc_instance(pyObject1-&gt;ob_type, pathResult);
}

// Returns the union of two NSBezierPaths as a new NSBezierPath.
static PyObject *
cPolymagic_union(PyObject *self, PyObject *args)
{
    return cPolymagic_operation(self, args, GPC_UNION);
}

// Returns the intersection of two NSBezierPaths as a new NSBezierPath.
static PyObject *
cPolymagic_intersect(PyObject *self, PyObject *args)
{
    return cPolymagic_operation(self, args, GPC_INT);
}

// Returns the difference of two NSBezierPaths as a new NSBezierPath.
static PyObject *
cPolymagic_difference(PyObject *self, PyObject *args)
{
    return cPolymagic_operation(self, args, GPC_DIFF);
}

// Returns the exclusive or of two NSBezierPaths as a new NSBezierPath.
static PyObject *
cPolymagic_xor(PyObject *self, PyObject *args)
{
    return cPolymagic_operation(self, args, GPC_XOR);
}

</t>
<t tx="karstenw.20210320133430.1">int
main(int argc, char *argv[])
{
    // Pass argv[0] to the Python interpreter
    Py_SetProgramName(argv[0]);

    // Initialize the Python interpreter.  Required.
    Py_Initialize();

    // Add a static module
#if PY_MAJOR_VERSION &gt;= 3
    PyInit_cPolymagic();
#else
    initcPolymagic();
#endif

    return 0;
}
/*
int xmain(int argc, char *argv[])
{
    [[NSAutoreleasePool alloc] init];
    NSBezierPath *p1, *p2;
    NSFont *helveticaFont;
    //NSGlyph *aGlpyh;
    //p1 = [NSBezierPath bezierPathWithOvalInRect:NSMakeRect(0, 0, 100, 100)];
    //p2 = [NSBezierPath bezierPathWithOvalInRect:NSMakeRect(50, 72, 100, 100)]; // x=50 intersects

    helveticaFont = [NSFont fontWithName:@"Helvetica" size:24];
    p1 = [NSBezierPath bezierPath];
    [p1 moveToPoint:NSMakePoint(68, 100)];
    [p1 appendBezierPathWithGlyph:68 inFont:helveticaFont];
    p2 = [NSBezierPath bezierPath];
    [p2 moveToPoint:NSMakePoint(70, 100)];
    [p2 appendBezierPathWithGlyph:68 inFont:helveticaFont];
    
    printf("p1: %i\n", [p1 elementCount]);
    if (intersects_path(p1, p2)) {
        printf("INTERSECTS\n");
    } else {
        printf("Doesn't intersect.\n");
    }
    [p1 release];
    [p2 release];
    return 0;
}

*/

</t>
<t tx="karstenw.20210322113242.1"># py3 stuff
py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr
    long = int

</t>
<t tx="karstenw.20210322113320.1">PyObjCTools.AppHelper.runEventLoop()
</t>
<t tx="karstenw.20210323114020.1">from keyword import kwlist as keywordsList
keywordsList = keywordsList[:]
keywordsList += ["None", "True", "False"]
keywordsList += graphics.__all__
keywordsList += util.__all__
keywordsList += dir(graphics.Context)

# These keywords were not captured somehow
keywordsList += ["MOUSEX", "MOUSEY", "mousedown", "keydown", "key",
                 "scrollwheel", "wheeldelta", "PAGENUM", "keycode",
                 "FRAME", "canvas"]


# Build up a regular expression which will match anything
# interesting, including multi-line triple-quoted strings.
commentPat = r"#[^\n]*"

pat = r"[uU]?[rR]?q[^\\q\n]*(\\[\000-\377][^\\q\n]*)*q?"
quotePat = pat.replace("q", "'") + "|" + pat.replace('q', '"')

# Way to go, Tim!
pat = r"""
    [uU]?[rR]?
    qqq
    [^\\q]*
    (
        (	\\[\000-\377]
        |	q
            (	\\[\000-\377]
            |	[^\q]
            |	q
                (	\\[\000-\377]
                |	[^\\q]
                )
            )
        )
        [^\\q]*
    )*
    (qqq)?
"""
pat = "".join(pat.split())  # get rid of whitespace
tripleQuotePat = pat.replace("q", "'") + "|" + pat.replace('q', '"')

# Build up a regular expression which matches all and only
# Python keywords. This will let us skip the uninteresting
# identifier references.
keyPat = r"\b(" + "|".join(keywordsList) + r")\b"

matchPat = commentPat + "|" + keyPat + "|(" + tripleQuotePat + "|" + quotePat + ")"
matchRE = re.compile(matchPat)

idKeyPat = "[ \t]*([A-Za-z_][A-Za-z_0-9.]*)"	# Ident w. leading whitespace.
idRE = re.compile(idKeyPat)
asRE = re.compile(r".*?\b(as)\b")

</t>
<t tx="karstenw.20210623180227.1"># modified NSApplication object
class NodeBoxApplication(NSApplication):

    @others


</t>
<t tx="karstenw.20210623180253.1">def awakeFromNib(self):
    if kwlog:
        print("AppClass.awakeFromNib()")
    objc.super(NodeBoxApplication, self).awakeFromNib()

</t>
<t tx="karstenw.20210623180302.1">def finishLaunching(self):
    if kwlog:
        print("AppClass.finishLaunching()")
    objc.super(NodeBoxApplication, self).finishLaunching()

</t>
<t tx="karstenw.20210623195428.1">def fractalimage( self, clut, w,h,iterations,x1,y1,dx,dy,nreal,nimag,limit):
    return nodebox.geo.fractalimage(clut, w,h,iterations,x1,y1,
                                        dx,dy,nreal,nimag,limit)

</t>
<t tx="karstenw.20210624121624.1">@objc.IBAction
def clearMessageArea_(self, sender):
    # pp( dir(self.outputView.textStorage()))
    self.outputView.textStorage().mutableString().setString_(u"")

</t>
<t tx="karstenw.20210628212143.1">def getFunctionArgCount( function ):
    # pdb.set_trace()
    if py3:
        return function.__code__.co_argcount
    else:
        return function.func_code.co_argcount


</t>
<t tx="karstenw.20210630133918.1">    pstr = bytes
    py3 = True
    punichr = chr
    long = int


def sortlistfunction(thelist, thecompare):
    if py3:
        sortkeyfunction = cmp_to_key( thecompare )
        thelist.sort( key=sortkeyfunction )
    else:
        thelist.sort( thecompare )

</t>
<t tx="karstenw.20210630165621.1">#if PY_MAJOR_VERSION &gt;= 3
  #define IN_FORMAT "y#iiii"
  #define OUT_FORMAT "y#"
#else
  #define IN_FORMAT "s#iiii"
  #define OUT_FORMAT "s#"
#endif
</t>
<t tx="karstenw.20210630171229.1">#if PY_MAJOR_VERSION &gt;= 3
  #define IN_FORMAT "y#iiiddddddd"
  #define OUT_FORMAT "y#"
#else
  #define IN_FORMAT "s#iiiddddddd"
  #define OUT_FORMAT "s#"
#endif

</t>
<t tx="karstenw.20210703124707.1">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    if type(s) not in ( pstr, punicode):
        s = str(s)
    if type(s) not in ( punicode, ):
        try:
            s = punicode(s, srcencoding)
        except TypeError as err:
            pass
    if type(s) in ( punicode, ):
        s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20210714232328.1">def __hash__(self):
    return hash( (self.x, self.y, self.ctrl1, self.ctrl2) )


</t>
<t tx="karstenw.20210714232606.1">def __hash__( self ):
    return hash( (self.x, self.y) )


</t>
<t tx="karstenw.20210714232702.1">def __lt__(self, other):
    return (self.x &lt; other.x) and (self.y &lt; other.y)

def __le__(self, other):
    return (self.x &lt;= other.x) and (self.y &lt;= other.y)

def __gt__(self, other):
    return (self.x &gt; other.x) and (self.y &gt; other.y)

def __ge__(self, other):
    return (self.x &gt;= other.x) and (self.y &gt;= other.y)

# added from squeaklib
def __add__( self, other):
    if not isinstance(other, Point):
        other = makePoint( other )
    return Point( self.x + other.x, self.y + other.y )

def __sub__( self, other):
    if not isinstance(other, Point):
        other = makePoint( other )
    return Point( self.x - other.x, self.y - other.y )

def __mul__( self, other):
    if isinstance(other, Point):
        return Point( self.x * other.x, self.y * other.y )
    return Point( self.x * other, self.y * other )

def __truediv__( self, other):
    if isinstance(other, Point):
        return Point( self.x / other.x, self.y / other.y )
    return Point( self.x / other, self.y / other )

</t>
<t tx="karstenw.20210714234429.1">def __lt__(self, other):
    return (    (self.x &lt; other.x) and (self.y &lt; other.y)
            and (self.ctrl1 &lt; other.ctrl1) and (self.ctrl2 &lt; other.ctrl2) )

</t>
<t tx="karstenw.20210714234443.1">def __le__(self, other):
    return (    (self.x &lt;= other.x) and (self.y &lt;= other.y)
            and (self.ctrl1 &lt;= other.ctrl1) and (self.ctrl2 &lt;= other.ctrl2) )

</t>
<t tx="karstenw.20210714234451.1">def __gt__(self, other):
    return (    (self.x &gt; other.x) and (self.y &gt; other.y)
            and (self.ctrl1 &gt; other.ctrl1) and (self.ctrl2 &gt; other.ctrl2) )

</t>
<t tx="karstenw.20210714234458.1">def __ge__(self, other):
    return (    (self.x &gt;= other.x) and (self.y &gt;= other.y)
            and (self.ctrl1 &gt;= other.ctrl1) and (self.ctrl2 &gt;= other.ctrl2) ) 


</t>
<t tx="karstenw.20210715171431.1">def __hash__( self ):
    return hash( (self.red, self.green, self.blue, self.alpha) )


</t>
<t tx="karstenw.20211017190738.1">gBGCol = NSColor.colorWithCalibratedRed_green_blue_alpha_( 0.4,0.4,0.4, 1.0)
gStrCol = NSColor.colorWithCalibratedRed_green_blue_alpha_( 0.1,0.1,0.1, 1.0)
gTxtCol = NSColor.colorWithCalibratedRed_green_blue_alpha_( 1.0,1.0,1.0, 1.0)

MAGICVAR = "__magic_var__"

</t>
<t tx="karstenw.20211125131320.1">def init(self):

    self = self.initWithWindowNibName_( "AskString" )
    self.question = u"" #question
    self.resultCallback = None # resultCallback
    self.default = u"" #default
    self.parentWindow = None #parentWindow
    self.retain()
    return self

</t>
<t tx="karstenw.20211125131451.1"></t>
<t tx="karstenw.20211127131740.1">def windowDidLoad( self ):
    print("AskStringWindowController.windowDidLoad()")
    print( "self.window()", self.window() )
    return objc.super(AskStringWindowController, self).windowDidLoad()


def windowWillLoad( self ):
    # pdb.set_trace()
    print("AskStringWindowController.windowWillLoad()")
    return objc.super(AskStringWindowController, self).windowWillLoad()

</t>
<t tx="karstenw.20211204132045.1">def AskString(question, resultCallback, default="", parentWindow=None):
    p = AskStringWindowController.alloc().init()
    p.setup_cb_default_parent_(question, resultCallback, default, parentWindow)


</t>
<t tx="karstenw.20230216113142.1">def applicationShouldOpenUntitledFile_( self, sender ):
    """Reopen last opened files. See also applicationWillTerminate_()"""

    if kwlog:
        print( "applicationShouldOpenUntitledFile_()" )
    defaults = NSUserDefaults.standardUserDefaults()
    documents = defaults.arrayForKey_( u"lastSessionURLs" )

    if len(documents) &gt; 0:
        controller = NSDocumentController.sharedDocumentController()
        for fileurl in documents:
            url = NSURL.URLWithString_( fileurl )
            theerr = controller.openDocumentWithContentsOfURL_display_error_( url, True, None )
            if kwdbg:
                print( theerr )
        return False
    else:
        # TODO read / write empty file open preferences here
        return True


</t>
<t tx="karstenw.20230216115950.1"># NOT NOW
#def applicationShouldHandleReopen_hasVisibleWindows_(self, sender, flag ):
#    return not flag


</t>
<t tx="karstenw.20230216131548.1"></t>
<t tx="karstenw.20230217121258.1">def scanmodule( self, module):
    types = {}
    # pdb.set_trace()
    for name in module.__dict__:
        inst = module.__dict__[name]
        t = type(inst)
        try:
            tn = inst.__class__.__name__
        except:
            tn = str(t)
        if tn not in types:
            types[tn] = []
        if tn == 'function':
            print( "co_filename:", name, inst.__code__.co_filename )
        types[tn].append(name)
    return types

</t>
<t tx="karstenw.20230718091743.1">### Path methods ###

</t>
<t tx="karstenw.20230718091902.1">### Basic shapes ###

</t>
<t tx="karstenw.20230718091919.1">### List methods ###

</t>
<t tx="karstenw.20230718092007.1">### Drawing methods ###

</t>
<t tx="karstenw.20230718092025.1">### Geometry ###

</t>
<t tx="karstenw.20230718092146.1">### Clipping operations ###

</t>
<t tx="karstenw.20230718111102.1">@language python
@tabwidth -4
@others
if __name__=='__main__':
    main()
</t>
<t tx="karstenw.20230718111113.1">

import sys
import os
import io
# import pdb
import subprocess

import AppKit
NSApplication = AppKit.NSApplication

try:
    import nodebox
except ImportError:
    nodebox_dir = os.path.dirname(os.path.abspath(__file__))
    sys.path.append(os.path.dirname(nodebox_dir))

import nodebox.graphics
graphics = nodebox.graphics

import nodebox.util
util = nodebox.util

librarypath = "NONE"
try:
    # pdb.set_trace()
    result = subprocess.run([ "defaults","read","net.nodebox.NodeBox","libraryPath" ], capture_output=True)
    
    p = result.stdout  #os.system("/usr/bin/defaults read net.nodebox.NodeBox libraryPath")
    p = p.strip( b" \t\n\r" )
    p = str(p,encoding="utf-8")
    if os.path.exists(p):
        librarypath = p
        sys.path.insert(0, librarypath)
except:
    librarypath = False
print("librarypath:", repr(librarypath))


</t>
<t tx="karstenw.20230718111113.10">def usage(err=""):
    if len(err) &gt; 0:
        err = '\n\nError: ' + str(err)
    print("""NodeBox console runner
Usage: console.py sourcefile imagefile
   or: console.py sourcefile moviefile number_of_frames [fps]
Supported image extensions: pdf, tiff, png, jpg, gif
Supported movie extension:  mov""" + err)

</t>
<t tx="karstenw.20230718111113.11">def main():
    if len(sys.argv) &lt; 2:
        usage()
    elif len(sys.argv) == 3: # Should be an image
        basename, ext = os.path.splitext(sys.argv[2])
        if ext not in ('.pdf', '.gif', '.jpg', '.jpeg', '.png', '.tiff'):
            return usage('This is not a supported image format.')
        make_image(open(sys.argv[1]).read(), sys.argv[2])
    elif len(sys.argv) == 4 or len(sys.argv) == 5: # Should be a movie
        basename, ext = os.path.splitext(sys.argv[2])
        if ext != '.mov':
            return usage('This is not a supported movie format.')
        if len(sys.argv) == 5:
            try:
                fps = int(sys.argv[4])
            except ValueError:
                return usage()
        else:
            fps = 30
        make_movie(open(sys.argv[1]).read(), sys.argv[2], int(sys.argv[3]), fps)

</t>
<t tx="karstenw.20230718111113.12">def test():
    # Creating the NodeBoxRunner class directly:
    runner = NodeBoxRunner()
    testscript = ('size(500,500)\n'
                  'for i in range(400):\n'
                  '  oval(random(WIDTH),random(HEIGHT),50,50, '
                  'fill=(random(), 0,0,random()))')
    runner.run(testscript)
    runner.canvas.save('console-test.pdf')
    runner.canvas.save('console-test.png')
    
    # Using the runner for animations:
    runner = NodeBoxRunner()
    for frame in runner.run_multiple('size(300, 300)\ntext(FRAME, 100, 100)', 10):
        runner.canvas.save('console-test-frame%02i.png' % frame)

    # Using the shortcut functions:
    make_image('size(200,200)\ntext(FRAME, 100, 100)', 'console-test.gif')
    make_movie('size(200,200)\ntext(FRAME, 100, 100)', 'console-test.mov', 10)

</t>
<t tx="karstenw.20230718111113.2">class NodeBoxRunner(object):
    
    @others
</t>
<t tx="karstenw.20230718111113.3">def __init__(self):
    # Force NSApp initialisation.
    NSApplication.sharedApplication().activateIgnoringOtherApps_(0)
    self.namespace = {}
    self.canvas = graphics.Canvas()
    self.context = graphics.Context(self.canvas, self.namespace)
    self.__doc__ = {}
    self._pageNumber = 1
    self.frame = 1
    self.library = False
    
    
</t>
<t tx="karstenw.20230718111113.4">def _check_animation(self):
    """Returns False if this is not an animation, True otherwise.
    Throws an expection if the animation is not correct (missing a draw method)."""
    if self.canvas.speed is not None:
        if 'draw' not in self.namespace:
            raise( graphics.NodeBoxError('Not a correct animation: No draw() method.') )
        return True
    return False
    
</t>
<t tx="karstenw.20230718111113.5">def run(self, source_or_code):
    self._initNamespace()
    if isinstance(source_or_code, str):
        source_or_code = compile(source_or_code + "\n\n", "&lt;Untitled&gt;", "exec")
    exec( source_or_code, self.namespace, self.namespace ) 
    if self._check_animation():
        if 'setup' in self.namespace:
            self.namespace['setup']()
        self.namespace['draw']()
    
</t>
<t tx="karstenw.20230718111113.6">def run_multiple(self, source_or_code, frames):
    if isinstance(source_or_code, str):
        source_or_code = compile(source_or_code + "\n\n", "&lt;Untitled&gt;", "exec")
        
    # First frame is special:
    self.run(source_or_code)
    yield 1
    animation = self._check_animation()
        
    for i in range(frames-1):
        self.canvas.clear()
        self.frame = i + 2
        self.namespace["PAGENUM"] = self.namespace["FRAME"] = self.frame
        if animation:
            self.namespace['draw']()
        else:
            exec( source_or_code, self.namespace, self.namespace )
        yield self.frame

</t>
<t tx="karstenw.20230718111113.7">def _initNamespace(self, frame=1):
    self.canvas.clear()
    self.namespace.clear()
    # Add everything from the namespace
    for name in graphics.__all__:
        self.namespace[name] = getattr(graphics, name)
    for name in util.__all__:
        self.namespace[name] = getattr(util, name)
    # Add everything from the context object
    self.namespace["_ctx"] = self.context
    for attrName in dir(self.context):
        self.namespace[attrName] = getattr(self.context, attrName)
    # Add the document global
    self.namespace["__doc__"] = self.__doc__
    # Add the frame
    self.frame = frame
    self.namespace["PAGENUM"] = self.namespace["FRAME"] = self.frame
    
</t>
<t tx="karstenw.20230718111113.8">def make_image(source_or_code, outputfile):
    
    """Given a source string or code object, executes the scripts and saves the result as
    an image.  Supported image extensions: pdf, tiff, png, jpg, gif"""
    
    if os.path.exists( source_or_code ):
        f = io.open( source_or_code, encoding="utf-8" )
        source_or_code = f.read()
        f.close()
        
    runner = NodeBoxRunner()
    runner.run(source_or_code)
    runner.canvas.save(outputfile)
    return source_or_code
    
    
</t>
<t tx="karstenw.20230718111113.9">def make_movie(source_or_code, outputfile, frames, fps=30):

    """Given a source string or code object, executes the scripts and saves the result as
    a movie.
    
    You also have to specify the number of frames to render.
    Supported movie extension: mov"""

    from nodebox.util import QTSupport
    runner = NodeBoxRunner()
    movie = QTSupport.Movie(outputfile, fps)
    for frame in runner.run_multiple(source_or_code, frames):
        movie.add(runner.canvas)
    movie.save()

</t>
<t tx="karstenw.20250718093121.1"></t>
<t tx="karstenw.20251222122048.1"></t>
<t tx="karstenw.20251222122634.1"></t>
<t tx="karstenw.20251222122658.1">def sign( number ):
    """I can't believe that Python does not have a sign() function."""

    if number &gt; 0:
        return +1
    elif number &lt; 0:
        return -1
    return 0


</t>
<t tx="karstenw.20251222122705.1">def makePoint( *args  ):
    """Tries to create a Point from args."""
    
    n = len(args)
    
    if n == 1:
        typ = type( args[0] )
        if typ in (Point,):
            return args[0]
        elif typ in (long, int, float):
            return Point( args[0], args[0] )
        elif typ in (list, tuple):
            return Point( args[0][0], args[0][1] )
    elif n == 2:
        return Point( args[0], args[1] )
    return None

</t>
</tnodes>
</leo_file>
